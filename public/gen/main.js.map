{"version":3,"file":"main.js","mappings":"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","sources":["webpack://@dobuki/compression/./node_modules/blueimp-md5/js/md5.js","webpack://@dobuki/compression/./node_modules/stream-data-view/dist/index.js","webpack://@dobuki/compression/webpack/bootstrap","webpack://@dobuki/compression/webpack/runtime/compat get default export","webpack://@dobuki/compression/webpack/runtime/define property getters","webpack://@dobuki/compression/webpack/runtime/hasOwnProperty shorthand","webpack://@dobuki/compression/./src/io/Loader.ts","webpack://@dobuki/compression/./src/compression/TokenEncoder.ts","webpack://@dobuki/compression/./src/reducer/Reducer.ts","webpack://@dobuki/compression/./node_modules/fflate/esm/browser.js","webpack://@dobuki/compression/./src/compression/FFlateEncoder.ts","webpack://@dobuki/compression/./src/tokenizer/Token.ts","webpack://@dobuki/compression/./src/tokenizer/Tokenizer.ts","webpack://@dobuki/compression/./src/expander/Extractor.ts","webpack://@dobuki/compression/./src/compression/Compressor.ts","webpack://@dobuki/compression/./src/index.ts"],"sourcesContent":["/*\n * JavaScript MD5\n * https://github.com/blueimp/JavaScript-MD5\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n *\n * Based on\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n * Digest Algorithm, as defined in RFC 1321.\n * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for more info.\n */\n\n/* global define */\n\n/* eslint-disable strict */\n\n;(function ($) {\n  'use strict'\n\n  /**\n   * Add integers, wrapping at 2^32.\n   * This uses 16-bit operations internally to work around bugs in interpreters.\n   *\n   * @param {number} x First integer\n   * @param {number} y Second integer\n   * @returns {number} Sum\n   */\n  function safeAdd(x, y) {\n    var lsw = (x & 0xffff) + (y & 0xffff)\n    var msw = (x >> 16) + (y >> 16) + (lsw >> 16)\n    return (msw << 16) | (lsw & 0xffff)\n  }\n\n  /**\n   * Bitwise rotate a 32-bit number to the left.\n   *\n   * @param {number} num 32-bit number\n   * @param {number} cnt Rotation count\n   * @returns {number} Rotated number\n   */\n  function bitRotateLeft(num, cnt) {\n    return (num << cnt) | (num >>> (32 - cnt))\n  }\n\n  /**\n   * Basic operation the algorithm uses.\n   *\n   * @param {number} q q\n   * @param {number} a a\n   * @param {number} b b\n   * @param {number} x x\n   * @param {number} s s\n   * @param {number} t t\n   * @returns {number} Result\n   */\n  function md5cmn(q, a, b, x, s, t) {\n    return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b)\n  }\n  /**\n   * Basic operation the algorithm uses.\n   *\n   * @param {number} a a\n   * @param {number} b b\n   * @param {number} c c\n   * @param {number} d d\n   * @param {number} x x\n   * @param {number} s s\n   * @param {number} t t\n   * @returns {number} Result\n   */\n  function md5ff(a, b, c, d, x, s, t) {\n    return md5cmn((b & c) | (~b & d), a, b, x, s, t)\n  }\n  /**\n   * Basic operation the algorithm uses.\n   *\n   * @param {number} a a\n   * @param {number} b b\n   * @param {number} c c\n   * @param {number} d d\n   * @param {number} x x\n   * @param {number} s s\n   * @param {number} t t\n   * @returns {number} Result\n   */\n  function md5gg(a, b, c, d, x, s, t) {\n    return md5cmn((b & d) | (c & ~d), a, b, x, s, t)\n  }\n  /**\n   * Basic operation the algorithm uses.\n   *\n   * @param {number} a a\n   * @param {number} b b\n   * @param {number} c c\n   * @param {number} d d\n   * @param {number} x x\n   * @param {number} s s\n   * @param {number} t t\n   * @returns {number} Result\n   */\n  function md5hh(a, b, c, d, x, s, t) {\n    return md5cmn(b ^ c ^ d, a, b, x, s, t)\n  }\n  /**\n   * Basic operation the algorithm uses.\n   *\n   * @param {number} a a\n   * @param {number} b b\n   * @param {number} c c\n   * @param {number} d d\n   * @param {number} x x\n   * @param {number} s s\n   * @param {number} t t\n   * @returns {number} Result\n   */\n  function md5ii(a, b, c, d, x, s, t) {\n    return md5cmn(c ^ (b | ~d), a, b, x, s, t)\n  }\n\n  /**\n   * Calculate the MD5 of an array of little-endian words, and a bit length.\n   *\n   * @param {Array} x Array of little-endian words\n   * @param {number} len Bit length\n   * @returns {Array<number>} MD5 Array\n   */\n  function binlMD5(x, len) {\n    /* append padding */\n    x[len >> 5] |= 0x80 << len % 32\n    x[(((len + 64) >>> 9) << 4) + 14] = len\n\n    var i\n    var olda\n    var oldb\n    var oldc\n    var oldd\n    var a = 1732584193\n    var b = -271733879\n    var c = -1732584194\n    var d = 271733878\n\n    for (i = 0; i < x.length; i += 16) {\n      olda = a\n      oldb = b\n      oldc = c\n      oldd = d\n\n      a = md5ff(a, b, c, d, x[i], 7, -680876936)\n      d = md5ff(d, a, b, c, x[i + 1], 12, -389564586)\n      c = md5ff(c, d, a, b, x[i + 2], 17, 606105819)\n      b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330)\n      a = md5ff(a, b, c, d, x[i + 4], 7, -176418897)\n      d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426)\n      c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341)\n      b = md5ff(b, c, d, a, x[i + 7], 22, -45705983)\n      a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416)\n      d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417)\n      c = md5ff(c, d, a, b, x[i + 10], 17, -42063)\n      b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162)\n      a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682)\n      d = md5ff(d, a, b, c, x[i + 13], 12, -40341101)\n      c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290)\n      b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329)\n\n      a = md5gg(a, b, c, d, x[i + 1], 5, -165796510)\n      d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632)\n      c = md5gg(c, d, a, b, x[i + 11], 14, 643717713)\n      b = md5gg(b, c, d, a, x[i], 20, -373897302)\n      a = md5gg(a, b, c, d, x[i + 5], 5, -701558691)\n      d = md5gg(d, a, b, c, x[i + 10], 9, 38016083)\n      c = md5gg(c, d, a, b, x[i + 15], 14, -660478335)\n      b = md5gg(b, c, d, a, x[i + 4], 20, -405537848)\n      a = md5gg(a, b, c, d, x[i + 9], 5, 568446438)\n      d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690)\n      c = md5gg(c, d, a, b, x[i + 3], 14, -187363961)\n      b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501)\n      a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467)\n      d = md5gg(d, a, b, c, x[i + 2], 9, -51403784)\n      c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473)\n      b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734)\n\n      a = md5hh(a, b, c, d, x[i + 5], 4, -378558)\n      d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463)\n      c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562)\n      b = md5hh(b, c, d, a, x[i + 14], 23, -35309556)\n      a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060)\n      d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353)\n      c = md5hh(c, d, a, b, x[i + 7], 16, -155497632)\n      b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640)\n      a = md5hh(a, b, c, d, x[i + 13], 4, 681279174)\n      d = md5hh(d, a, b, c, x[i], 11, -358537222)\n      c = md5hh(c, d, a, b, x[i + 3], 16, -722521979)\n      b = md5hh(b, c, d, a, x[i + 6], 23, 76029189)\n      a = md5hh(a, b, c, d, x[i + 9], 4, -640364487)\n      d = md5hh(d, a, b, c, x[i + 12], 11, -421815835)\n      c = md5hh(c, d, a, b, x[i + 15], 16, 530742520)\n      b = md5hh(b, c, d, a, x[i + 2], 23, -995338651)\n\n      a = md5ii(a, b, c, d, x[i], 6, -198630844)\n      d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415)\n      c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905)\n      b = md5ii(b, c, d, a, x[i + 5], 21, -57434055)\n      a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571)\n      d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606)\n      c = md5ii(c, d, a, b, x[i + 10], 15, -1051523)\n      b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799)\n      a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359)\n      d = md5ii(d, a, b, c, x[i + 15], 10, -30611744)\n      c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380)\n      b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649)\n      a = md5ii(a, b, c, d, x[i + 4], 6, -145523070)\n      d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379)\n      c = md5ii(c, d, a, b, x[i + 2], 15, 718787259)\n      b = md5ii(b, c, d, a, x[i + 9], 21, -343485551)\n\n      a = safeAdd(a, olda)\n      b = safeAdd(b, oldb)\n      c = safeAdd(c, oldc)\n      d = safeAdd(d, oldd)\n    }\n    return [a, b, c, d]\n  }\n\n  /**\n   * Convert an array of little-endian words to a string\n   *\n   * @param {Array<number>} input MD5 Array\n   * @returns {string} MD5 string\n   */\n  function binl2rstr(input) {\n    var i\n    var output = ''\n    var length32 = input.length * 32\n    for (i = 0; i < length32; i += 8) {\n      output += String.fromCharCode((input[i >> 5] >>> i % 32) & 0xff)\n    }\n    return output\n  }\n\n  /**\n   * Convert a raw string to an array of little-endian words\n   * Characters >255 have their high-byte silently ignored.\n   *\n   * @param {string} input Raw input string\n   * @returns {Array<number>} Array of little-endian words\n   */\n  function rstr2binl(input) {\n    var i\n    var output = []\n    output[(input.length >> 2) - 1] = undefined\n    for (i = 0; i < output.length; i += 1) {\n      output[i] = 0\n    }\n    var length8 = input.length * 8\n    for (i = 0; i < length8; i += 8) {\n      output[i >> 5] |= (input.charCodeAt(i / 8) & 0xff) << i % 32\n    }\n    return output\n  }\n\n  /**\n   * Calculate the MD5 of a raw string\n   *\n   * @param {string} s Input string\n   * @returns {string} Raw MD5 string\n   */\n  function rstrMD5(s) {\n    return binl2rstr(binlMD5(rstr2binl(s), s.length * 8))\n  }\n\n  /**\n   * Calculates the HMAC-MD5 of a key and some data (raw strings)\n   *\n   * @param {string} key HMAC key\n   * @param {string} data Raw input string\n   * @returns {string} Raw MD5 string\n   */\n  function rstrHMACMD5(key, data) {\n    var i\n    var bkey = rstr2binl(key)\n    var ipad = []\n    var opad = []\n    var hash\n    ipad[15] = opad[15] = undefined\n    if (bkey.length > 16) {\n      bkey = binlMD5(bkey, key.length * 8)\n    }\n    for (i = 0; i < 16; i += 1) {\n      ipad[i] = bkey[i] ^ 0x36363636\n      opad[i] = bkey[i] ^ 0x5c5c5c5c\n    }\n    hash = binlMD5(ipad.concat(rstr2binl(data)), 512 + data.length * 8)\n    return binl2rstr(binlMD5(opad.concat(hash), 512 + 128))\n  }\n\n  /**\n   * Convert a raw string to a hex string\n   *\n   * @param {string} input Raw input string\n   * @returns {string} Hex encoded string\n   */\n  function rstr2hex(input) {\n    var hexTab = '0123456789abcdef'\n    var output = ''\n    var x\n    var i\n    for (i = 0; i < input.length; i += 1) {\n      x = input.charCodeAt(i)\n      output += hexTab.charAt((x >>> 4) & 0x0f) + hexTab.charAt(x & 0x0f)\n    }\n    return output\n  }\n\n  /**\n   * Encode a string as UTF-8\n   *\n   * @param {string} input Input string\n   * @returns {string} UTF8 string\n   */\n  function str2rstrUTF8(input) {\n    return unescape(encodeURIComponent(input))\n  }\n\n  /**\n   * Encodes input string as raw MD5 string\n   *\n   * @param {string} s Input string\n   * @returns {string} Raw MD5 string\n   */\n  function rawMD5(s) {\n    return rstrMD5(str2rstrUTF8(s))\n  }\n  /**\n   * Encodes input string as Hex encoded string\n   *\n   * @param {string} s Input string\n   * @returns {string} Hex encoded string\n   */\n  function hexMD5(s) {\n    return rstr2hex(rawMD5(s))\n  }\n  /**\n   * Calculates the raw HMAC-MD5 for the given key and data\n   *\n   * @param {string} k HMAC key\n   * @param {string} d Input string\n   * @returns {string} Raw MD5 string\n   */\n  function rawHMACMD5(k, d) {\n    return rstrHMACMD5(str2rstrUTF8(k), str2rstrUTF8(d))\n  }\n  /**\n   * Calculates the Hex encoded HMAC-MD5 for the given key and data\n   *\n   * @param {string} k HMAC key\n   * @param {string} d Input string\n   * @returns {string} Raw MD5 string\n   */\n  function hexHMACMD5(k, d) {\n    return rstr2hex(rawHMACMD5(k, d))\n  }\n\n  /**\n   * Calculates MD5 value for a given string.\n   * If a key is provided, calculates the HMAC-MD5 value.\n   * Returns a Hex encoded string unless the raw argument is given.\n   *\n   * @param {string} string Input string\n   * @param {string} [key] HMAC key\n   * @param {boolean} [raw] Raw output switch\n   * @returns {string} MD5 output\n   */\n  function md5(string, key, raw) {\n    if (!key) {\n      if (!raw) {\n        return hexMD5(string)\n      }\n      return rawMD5(string)\n    }\n    if (!raw) {\n      return hexHMACMD5(key, string)\n    }\n    return rawHMACMD5(key, string)\n  }\n\n  if (typeof define === 'function' && define.amd) {\n    define(function () {\n      return md5\n    })\n  } else if (typeof module === 'object' && module.exports) {\n    module.exports = md5\n  } else {\n    $.md5 = md5\n  }\n})(this)\n","!function(t,e){if(\"object\"==typeof exports&&\"object\"==typeof module)module.exports=e();else if(\"function\"==typeof define&&define.amd)define([],e);else{var n=e();for(var i in n)(\"object\"==typeof exports?exports:t)[i]=n[i]}}(this,(function(){return(()=>{\"use strict\";var t={d:(e,n)=>{for(var i in n)t.o(n,i)&&!t.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:n[i]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(t,\"__esModule\",{value:!0})}},e={};t.r(e),t.d(e,{StreamDataView:()=>o});var n=function(){function t(t){this.encoding=t||\"utf-8\"}return t.prototype.decode=function(t){var e=String.fromCharCode.apply(null,Array.from(t));return\"utf-8\"===this.encoding?decodeURIComponent(escape(e)):e},t}(),i=function(){function t(t){this.encoding=t||\"utf-8\"}return t.prototype.encode=function(t){return\"utf-8\"===this.encoding&&(t=unescape(encodeURIComponent(t))),new Uint8Array(t.split(\"\").map((function(t){return t.charCodeAt(0)})))},t}(),o=function(){function t(t,e){this.offset=0,this.autoResize=!1,void 0===t&&(t=0,this.autoResize=!0),\"number\"==typeof t&&(t=new ArrayBuffer(t)),this.view=new DataView(t),this.littleEndian=!e}return t.fromByteString=function(e){var n=new t(e.split(\" \").length);return n.fromByteString(e),n},t.fromTextString=function(e,n){var o,s=new t((o=n?new i(\"utf-8\").encode(e):new i(\"ascii\").encode(e)).length);return s.setNextString(e,n,o.length),s},t.prototype.resize=function(t){var e=function(t,e){if(!(t instanceof ArrayBuffer))throw new TypeError(\"Source must be an instance of ArrayBuffer\");if(e<=t.byteLength)return t.slice(0,e);var n=new Uint8Array(t),i=new Uint8Array(new ArrayBuffer(e));return i.set(n),i.buffer}(this.getBuffer(),t);this.view=new DataView(e)},t.prototype.crop=function(){this.resize(this.getOffset())},t.prototype.getBuffer=function(){return this.view.buffer},t.prototype.skip=function(t){this.offset+=t},t.prototype.resetOffset=function(){this.offset=0},t.prototype.getOffset=function(){return this.offset},t.prototype.setOffset=function(t){this.offset=t},t.prototype.getInt8=function(t){return this.view.getInt8(t)},t.prototype.getUint8=function(t){return this.view.getUint8(t)},t.prototype.getNextInt8=function(){var t=this.getInt8(this.offset);return this.offset+=1,t},t.prototype.getNextUint8=function(){var t=this.getUint8(this.offset);return this.offset+=1,t},t.prototype.getInt16=function(t){return this.view.getInt16(t,this.littleEndian)},t.prototype.getUint16=function(t){return this.view.getUint16(t,this.littleEndian)},t.prototype.getNextInt16=function(){var t=this.getInt16(this.offset);return this.offset+=2,t},t.prototype.getNextUint16=function(){var t=this.getUint16(this.offset);return this.offset+=2,t},t.prototype.getInt32=function(t){return this.view.getInt32(t,this.littleEndian)},t.prototype.getUint32=function(t){return this.view.getUint32(t,this.littleEndian)},t.prototype.getNextInt32=function(){var t=this.getInt32(this.offset);return this.offset+=4,t},t.prototype.getNextUint32=function(){var t=this.getUint32(this.offset);return this.offset+=4,t},t.prototype.getFloat32=function(t){return this.view.getFloat32(t,this.littleEndian)},t.prototype.getFloat64=function(t){return this.view.getFloat64(t,this.littleEndian)},t.prototype.getNextFloat32=function(){var t=this.getFloat32(this.offset);return this.offset+=4,t},t.prototype.getNextFloat64=function(){var t=this.getFloat64(this.offset);return this.offset+=8,t},t.prototype.setInt8=function(t,e){this.handleAutoResize(t,1),this.view.setInt8(t,e)},t.prototype.setUint8=function(t,e){this.handleAutoResize(t,1),this.view.setUint8(t,e)},t.prototype.setNextInt8=function(t){this.setInt8(this.offset,t),this.offset+=1},t.prototype.setNextUint8=function(t){this.setUint8(this.offset,t),this.offset+=1},t.prototype.setInt16=function(t,e){this.handleAutoResize(t,2),this.view.setInt16(t,e,this.littleEndian)},t.prototype.setUint16=function(t,e){this.handleAutoResize(t,2),this.view.setUint16(t,e,this.littleEndian)},t.prototype.setNextInt16=function(t){this.setInt16(this.offset,t),this.offset+=2},t.prototype.setNextUint16=function(t){this.setUint16(this.offset,t),this.offset+=2},t.prototype.setInt32=function(t,e){this.handleAutoResize(t,4),this.view.setInt32(t,e,this.littleEndian)},t.prototype.setUint32=function(t,e){this.handleAutoResize(t,4),this.view.setUint32(t,e,this.littleEndian)},t.prototype.setNextInt32=function(t){this.setInt32(this.offset,t),this.offset+=4},t.prototype.setNextUint32=function(t){this.setUint32(this.offset,t),this.offset+=4},t.prototype.setFloat32=function(t,e){this.handleAutoResize(t,8),this.view.setFloat32(t,e,this.littleEndian)},t.prototype.setFloat64=function(t,e){this.handleAutoResize(t,8),this.view.setFloat64(t,e,this.littleEndian)},t.prototype.setNextFloat32=function(t){this.setFloat32(this.offset,t),this.offset+=4},t.prototype.setNextFloat64=function(t){this.setFloat64(this.offset,t),this.offset+=8},t.prototype.getBytes=function(t,e){void 0===t&&(t=0),e=e||this.view.buffer.byteLength-t;var n=this.getBuffer().slice(t,t+e);return new Uint8Array(n)},t.prototype.getNextBytes=function(t){var e=this.getBytes(this.offset,t);return this.offset+=t||0,e},t.prototype.setBytes=function(t,e){(e instanceof ArrayBuffer||Array.isArray(e))&&(e=new Uint8Array(e));var n=e;this.handleAutoResize(t,n.byteLength);for(var i=0;i<n.byteLength;i++)this.setUint8(t+i,n[i])},t.prototype.setNextBytes=function(t){Array.isArray(t)&&(t=new Uint8Array(t)),this.setBytes(this.offset,t),this.offset+=t.byteLength},t.prototype.getString=function(t,e,i,o){var s=this.getBytes(t,e);if(o){var r=s.indexOf(0);r>=0&&(s=s.slice(0,r))}return i?new n(\"utf-8\").decode(s):new n(\"ascii\").decode(s)},t.prototype.getNextString=function(t,e,n){var i=this.getString(this.offset,t,e,n);return this.offset+=t,i},t.prototype.setString=function(t,e,n,o){var s;s=n?new i(\"utf-8\").encode(e):new i(\"ascii\").encode(e),o=\"number\"==typeof o?o:s.byteLength,this.handleAutoResize(t,o);for(var r=0;r<o;r++)this.view.setUint8(t+r,s[r]||0);return o},t.prototype.setNextString=function(t,e,n){this.offset+=this.setString(this.offset,t,e,n)},t.prototype.toByteString=function(){return Array.from(new Uint8Array(this.getBuffer())).map((function(t){return(\"00\"+t.toString(16)).slice(-2)})).join(\" \").toUpperCase()},t.prototype.toTextString=function(t){return this.getString(0,this.view.byteLength,t)},t.prototype.fromByteString=function(t){var e=t.split(\" \"),n=new ArrayBuffer(e.length);this.view=new DataView(n),this.setNextBytes(new Uint8Array(e.map((function(t){return parseInt(t,16)})))),this.resetOffset()},t.prototype.getLength=function(){return this.view.byteLength},t.prototype.clear=function(){this.view=new DataView(new ArrayBuffer(this.view.byteLength)),this.offset=0},t.prototype.handleAutoResize=function(t,e){this.autoResize&&this.getBuffer().byteLength<t+e&&this.resize(t+e)},t}();return e})()}));","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nfunction extension(file) {\n    return file.split(\".\").pop();\n}\nexport default class Loader {\n    load(file) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield fetch(file);\n            return extension(file) === \"json\" ? yield response.json() : yield response.text();\n        });\n    }\n}\n","import { StreamDataView } from \"stream-data-view\";\nvar DataType;\n(function (DataType) {\n    DataType[DataType[\"UNDEFINED\"] = 0] = \"UNDEFINED\";\n    DataType[DataType[\"NULL\"] = 1] = \"NULL\";\n    DataType[DataType[\"BOOLEAN_FALSE\"] = 2] = \"BOOLEAN_FALSE\";\n    DataType[DataType[\"BOOLEAN_TRUE\"] = 3] = \"BOOLEAN_TRUE\";\n    DataType[DataType[\"INT8\"] = 4] = \"INT8\";\n    DataType[DataType[\"UINT8\"] = 5] = \"UINT8\";\n    DataType[DataType[\"INT16\"] = 6] = \"INT16\";\n    DataType[DataType[\"UINT16\"] = 7] = \"UINT16\";\n    DataType[DataType[\"INT32\"] = 8] = \"INT32\";\n    DataType[DataType[\"UINT32\"] = 9] = \"UINT32\";\n    DataType[DataType[\"FLOAT32\"] = 10] = \"FLOAT32\";\n    DataType[DataType[\"FLOAT64\"] = 11] = \"FLOAT64\";\n    DataType[DataType[\"STRING\"] = 12] = \"STRING\";\n    DataType[DataType[\"UNICODE\"] = 13] = \"UNICODE\";\n    DataType[DataType[\"OBJECT_8\"] = 17] = \"OBJECT_8\";\n    DataType[DataType[\"OBJECT_16\"] = 18] = \"OBJECT_16\";\n    DataType[DataType[\"OBJECT_32\"] = 19] = \"OBJECT_32\";\n    DataType[DataType[\"SPLIT_8\"] = 20] = \"SPLIT_8\";\n    DataType[DataType[\"SPLIT_16\"] = 21] = \"SPLIT_16\";\n    DataType[DataType[\"SPLIT_32\"] = 22] = \"SPLIT_32\";\n    DataType[DataType[\"ARRAY_8\"] = 23] = \"ARRAY_8\";\n    DataType[DataType[\"ARRAY_16\"] = 24] = \"ARRAY_16\";\n    DataType[DataType[\"ARRAY_32\"] = 25] = \"ARRAY_32\";\n    DataType[DataType[\"OFFSET_ARRAY_8\"] = 26] = \"OFFSET_ARRAY_8\";\n    DataType[DataType[\"OFFSET_ARRAY_16\"] = 27] = \"OFFSET_ARRAY_16\";\n    DataType[DataType[\"OFFSET_ARRAY_32\"] = 28] = \"OFFSET_ARRAY_32\";\n    DataType[DataType[\"EMPTY_ARRAY\"] = 29] = \"EMPTY_ARRAY\";\n})(DataType || (DataType = {}));\nvar Tag;\n(function (Tag) {\n    Tag[Tag[\"DONE\"] = 100] = \"DONE\";\n    Tag[Tag[\"MULTI\"] = 101] = \"MULTI\";\n})(Tag || (Tag = {}));\n;\nconst NUMBER_DATA_TYPES = [\n    DataType.UINT8,\n    DataType.INT8,\n    DataType.UINT16,\n    DataType.INT16,\n    DataType.UINT32,\n    DataType.INT32,\n    DataType.FLOAT32,\n    DataType.FLOAT64,\n];\nexport default class TokenEncoder {\n    constructor(streamDataView) {\n        this.streamDataView = streamDataView;\n    }\n    encodeTokens(tokens) {\n        let pos = 0;\n        while (pos < tokens.length) {\n            const count = this.encodeMulti(tokens, pos);\n            if (count) {\n                pos += count;\n            }\n            else {\n                this.encodeToken(tokens[pos]);\n                pos++;\n            }\n        }\n        this.encodeTag(Tag.DONE);\n    }\n    decodeTokens() {\n        const tokens = [];\n        while (this.streamDataView.getOffset() < this.streamDataView.getLength()) {\n            const tagOrDataType = this.decodeTagOrDataType();\n            if (tagOrDataType === Tag.DONE) {\n                break;\n            }\n            if (tagOrDataType === Tag.MULTI) {\n                this.decodeMulti(tagOrDataType, tokens);\n            }\n            else {\n                const token = this.decodeToken(tagOrDataType);\n                tokens.push(token);\n            }\n        }\n        return tokens;\n    }\n    encodeToken(token, dataType) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.encodeDataType(this.getDataType(token));\n        switch (usedDataType) {\n            case DataType.UNDEFINED:\n            case DataType.NULL:\n            case DataType.BOOLEAN_TRUE:\n            case DataType.BOOLEAN_FALSE:\n            case DataType.EMPTY_ARRAY:\n                break;\n            case DataType.INT8:\n            case DataType.UINT8:\n            case DataType.INT16:\n            case DataType.UINT16:\n            case DataType.INT32:\n            case DataType.UINT32:\n            case DataType.FLOAT32:\n            case DataType.FLOAT64:\n                this.encodeSingleNumber(token.value, usedDataType);\n                break;\n            case DataType.STRING:\n            case DataType.UNICODE:\n                this.encodeString(token.value, usedDataType);\n                break;\n            case DataType.OBJECT_8:\n            case DataType.OBJECT_16:\n            case DataType.OBJECT_32:\n                this.encodeObjectToken(token, usedDataType);\n                break;\n            case DataType.SPLIT_8:\n            case DataType.SPLIT_16:\n            case DataType.SPLIT_32:\n                this.encodeSplitToken(token, usedDataType);\n                break;\n            case DataType.ARRAY_8:\n            case DataType.ARRAY_16:\n            case DataType.ARRAY_32:\n            case DataType.OFFSET_ARRAY_8:\n            case DataType.OFFSET_ARRAY_16:\n            case DataType.OFFSET_ARRAY_32:\n                this.encodeArrayToken(token, usedDataType);\n                break;\n            default:\n                throw new Error(\"Invalid dataType: \" + usedDataType);\n        }\n    }\n    decodeToken(dataType) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.decodeDataType();\n        switch (usedDataType) {\n            case DataType.UNDEFINED:\n                return { type: \"leaf\", value: undefined };\n            case DataType.NULL:\n                return { type: \"leaf\", value: null };\n            case DataType.BOOLEAN_TRUE:\n                return { type: \"leaf\", value: true };\n            case DataType.BOOLEAN_FALSE:\n                return { type: \"leaf\", value: false };\n            case DataType.EMPTY_ARRAY:\n                return { type: \"array\", value: [] };\n            case DataType.INT8:\n            case DataType.UINT8:\n            case DataType.INT16:\n            case DataType.UINT16:\n            case DataType.INT32:\n            case DataType.UINT32:\n            case DataType.FLOAT32:\n            case DataType.FLOAT64:\n                return { type: \"leaf\", value: this.decodeSingleNumber(usedDataType) };\n            case DataType.STRING:\n            case DataType.UNICODE:\n                return { type: \"leaf\", value: this.decodeString(usedDataType) };\n            case DataType.OBJECT_8:\n            case DataType.OBJECT_16:\n            case DataType.OBJECT_32:\n                return this.decodeObjectToken(usedDataType);\n            case DataType.SPLIT_8:\n            case DataType.SPLIT_16:\n            case DataType.SPLIT_32:\n                return this.decodeSplitToken(usedDataType);\n            case DataType.ARRAY_8:\n            case DataType.ARRAY_16:\n            case DataType.ARRAY_32:\n            case DataType.OFFSET_ARRAY_8:\n            case DataType.OFFSET_ARRAY_16:\n            case DataType.OFFSET_ARRAY_32:\n                return this.decodeArrayToken(usedDataType);\n            default:\n                throw new Error(\"Invalid dataType: \" + usedDataType);\n        }\n    }\n    isOffsetDataType(dataType) {\n        return dataType === DataType.OFFSET_ARRAY_8 || dataType === DataType.OFFSET_ARRAY_16 || dataType === DataType.OFFSET_ARRAY_32;\n    }\n    encodeArrayToken(arrayToken, dataType) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.encodeDataType(this.getDataType(arrayToken));\n        const numberType = usedDataType === DataType.ARRAY_8 || usedDataType === DataType.OFFSET_ARRAY_8\n            ? DataType.UINT8\n            : usedDataType === DataType.ARRAY_16 || usedDataType === DataType.OFFSET_ARRAY_16\n                ? DataType.UINT16 : DataType.UINT32;\n        let indices = arrayToken.value;\n        if (this.isOffsetDataType(usedDataType)) {\n            const offset = Math.min(...indices);\n            indices = indices.map((value) => value - offset);\n            this.encodeSingleNumber(offset);\n        }\n        this.encodeNumberArray(indices, numberType);\n    }\n    decodeArrayToken(dataType) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.decodeDataType();\n        let offset = 0;\n        if (this.isOffsetDataType(usedDataType)) {\n            offset = this.decodeSingleNumber();\n        }\n        const numberType = usedDataType === DataType.ARRAY_8 || usedDataType === DataType.OFFSET_ARRAY_8\n            ? DataType.UINT8\n            : usedDataType === DataType.ARRAY_16 || usedDataType === DataType.OFFSET_ARRAY_16\n                ? DataType.UINT16 : DataType.UINT32;\n        const indices = this.decodeNumberArray(numberType)\n            .map(value => value + offset);\n        return {\n            type: \"array\",\n            value: indices,\n        };\n    }\n    encodeObjectToken(objectToken, dataType) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.encodeDataType(this.getDataType(objectToken));\n        const numberType = usedDataType === DataType.OBJECT_8 ? DataType.UINT8 : usedDataType === DataType.OBJECT_16 ? DataType.UINT16 : DataType.UINT32;\n        const [keysIndex, valuesIndex] = objectToken.value;\n        this.encodeSingleNumber(keysIndex, numberType);\n        this.encodeSingleNumber(valuesIndex, numberType);\n    }\n    decodeObjectToken(dataType) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.decodeDataType();\n        const numberType = usedDataType === DataType.OBJECT_8 ? DataType.UINT8 : usedDataType === DataType.OBJECT_16 ? DataType.UINT16 : DataType.UINT32;\n        return {\n            type: \"object\",\n            value: [this.decodeSingleNumber(numberType), this.decodeSingleNumber(numberType)],\n        };\n    }\n    encodeSplitToken(splitToken, dataType) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.encodeDataType(this.getDataType(splitToken));\n        const numberType = usedDataType === DataType.SPLIT_8 ? DataType.UINT8 : usedDataType === DataType.SPLIT_16 ? DataType.UINT16 : DataType.UINT32;\n        const [chunksIndex, separatorsIndex] = splitToken.value;\n        this.encodeSingleNumber(chunksIndex, numberType);\n        this.encodeSingleNumber(separatorsIndex, numberType);\n    }\n    decodeSplitToken(dataType) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.decodeDataType();\n        const numberType = usedDataType === DataType.SPLIT_8 ? DataType.UINT8 : usedDataType === DataType.SPLIT_16 ? DataType.UINT16 : DataType.UINT32;\n        return {\n            type: \"split\",\n            value: [this.decodeSingleNumber(numberType), this.decodeSingleNumber(numberType)],\n        };\n    }\n    encodeTag(tag) {\n        this.streamDataView.setNextUint8(tag);\n    }\n    decodeTag() {\n        return this.streamDataView.getNextUint8();\n    }\n    decodeTagOrDataType() {\n        const dataType = this.streamDataView.getNextUint8();\n        return dataType;\n    }\n    encodeDataType(dataType) {\n        this.streamDataView.setNextUint8(dataType);\n        return dataType;\n    }\n    decodeDataType() {\n        return this.streamDataView.getNextUint8();\n    }\n    encodeMulti(tokens, pos) {\n        const firstType = this.getDataType(tokens[pos]);\n        let multiCount;\n        const maxCount = Math.min(tokens.length - pos, 256);\n        for (multiCount = 1; multiCount < maxCount; multiCount++) {\n            if (this.getDataType(tokens[pos + multiCount]) !== firstType) {\n                break;\n            }\n        }\n        if (multiCount > 2) {\n            //  encode a multi, meaning that the same type is going to get repeated multiple times\n            this.encodeTag(Tag.MULTI);\n            this.encodeSingleNumber(multiCount % 256, DataType.UINT8);\n            this.encodeDataType(firstType);\n            for (let i = 0; i < multiCount; i++) {\n                this.encodeToken(tokens[pos + i], firstType);\n            }\n            return multiCount;\n        }\n        return 0;\n    }\n    decodeMulti(tag, tokens) {\n        if (tag === Tag.MULTI) {\n            const count = this.streamDataView.getNextUint8() || 256;\n            const dataType = this.decodeDataType();\n            for (let i = 0; i < count; i++) {\n                const token = this.decodeToken(dataType);\n                tokens.push(token);\n            }\n            return count;\n        }\n        return 0;\n    }\n    encodeSingleNumber(value, dataType) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.encodeDataType(this.getNumberDataType(value));\n        switch (usedDataType) {\n            case DataType.UINT8:\n                this.streamDataView.setNextUint8(value);\n                break;\n            case DataType.INT8:\n                this.streamDataView.setNextInt8(value);\n                break;\n            case DataType.UINT16:\n                this.streamDataView.setNextUint16(value);\n                break;\n            case DataType.INT16:\n                this.streamDataView.setNextInt16(value);\n                break;\n            case DataType.UINT32:\n                this.streamDataView.setNextUint32(value);\n                break;\n            case DataType.INT32:\n                this.streamDataView.setNextInt32(value);\n                break;\n            case DataType.FLOAT32:\n                this.streamDataView.setNextFloat32(value);\n                break;\n            case DataType.FLOAT64:\n                this.streamDataView.setNextFloat64(value);\n                break;\n            default:\n                throw new Error(\"Invalid dataType for number: \" + usedDataType);\n        }\n    }\n    decodeSingleNumber(dataType) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.decodeDataType();\n        switch (usedDataType) {\n            case DataType.UINT8:\n                return this.streamDataView.getNextUint8();\n            case DataType.INT8:\n                return this.streamDataView.getNextInt8();\n            case DataType.UINT16:\n                return this.streamDataView.getNextUint16();\n            case DataType.INT16:\n                return this.streamDataView.getNextInt16();\n            case DataType.UINT32:\n                return this.streamDataView.getNextUint32();\n            case DataType.INT32:\n                return this.streamDataView.getNextInt32();\n            case DataType.FLOAT32:\n                return this.streamDataView.getNextFloat32();\n            case DataType.FLOAT64:\n                return this.streamDataView.getNextFloat64();\n            default:\n                throw new Error(\"Invalid dataType for number: \" + usedDataType);\n        }\n    }\n    numberSatisfyDataType(value, dataType) {\n        const hasDecimal = value % 1 !== 0;\n        if (hasDecimal) {\n            switch (dataType) {\n                case DataType.FLOAT32:\n                    return Math.fround(value) === value;\n                case DataType.FLOAT64:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n        switch (dataType) {\n            case DataType.UINT8:\n                return value >= 0 && value <= 255;\n            case DataType.INT8:\n                return value >= -128 && value <= 127;\n            case DataType.UINT16:\n                return value >= 0 && value <= 65535;\n            case DataType.INT16:\n                return value >= -32768 && value <= 32767;\n            case DataType.UINT32:\n                return value >= 0;\n            case DataType.INT32:\n                return true;\n        }\n        return false;\n    }\n    getBestType(array) {\n        if (array.some(number => number % 1 !== 0)) {\n            //  decimal\n            if (array.every(number => this.numberSatisfyDataType(number, DataType.FLOAT32))) {\n                return DataType.FLOAT32;\n            }\n            return DataType.FLOAT64;\n        }\n        const min = Math.min(...array);\n        const max = Math.max(...array);\n        for (let dataType of NUMBER_DATA_TYPES) {\n            if (this.numberSatisfyDataType(min, dataType) && this.numberSatisfyDataType(max, dataType)) {\n                return dataType;\n            }\n        }\n        return DataType.FLOAT64;\n    }\n    encodeNumberArray(array, dataType) {\n        let pos;\n        for (pos = 0; pos < array.length;) {\n            const size = Math.min(255, array.length - pos);\n            this.encodeSingleNumber(size, DataType.UINT8);\n            if (!size) {\n                break;\n            }\n            const bestType = dataType !== null && dataType !== void 0 ? dataType : this.encodeDataType(this.getBestType(array));\n            for (let i = 0; i < size; i++) {\n                this.encodeSingleNumber(array[pos + i], bestType);\n            }\n            pos += size;\n        }\n        if (pos === 255) {\n            //  Reached the max size of 255, but the next one is 0.\n            this.encodeSingleNumber(0, DataType.UINT8);\n        }\n    }\n    decodeNumberArray(dataType) {\n        let size;\n        const numbers = [];\n        do {\n            size = this.decodeSingleNumber(DataType.UINT8);\n            if (!size) {\n                break;\n            }\n            const type = dataType !== null && dataType !== void 0 ? dataType : this.decodeDataType();\n            for (let i = 0; i < size; i++) {\n                numbers.push(this.decodeSingleNumber(type));\n            }\n        } while (size >= 255);\n        return numbers;\n    }\n    getNumberDataType(value) {\n        for (let type of NUMBER_DATA_TYPES) {\n            if (this.numberSatisfyDataType(value, type)) {\n                return type;\n            }\n        }\n        return DataType.UNDEFINED;\n    }\n    getStringDataType(value) {\n        const letterCodes = value.split(\"\").map(l => l.charCodeAt(0));\n        if (letterCodes.every(code => code <= 255)) {\n            return DataType.STRING;\n        }\n        else {\n            return DataType.UNICODE;\n        }\n    }\n    getDataType(token) {\n        switch (token.type) {\n            case \"array\":\n            case \"object\":\n            case \"split\":\n                let indices = token.value;\n                if (!indices.length) {\n                    console.assert(token.type === \"array\");\n                    return DataType.EMPTY_ARRAY;\n                }\n                let offset = 0;\n                if (token.type === \"array\" && indices.length > 3) {\n                    const min = Math.min(...indices);\n                    const max = Math.max(...indices);\n                    if (this.getNumberDataType(max - min) !== this.getNumberDataType(max)) {\n                        offset = min;\n                    }\n                    indices = indices.map(value => value - offset);\n                }\n                const bestType = this.getBestType(indices);\n                switch (token.type) {\n                    case \"object\":\n                        return bestType === DataType.UINT8\n                            ? DataType.OBJECT_8\n                            : bestType === DataType.UINT16\n                                ? DataType.OBJECT_16\n                                : DataType.OBJECT_32;\n                    case \"split\":\n                        return bestType === DataType.UINT8\n                            ? DataType.SPLIT_8\n                            : bestType === DataType.UINT16\n                                ? DataType.SPLIT_16\n                                : DataType.SPLIT_32;\n                    case \"array\":\n                        if (offset) {\n                            return bestType === DataType.UINT8\n                                ? DataType.OFFSET_ARRAY_8\n                                : bestType === DataType.UINT16\n                                    ? DataType.OFFSET_ARRAY_16\n                                    : DataType.OFFSET_ARRAY_32;\n                        }\n                        else {\n                            return bestType === DataType.UINT8\n                                ? DataType.ARRAY_8\n                                : bestType === DataType.UINT16\n                                    ? DataType.ARRAY_16\n                                    : DataType.ARRAY_32;\n                        }\n                }\n            case \"leaf\":\n                if (token.value === undefined) {\n                    return DataType.UNDEFINED;\n                }\n                else if (token.value === null) {\n                    return DataType.NULL;\n                }\n                else {\n                    switch (typeof token.value) {\n                        case \"boolean\":\n                            return token.value ? DataType.BOOLEAN_TRUE : DataType.BOOLEAN_FALSE;\n                        case \"string\":\n                            return this.getStringDataType(token.value);\n                        case \"number\":\n                            return this.getNumberDataType(token.value);\n                    }\n                }\n        }\n        throw new Error(`Unrecognized type for ${token.type} value: ${token.value}`);\n    }\n    dataTypeToType(dataType) {\n        switch (dataType) {\n            case DataType.EMPTY_ARRAY:\n            case DataType.ARRAY_8:\n            case DataType.ARRAY_16:\n            case DataType.ARRAY_32:\n                return \"array\";\n            case DataType.OBJECT_8:\n            case DataType.OBJECT_16:\n            case DataType.OBJECT_32:\n                return \"object\";\n            case DataType.SPLIT_8:\n            case DataType.SPLIT_16:\n            case DataType.SPLIT_32:\n                return \"split\";\n            default:\n                return \"leaf\";\n        }\n    }\n    encodeString(value, dataType) {\n        const letterCodes = value.split(\"\").map(l => l.charCodeAt(0));\n        letterCodes.push(0);\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.encodeDataType(this.getStringDataType(value));\n        const numberType = usedDataType === DataType.STRING ? DataType.UINT8 : DataType.UINT16;\n        letterCodes.forEach(code => this.encodeSingleNumber(code, numberType));\n    }\n    decodeString(dataType) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.decodeDataType();\n        const charCodes = [];\n        const numberType = usedDataType === DataType.STRING ? DataType.UINT8 : DataType.UINT16;\n        do {\n            const code = this.decodeSingleNumber(numberType);\n            if (!code) {\n                break;\n            }\n            charCodes.push(code);\n        } while (true);\n        return charCodes.map(code => String.fromCharCode(code)).join(\"\");\n    }\n    static selfTest() {\n        const testers = [\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction(DataType.STRING, dataType => tokenEncoder.encodeDataType(dataType), reset, () => tokenDecoder.decodeDataType());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction(DataType.UNDEFINED, dataType => tokenEncoder.encodeDataType(dataType), reset, () => tokenDecoder.decodeDataType());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction(33, number => tokenEncoder.encodeSingleNumber(number, DataType.INT8), reset, () => tokenDecoder.decodeSingleNumber(DataType.INT8));\n            },\n            // (tokenEncoder, tokenDecoder, reset) => {\n            //     this.testAction([\n            //             { type: \"leaf\", value: 123 },\n            //             { type: \"leaf\", value: 45 },\n            //             { type: \"leaf\", value: 67 },\n            //             { type: \"leaf\", value: 89 },\n            //         ],\n            //         header => tokenEncoder.encodeMulti(header, 0),\n            //         reset,\n            //         () => {\n            //             const result: ReducedToken[] = [];\n            //             tokenDecoder.decodeMulti(tokenDecoder.decodeTag(), result);\n            //             return result;\n            //         });\n            // },\n            // (tokenEncoder, tokenDecoder, reset) => {\n            //     this.testAction([\n            //             { type: \"leaf\", value: 1000001 },\n            //             { type: \"leaf\", value: 1002000 },\n            //             { type: \"leaf\", value: 1003001 },\n            //         ],\n            //         header => tokenEncoder.encodeMulti(header, 0),\n            //         reset,\n            //         () => {\n            //             const result: ReducedToken[] = [];\n            //             tokenDecoder.decodeMulti(tokenDecoder.decodeTag(), result);\n            //             return result;\n            //         });                \n            // },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction([1, 2, 3, 4, 10, 20, 200], array => tokenEncoder.encodeNumberArray(array), reset, () => tokenDecoder.decodeNumberArray());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction(new Array(2000).fill(null).map((_, index) => index), array => tokenEncoder.encodeNumberArray(array), reset, () => tokenDecoder.decodeNumberArray());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction([10000, -202, 3, 4, 10, 20, 3200], array => tokenEncoder.encodeNumberArray(array), reset, () => tokenDecoder.decodeNumberArray());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction(\"test-string\", string => tokenEncoder.encodeString(string), reset, () => tokenDecoder.decodeString());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction(\"test-string\", string => tokenEncoder.encodeString(string, DataType.STRING), reset, () => tokenDecoder.decodeString(DataType.STRING));\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction(\"test-😀😃😄😁😆\", string => tokenEncoder.encodeString(string), reset, () => tokenDecoder.decodeString());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"object\", value: [200, 201] }, o => tokenEncoder.encodeObjectToken(o), reset, () => tokenDecoder.decodeObjectToken());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"object\", value: [2000, 2001] }, o => tokenEncoder.encodeObjectToken(o), reset, () => tokenDecoder.decodeObjectToken());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"object\", value: [2000, 2001] }, o => tokenEncoder.encodeObjectToken(o, DataType.OBJECT_32), reset, () => tokenDecoder.decodeObjectToken(DataType.OBJECT_32));\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"split\", value: [200, 201] }, o => tokenEncoder.encodeSplitToken(o), reset, () => tokenDecoder.decodeSplitToken());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"split\", value: [2000, 2001] }, o => tokenEncoder.encodeSplitToken(o), reset, () => tokenDecoder.decodeSplitToken());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"split\", value: [2000, 2001] }, o => tokenEncoder.encodeSplitToken(o, DataType.SPLIT_32), reset, () => tokenDecoder.decodeSplitToken(DataType.SPLIT_32));\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"leaf\", value: \"token-string\" }, o => tokenEncoder.encodeToken(o), reset, () => tokenDecoder.decodeToken());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"leaf\", value: 123.5 }, o => tokenEncoder.encodeToken(o), reset, () => tokenDecoder.decodeToken());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"leaf\", value: \"😁😆\" }, o => tokenEncoder.encodeToken(o), reset, () => tokenDecoder.decodeToken());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"array\", value: [1, 10, 20, 30, 200] }, o => tokenEncoder.encodeToken(o), reset, () => tokenDecoder.decodeToken());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"array\", value: [1001, 1010, 1020, 1030, 1200] }, o => tokenEncoder.encodeToken(o), reset, () => tokenDecoder.decodeToken());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"array\", value: [10010, 10100, 10300, 20000] }, o => tokenEncoder.encodeToken(o), reset, () => tokenDecoder.decodeToken());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"array\", value: [10010, 10100, 10000] }, o => tokenEncoder.encodeToken(o), reset, () => tokenDecoder.decodeToken());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"array\", value: new Array(260).fill(null).map((_, index) => index) }, o => tokenEncoder.encodeToken(o), reset, () => tokenDecoder.decodeToken());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction(new Array(100).fill(null).map((_, index) => {\n                    const token = {\n                        type: \"array\",\n                        value: new Array(index).fill(null).map((_, index) => index),\n                    };\n                    return token;\n                }), o => tokenEncoder.encodeTokens(o), reset, () => tokenDecoder.decodeTokens());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction(new Array(260).fill(null).map((_, index) => {\n                    const token = {\n                        type: \"array\",\n                        value: new Array(index).fill(null).map((_, index) => index),\n                    };\n                    return token;\n                }), o => tokenEncoder.encodeTokens(o), reset, () => tokenDecoder.decodeTokens());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction(new Array(260).fill(null).map((_, index) => {\n                    const token = {\n                        type: \"array\",\n                        value: [1],\n                    };\n                    return token;\n                }), o => tokenEncoder.encodeTokens(o), reset, () => tokenDecoder.decodeTokens());\n            },\n        ];\n        testers.forEach((tester, index) => {\n            const streamDataView = new StreamDataView();\n            const encoder = new TokenEncoder(streamDataView);\n            const decoder = new TokenEncoder(streamDataView);\n            const reset = () => streamDataView.resetOffset();\n            tester(encoder, decoder, reset);\n            console.log(`✅ Passed test ${index}.`);\n        });\n    }\n    static testAction(value, encode, reset, decode, check = (result, value) => console.assert(JSON.stringify(result) === JSON.stringify(value), `Not equal: \\n%s\\n!==\\n%s`, JSON.stringify(result), JSON.stringify(value))) {\n        encode(value);\n        reset();\n        const decoded = decode();\n        reset();\n        check(decoded, value);\n    }\n}\n","/**\n * Reduce header from using large tokens to reduce tokens.\n */\nexport default class Reducer {\n    constructor(debug) {\n        this.debug = debug !== null && debug !== void 0 ? debug : false;\n    }\n    /**\n     * Reduce header with smaller tokens for storage\n     *\n     * @param header Represents all data that we have.\n     * @returns DataStorage object that's the minimum we can store.\n     */\n    reduce(header) {\n        const hashToIndex = {};\n        //  start with header tokens\n        const headerTokens = this.createReducedTokens(Object.values(header.registry)\n            .filter(token => token.files.size > 1 || token.files.has(\"header\")), hashToIndex);\n        //  save files\n        const fileEntries = Object.entries(header.files).sort(([name1], [name2]) => name1.localeCompare(name2));\n        const files = fileEntries.map(([, token]) => hashToIndex[token.nameToken.hash]);\n        //  save all files separately\n        const dataTokens = fileEntries.map(([file, { token: root }]) => {\n            const subHashToIndex = Object.assign({}, hashToIndex);\n            const tokens = Object.values(header.registry).filter(token => token.files.has(file) && token !== root);\n            return this.createReducedTokens(tokens, subHashToIndex, headerTokens.length).concat(this.createReducedTokens([root], subHashToIndex, headerTokens.length));\n        });\n        return {\n            headerTokens,\n            files,\n            getDataTokens(index) {\n                return dataTokens[index];\n            },\n        };\n    }\n    createReducedTokens(tokens, hashToIndex, offset = 0) {\n        const sortedTokens = tokens.sort((t1, t2) => t2.count - t1.count);\n        sortedTokens.forEach(({ hash }, index) => {\n            hashToIndex[hash] = index + offset;\n        });\n        return sortedTokens.map(token => {\n            var _a, _b;\n            return (Object.assign({ type: token.type, value: (_b = (_a = token.reference) === null || _a === void 0 ? void 0 : _a.map(hash => hashToIndex[hash])) !== null && _b !== void 0 ? _b : token.value }, this.debug ? { debug: token.value } : {}));\n        });\n    }\n}\n","// DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n// https://tools.ietf.org/html/rfc1951\n// You may also wish to take a look at the guide I made about this program:\n// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad\n// Some of the following code is similar to that of UZIP.js:\n// https://github.com/photopea/UZIP.js\n// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.\n// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint\n// is better for memory in most engines (I *think*).\nvar ch2 = {};\nvar wk = (function (c, id, msg, transfer, cb) {\n    var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([\n        c + ';addEventListener(\"error\",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'\n    ], { type: 'text/javascript' }))));\n    w.onmessage = function (e) {\n        var d = e.data, ed = d.$e$;\n        if (ed) {\n            var err = new Error(ed[0]);\n            err['code'] = ed[1];\n            err.stack = ed[2];\n            cb(err, null);\n        }\n        else\n            cb(null, d);\n    };\n    w.postMessage(msg, transfer);\n    return w;\n});\n\n// aliases for shorter compressed code (most minifers don't do this)\nvar u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;\n// fixed length extra bits\nvar fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);\n// fixed distance extra bits\n// see fleb note\nvar fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);\n// code length index map\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n// get base, reverse index map from extra bits\nvar freb = function (eb, start) {\n    var b = new u16(31);\n    for (var i = 0; i < 31; ++i) {\n        b[i] = start += 1 << eb[i - 1];\n    }\n    // numbers here are at max 18 bits\n    var r = new u32(b[30]);\n    for (var i = 1; i < 30; ++i) {\n        for (var j = b[i]; j < b[i + 1]; ++j) {\n            r[j] = ((j - b[i]) << 5) | i;\n        }\n    }\n    return [b, r];\n};\nvar _a = freb(fleb, 2), fl = _a[0], revfl = _a[1];\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = _b[0], revfd = _b[1];\n// map of value to reverse (assuming 16 bits)\nvar rev = new u16(32768);\nfor (var i = 0; i < 32768; ++i) {\n    // reverse table algorithm from SO\n    var x = ((i & 0xAAAA) >>> 1) | ((i & 0x5555) << 1);\n    x = ((x & 0xCCCC) >>> 2) | ((x & 0x3333) << 2);\n    x = ((x & 0xF0F0) >>> 4) | ((x & 0x0F0F) << 4);\n    rev[i] = (((x & 0xFF00) >>> 8) | ((x & 0x00FF) << 8)) >>> 1;\n}\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nvar hMap = (function (cd, mb, r) {\n    var s = cd.length;\n    // index\n    var i = 0;\n    // u16 \"map\": index -> # of codes with bit length = index\n    var l = new u16(mb);\n    // length of cd must be 288 (total # of codes)\n    for (; i < s; ++i) {\n        if (cd[i])\n            ++l[cd[i] - 1];\n    }\n    // u16 \"map\": index -> minimum code for bit length = index\n    var le = new u16(mb);\n    for (i = 0; i < mb; ++i) {\n        le[i] = (le[i - 1] + l[i - 1]) << 1;\n    }\n    var co;\n    if (r) {\n        // u16 \"map\": index -> number of actual bits, symbol for code\n        co = new u16(1 << mb);\n        // bits to remove for reverser\n        var rvb = 15 - mb;\n        for (i = 0; i < s; ++i) {\n            // ignore 0 lengths\n            if (cd[i]) {\n                // num encoding both symbol and bits read\n                var sv = (i << 4) | cd[i];\n                // free bits\n                var r_1 = mb - cd[i];\n                // start value\n                var v = le[cd[i] - 1]++ << r_1;\n                // m is end value\n                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {\n                    // every 16 bit value starting with the code yields the same result\n                    co[rev[v] >>> rvb] = sv;\n                }\n            }\n        }\n    }\n    else {\n        co = new u16(s);\n        for (i = 0; i < s; ++i) {\n            if (cd[i]) {\n                co[i] = rev[le[cd[i] - 1]++] >>> (15 - cd[i]);\n            }\n        }\n    }\n    return co;\n});\n// fixed length tree\nvar flt = new u8(288);\nfor (var i = 0; i < 144; ++i)\n    flt[i] = 8;\nfor (var i = 144; i < 256; ++i)\n    flt[i] = 9;\nfor (var i = 256; i < 280; ++i)\n    flt[i] = 7;\nfor (var i = 280; i < 288; ++i)\n    flt[i] = 8;\n// fixed distance tree\nvar fdt = new u8(32);\nfor (var i = 0; i < 32; ++i)\n    fdt[i] = 5;\n// fixed length map\nvar flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);\n// fixed distance map\nvar fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);\n// find max of array\nvar max = function (a) {\n    var m = a[0];\n    for (var i = 1; i < a.length; ++i) {\n        if (a[i] > m)\n            m = a[i];\n    }\n    return m;\n};\n// read d, starting at bit p and mask with m\nvar bits = function (d, p, m) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;\n};\n// read d, starting at bit p continuing for at least 16 bits\nvar bits16 = function (d, p) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));\n};\n// get end of byte\nvar shft = function (p) { return ((p + 7) / 8) | 0; };\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nvar slc = function (v, s, e) {\n    if (s == null || s < 0)\n        s = 0;\n    if (e == null || e > v.length)\n        e = v.length;\n    // can't use .constructor in case user-supplied\n    var n = new (v.BYTES_PER_ELEMENT == 2 ? u16 : v.BYTES_PER_ELEMENT == 4 ? u32 : u8)(e - s);\n    n.set(v.subarray(s, e));\n    return n;\n};\n/**\n * Codes for errors generated within this library\n */\nexport var FlateErrorCode = {\n    UnexpectedEOF: 0,\n    InvalidBlockType: 1,\n    InvalidLengthLiteral: 2,\n    InvalidDistance: 3,\n    StreamFinished: 4,\n    NoStreamHandler: 5,\n    InvalidHeader: 6,\n    NoCallback: 7,\n    InvalidUTF8: 8,\n    ExtraFieldTooLong: 9,\n    InvalidDate: 10,\n    FilenameTooLong: 11,\n    StreamFinishing: 12,\n    InvalidZipData: 13,\n    UnknownCompressionMethod: 14\n};\n// error codes\nvar ec = [\n    'unexpected EOF',\n    'invalid block type',\n    'invalid length/literal',\n    'invalid distance',\n    'stream finished',\n    'no stream handler',\n    ,\n    'no callback',\n    'invalid UTF-8 data',\n    'extra field too long',\n    'date not in range 1980-2099',\n    'filename too long',\n    'stream finishing',\n    'invalid zip data'\n    // determined by unknown compression method\n];\n;\nvar err = function (ind, msg, nt) {\n    var e = new Error(msg || ec[ind]);\n    e.code = ind;\n    if (Error.captureStackTrace)\n        Error.captureStackTrace(e, err);\n    if (!nt)\n        throw e;\n    return e;\n};\n// expands raw DEFLATE data\nvar inflt = function (dat, buf, st) {\n    // source length\n    var sl = dat.length;\n    if (!sl || (st && st.f && !st.l))\n        return buf || new u8(0);\n    // have to estimate size\n    var noBuf = !buf || st;\n    // no state\n    var noSt = !st || st.i;\n    if (!st)\n        st = {};\n    // Assumes roughly 33% compression ratio average\n    if (!buf)\n        buf = new u8(sl * 3);\n    // ensure buffer can fit at least l elements\n    var cbuf = function (l) {\n        var bl = buf.length;\n        // need to increase size to fit\n        if (l > bl) {\n            // Double or set to necessary, whichever is greater\n            var nbuf = new u8(Math.max(bl * 2, l));\n            nbuf.set(buf);\n            buf = nbuf;\n        }\n    };\n    //  last chunk         bitpos           bytes\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    // total bits\n    var tbts = sl * 8;\n    do {\n        if (!lm) {\n            // BFINAL - this is only 1 when last chunk is next\n            final = bits(dat, pos, 1);\n            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n            var type = bits(dat, pos + 1, 3);\n            pos += 3;\n            if (!type) {\n                // go to end of byte boundary\n                var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;\n                if (t > sl) {\n                    if (noSt)\n                        err(0);\n                    break;\n                }\n                // ensure size\n                if (noBuf)\n                    cbuf(bt + l);\n                // Copy over uncompressed data\n                buf.set(dat.subarray(s, t), bt);\n                // Get new bitpos, update byte count\n                st.b = bt += l, st.p = pos = t * 8, st.f = final;\n                continue;\n            }\n            else if (type == 1)\n                lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n            else if (type == 2) {\n                //  literal                            lengths\n                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n                var tl = hLit + bits(dat, pos + 5, 31) + 1;\n                pos += 14;\n                // length+distance tree\n                var ldt = new u8(tl);\n                // code length tree\n                var clt = new u8(19);\n                for (var i = 0; i < hcLen; ++i) {\n                    // use index map to get real code\n                    clt[clim[i]] = bits(dat, pos + i * 3, 7);\n                }\n                pos += hcLen * 3;\n                // code lengths bits\n                var clb = max(clt), clbmsk = (1 << clb) - 1;\n                // code lengths map\n                var clm = hMap(clt, clb, 1);\n                for (var i = 0; i < tl;) {\n                    var r = clm[bits(dat, pos, clbmsk)];\n                    // bits read\n                    pos += r & 15;\n                    // symbol\n                    var s = r >>> 4;\n                    // code length to copy\n                    if (s < 16) {\n                        ldt[i++] = s;\n                    }\n                    else {\n                        //  copy   count\n                        var c = 0, n = 0;\n                        if (s == 16)\n                            n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n                        else if (s == 17)\n                            n = 3 + bits(dat, pos, 7), pos += 3;\n                        else if (s == 18)\n                            n = 11 + bits(dat, pos, 127), pos += 7;\n                        while (n--)\n                            ldt[i++] = c;\n                    }\n                }\n                //    length tree                 distance tree\n                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n                // max length bits\n                lbt = max(lt);\n                // max dist bits\n                dbt = max(dt);\n                lm = hMap(lt, lbt, 1);\n                dm = hMap(dt, dbt, 1);\n            }\n            else\n                err(1);\n            if (pos > tbts) {\n                if (noSt)\n                    err(0);\n                break;\n            }\n        }\n        // Make sure the buffer can hold this + the largest possible addition\n        // Maximum chunk size (practically, theoretically infinite) is 2^17;\n        if (noBuf)\n            cbuf(bt + 131072);\n        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n        var lpos = pos;\n        for (;; lpos = pos) {\n            // bits read, code\n            var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;\n            pos += c & 15;\n            if (pos > tbts) {\n                if (noSt)\n                    err(0);\n                break;\n            }\n            if (!c)\n                err(2);\n            if (sym < 256)\n                buf[bt++] = sym;\n            else if (sym == 256) {\n                lpos = pos, lm = null;\n                break;\n            }\n            else {\n                var add = sym - 254;\n                // no extra bits needed if less\n                if (sym > 264) {\n                    // index\n                    var i = sym - 257, b = fleb[i];\n                    add = bits(dat, pos, (1 << b) - 1) + fl[i];\n                    pos += b;\n                }\n                // dist\n                var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;\n                if (!d)\n                    err(3);\n                pos += d & 15;\n                var dt = fd[dsym];\n                if (dsym > 3) {\n                    var b = fdeb[dsym];\n                    dt += bits16(dat, pos) & ((1 << b) - 1), pos += b;\n                }\n                if (pos > tbts) {\n                    if (noSt)\n                        err(0);\n                    break;\n                }\n                if (noBuf)\n                    cbuf(bt + 131072);\n                var end = bt + add;\n                for (; bt < end; bt += 4) {\n                    buf[bt] = buf[bt - dt];\n                    buf[bt + 1] = buf[bt + 1 - dt];\n                    buf[bt + 2] = buf[bt + 2 - dt];\n                    buf[bt + 3] = buf[bt + 3 - dt];\n                }\n                bt = end;\n            }\n        }\n        st.l = lm, st.p = lpos, st.b = bt, st.f = final;\n        if (lm)\n            final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    } while (!final);\n    return bt == buf.length ? buf : slc(buf, 0, bt);\n};\n// starting at p, write the minimum number of bits that can hold v to d\nvar wbits = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n};\n// starting at p, write the minimum number of bits (>8) that can hold v to d\nvar wbits16 = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n    d[o + 2] |= v >>> 16;\n};\n// creates code lengths from a frequency table\nvar hTree = function (d, mb) {\n    // Need extra info to make a tree\n    var t = [];\n    for (var i = 0; i < d.length; ++i) {\n        if (d[i])\n            t.push({ s: i, f: d[i] });\n    }\n    var s = t.length;\n    var t2 = t.slice();\n    if (!s)\n        return [et, 0];\n    if (s == 1) {\n        var v = new u8(t[0].s + 1);\n        v[t[0].s] = 1;\n        return [v, 1];\n    }\n    t.sort(function (a, b) { return a.f - b.f; });\n    // after i2 reaches last ind, will be stopped\n    // freq must be greater than largest possible number of symbols\n    t.push({ s: -1, f: 25001 });\n    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;\n    t[0] = { s: -1, f: l.f + r.f, l: l, r: r };\n    // efficient algorithm from UZIP.js\n    // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n    // symbols that combined have high freq, will start processing i2 (high-freq,\n    // non-composite) symbols instead\n    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n    while (i1 != s - 1) {\n        l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n        t[i1++] = { s: -1, f: l.f + r.f, l: l, r: r };\n    }\n    var maxSym = t2[0].s;\n    for (var i = 1; i < s; ++i) {\n        if (t2[i].s > maxSym)\n            maxSym = t2[i].s;\n    }\n    // code lengths\n    var tr = new u16(maxSym + 1);\n    // max bits in tree\n    var mbt = ln(t[i1 - 1], tr, 0);\n    if (mbt > mb) {\n        // more algorithms from UZIP.js\n        // TODO: find out how this code works (debt)\n        //  ind    debt\n        var i = 0, dt = 0;\n        //    left            cost\n        var lft = mbt - mb, cst = 1 << lft;\n        t2.sort(function (a, b) { return tr[b.s] - tr[a.s] || a.f - b.f; });\n        for (; i < s; ++i) {\n            var i2_1 = t2[i].s;\n            if (tr[i2_1] > mb) {\n                dt += cst - (1 << (mbt - tr[i2_1]));\n                tr[i2_1] = mb;\n            }\n            else\n                break;\n        }\n        dt >>>= lft;\n        while (dt > 0) {\n            var i2_2 = t2[i].s;\n            if (tr[i2_2] < mb)\n                dt -= 1 << (mb - tr[i2_2]++ - 1);\n            else\n                ++i;\n        }\n        for (; i >= 0 && dt; --i) {\n            var i2_3 = t2[i].s;\n            if (tr[i2_3] == mb) {\n                --tr[i2_3];\n                ++dt;\n            }\n        }\n        mbt = mb;\n    }\n    return [new u8(tr), mbt];\n};\n// get the max length and assign length codes\nvar ln = function (n, l, d) {\n    return n.s == -1\n        ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))\n        : (l[n.s] = d);\n};\n// length codes generation\nvar lc = function (c) {\n    var s = c.length;\n    // Note that the semicolon was intentional\n    while (s && !c[--s])\n        ;\n    var cl = new u16(++s);\n    //  ind      num         streak\n    var cli = 0, cln = c[0], cls = 1;\n    var w = function (v) { cl[cli++] = v; };\n    for (var i = 1; i <= s; ++i) {\n        if (c[i] == cln && i != s)\n            ++cls;\n        else {\n            if (!cln && cls > 2) {\n                for (; cls > 138; cls -= 138)\n                    w(32754);\n                if (cls > 2) {\n                    w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305);\n                    cls = 0;\n                }\n            }\n            else if (cls > 3) {\n                w(cln), --cls;\n                for (; cls > 6; cls -= 6)\n                    w(8304);\n                if (cls > 2)\n                    w(((cls - 3) << 5) | 8208), cls = 0;\n            }\n            while (cls--)\n                w(cln);\n            cls = 1;\n            cln = c[i];\n        }\n    }\n    return [cl.subarray(0, cli), s];\n};\n// calculate the length of output from tree, code lengths\nvar clen = function (cf, cl) {\n    var l = 0;\n    for (var i = 0; i < cl.length; ++i)\n        l += cf[i] * cl[i];\n    return l;\n};\n// writes a fixed block\n// returns the new bit pos\nvar wfblk = function (out, pos, dat) {\n    // no need to write 00 as type: TypedArray defaults to 0\n    var s = dat.length;\n    var o = shft(pos + 2);\n    out[o] = s & 255;\n    out[o + 1] = s >>> 8;\n    out[o + 2] = out[o] ^ 255;\n    out[o + 3] = out[o + 1] ^ 255;\n    for (var i = 0; i < s; ++i)\n        out[o + i + 4] = dat[i];\n    return (o + 4 + s) * 8;\n};\n// writes a block\nvar wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\n    wbits(out, p++, final);\n    ++lf[256];\n    var _a = hTree(lf, 15), dlt = _a[0], mlb = _a[1];\n    var _b = hTree(df, 15), ddt = _b[0], mdb = _b[1];\n    var _c = lc(dlt), lclt = _c[0], nlc = _c[1];\n    var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];\n    var lcfreq = new u16(19);\n    for (var i = 0; i < lclt.length; ++i)\n        lcfreq[lclt[i] & 31]++;\n    for (var i = 0; i < lcdt.length; ++i)\n        lcfreq[lcdt[i] & 31]++;\n    var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];\n    var nlcc = 19;\n    for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)\n        ;\n    var flen = (bl + 5) << 3;\n    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);\n    if (flen <= ftlen && flen <= dtlen)\n        return wfblk(out, p, dat.subarray(bs, bs + bl));\n    var lm, ll, dm, dl;\n    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;\n    if (dtlen < ftlen) {\n        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n        var llm = hMap(lct, mlcb, 0);\n        wbits(out, p, nlc - 257);\n        wbits(out, p + 5, ndc - 1);\n        wbits(out, p + 10, nlcc - 4);\n        p += 14;\n        for (var i = 0; i < nlcc; ++i)\n            wbits(out, p + 3 * i, lct[clim[i]]);\n        p += 3 * nlcc;\n        var lcts = [lclt, lcdt];\n        for (var it = 0; it < 2; ++it) {\n            var clct = lcts[it];\n            for (var i = 0; i < clct.length; ++i) {\n                var len = clct[i] & 31;\n                wbits(out, p, llm[len]), p += lct[len];\n                if (len > 15)\n                    wbits(out, p, (clct[i] >>> 5) & 127), p += clct[i] >>> 12;\n            }\n        }\n    }\n    else {\n        lm = flm, ll = flt, dm = fdm, dl = fdt;\n    }\n    for (var i = 0; i < li; ++i) {\n        if (syms[i] > 255) {\n            var len = (syms[i] >>> 18) & 31;\n            wbits16(out, p, lm[len + 257]), p += ll[len + 257];\n            if (len > 7)\n                wbits(out, p, (syms[i] >>> 23) & 31), p += fleb[len];\n            var dst = syms[i] & 31;\n            wbits16(out, p, dm[dst]), p += dl[dst];\n            if (dst > 3)\n                wbits16(out, p, (syms[i] >>> 5) & 8191), p += fdeb[dst];\n        }\n        else {\n            wbits16(out, p, lm[syms[i]]), p += ll[syms[i]];\n        }\n    }\n    wbits16(out, p, lm[256]);\n    return p + ll[256];\n};\n// deflate options (nice << 13) | chain\nvar deo = /*#__PURE__*/ new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);\n// empty\nvar et = /*#__PURE__*/ new u8(0);\n// compresses data into a raw DEFLATE buffer\nvar dflt = function (dat, lvl, plvl, pre, post, lst) {\n    var s = dat.length;\n    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);\n    // writing to this writes to the output buffer\n    var w = o.subarray(pre, o.length - post);\n    var pos = 0;\n    if (!lvl || s < 8) {\n        for (var i = 0; i <= s; i += 65535) {\n            // end\n            var e = i + 65535;\n            if (e >= s) {\n                // write final block\n                w[pos >> 3] = lst;\n            }\n            pos = wfblk(w, pos + 1, dat.subarray(i, e));\n        }\n    }\n    else {\n        var opt = deo[lvl - 1];\n        var n = opt >>> 13, c = opt & 8191;\n        var msk_1 = (1 << plvl) - 1;\n        //    prev 2-byte val map    curr 2-byte val map\n        var prev = new u16(32768), head = new u16(msk_1 + 1);\n        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;\n        var hsh = function (i) { return (dat[i] ^ (dat[i + 1] << bs1_1) ^ (dat[i + 2] << bs2_1)) & msk_1; };\n        // 24576 is an arbitrary number of maximum symbols per block\n        // 424 buffer for last block\n        var syms = new u32(25000);\n        // length/literal freq   distance freq\n        var lf = new u16(288), df = new u16(32);\n        //  l/lcnt  exbits  index  l/lind  waitdx  bitpos\n        var lc_1 = 0, eb = 0, i = 0, li = 0, wi = 0, bs = 0;\n        for (; i < s; ++i) {\n            // hash value\n            // deopt when i > s - 3 - at end, deopt acceptable\n            var hv = hsh(i);\n            // index mod 32768    previous index mod\n            var imod = i & 32767, pimod = head[hv];\n            prev[imod] = pimod;\n            head[hv] = imod;\n            // We always should modify head and prev, but only add symbols if\n            // this data is not yet processed (\"wait\" for wait index)\n            if (wi <= i) {\n                // bytes remaining\n                var rem = s - i;\n                if ((lc_1 > 7000 || li > 24576) && rem > 423) {\n                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n                    li = lc_1 = eb = 0, bs = i;\n                    for (var j = 0; j < 286; ++j)\n                        lf[j] = 0;\n                    for (var j = 0; j < 30; ++j)\n                        df[j] = 0;\n                }\n                //  len    dist   chain\n                var l = 2, d = 0, ch_1 = c, dif = (imod - pimod) & 32767;\n                if (rem > 2 && hv == hsh(i - dif)) {\n                    var maxn = Math.min(n, rem) - 1;\n                    var maxd = Math.min(32767, i);\n                    // max possible length\n                    // not capped at dif because decompressors implement \"rolling\" index population\n                    var ml = Math.min(258, rem);\n                    while (dif <= maxd && --ch_1 && imod != pimod) {\n                        if (dat[i + l] == dat[i + l - dif]) {\n                            var nl = 0;\n                            for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)\n                                ;\n                            if (nl > l) {\n                                l = nl, d = dif;\n                                // break out early when we reach \"nice\" (we are satisfied enough)\n                                if (nl > maxn)\n                                    break;\n                                // now, find the rarest 2-byte sequence within this\n                                // length of literals and search for that instead.\n                                // Much faster than just using the start\n                                var mmd = Math.min(dif, nl - 2);\n                                var md = 0;\n                                for (var j = 0; j < mmd; ++j) {\n                                    var ti = (i - dif + j + 32768) & 32767;\n                                    var pti = prev[ti];\n                                    var cd = (ti - pti + 32768) & 32767;\n                                    if (cd > md)\n                                        md = cd, pimod = ti;\n                                }\n                            }\n                        }\n                        // check the previous match\n                        imod = pimod, pimod = prev[imod];\n                        dif += (imod - pimod + 32768) & 32767;\n                    }\n                }\n                // d will be nonzero only when a match was found\n                if (d) {\n                    // store both dist and len data in one Uint32\n                    // Make sure this is recognized as a len/dist with 28th bit (2^28)\n                    syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d];\n                    var lin = revfl[l] & 31, din = revfd[d] & 31;\n                    eb += fleb[lin] + fdeb[din];\n                    ++lf[257 + lin];\n                    ++df[din];\n                    wi = i + l;\n                    ++lc_1;\n                }\n                else {\n                    syms[li++] = dat[i];\n                    ++lf[dat[i]];\n                }\n            }\n        }\n        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);\n        // this is the easiest way to avoid needing to maintain state\n        if (!lst && pos & 7)\n            pos = wfblk(w, pos + 1, et);\n    }\n    return slc(o, 0, pre + shft(pos) + post);\n};\n// CRC32 table\nvar crct = /*#__PURE__*/ (function () {\n    var t = new Int32Array(256);\n    for (var i = 0; i < 256; ++i) {\n        var c = i, k = 9;\n        while (--k)\n            c = ((c & 1) && -306674912) ^ (c >>> 1);\n        t[i] = c;\n    }\n    return t;\n})();\n// CRC32\nvar crc = function () {\n    var c = -1;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var cr = c;\n            for (var i = 0; i < d.length; ++i)\n                cr = crct[(cr & 255) ^ d[i]] ^ (cr >>> 8);\n            c = cr;\n        },\n        d: function () { return ~c; }\n    };\n};\n// Alder32\nvar adler = function () {\n    var a = 1, b = 0;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var n = a, m = b;\n            var l = d.length | 0;\n            for (var i = 0; i != l;) {\n                var e = Math.min(i + 2655, l);\n                for (; i < e; ++i)\n                    m += n += d[i];\n                n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);\n            }\n            a = n, b = m;\n        },\n        d: function () {\n            a %= 65521, b %= 65521;\n            return (a & 255) << 24 | (a >>> 8) << 16 | (b & 255) << 8 | (b >>> 8);\n        }\n    };\n};\n;\n// deflate with opts\nvar dopt = function (dat, opt, pre, post, st) {\n    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : (12 + opt.mem), pre, post, !st);\n};\n// Walmart object spread\nvar mrg = function (a, b) {\n    var o = {};\n    for (var k in a)\n        o[k] = a[k];\n    for (var k in b)\n        o[k] = b[k];\n    return o;\n};\n// worker clone\n// This is possibly the craziest part of the entire codebase, despite how simple it may seem.\n// The only parameter to this function is a closure that returns an array of variables outside of the function scope.\n// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.\n// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).\n// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.\n// This took me three weeks to figure out how to do.\nvar wcln = function (fn, fnStr, td) {\n    var dt = fn();\n    var st = fn.toString();\n    var ks = st.slice(st.indexOf('[') + 1, st.lastIndexOf(']')).replace(/\\s+/g, '').split(',');\n    for (var i = 0; i < dt.length; ++i) {\n        var v = dt[i], k = ks[i];\n        if (typeof v == 'function') {\n            fnStr += ';' + k + '=';\n            var st_1 = v.toString();\n            if (v.prototype) {\n                // for global objects\n                if (st_1.indexOf('[native code]') != -1) {\n                    var spInd = st_1.indexOf(' ', 8) + 1;\n                    fnStr += st_1.slice(spInd, st_1.indexOf('(', spInd));\n                }\n                else {\n                    fnStr += st_1;\n                    for (var t in v.prototype)\n                        fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[t].toString();\n                }\n            }\n            else\n                fnStr += st_1;\n        }\n        else\n            td[k] = v;\n    }\n    return [fnStr, td];\n};\nvar ch = [];\n// clone bufs\nvar cbfs = function (v) {\n    var tl = [];\n    for (var k in v) {\n        if (v[k].buffer) {\n            tl.push((v[k] = new v[k].constructor(v[k])).buffer);\n        }\n    }\n    return tl;\n};\n// use a worker to execute code\nvar wrkr = function (fns, init, id, cb) {\n    var _a;\n    if (!ch[id]) {\n        var fnStr = '', td_1 = {}, m = fns.length - 1;\n        for (var i = 0; i < m; ++i)\n            _a = wcln(fns[i], fnStr, td_1), fnStr = _a[0], td_1 = _a[1];\n        ch[id] = wcln(fns[m], fnStr, td_1);\n    }\n    var td = mrg({}, ch[id][1]);\n    return wk(ch[id][0] + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + init.toString() + '}', id, td, cbfs(td), cb);\n};\n// base async inflate fn\nvar bInflt = function () { return [u8, u16, u32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gu8]; };\nvar bDflt = function () { return [u8, u16, u32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf]; };\n// gzip extra\nvar gze = function () { return [gzh, gzhl, wbytes, crc, crct]; };\n// gunzip extra\nvar guze = function () { return [gzs, gzl]; };\n// zlib extra\nvar zle = function () { return [zlh, wbytes, adler]; };\n// unzlib extra\nvar zule = function () { return [zlv]; };\n// post buf\nvar pbf = function (msg) { return postMessage(msg, [msg.buffer]); };\n// get u8\nvar gu8 = function (o) { return o && o.size && new u8(o.size); };\n// async helper\nvar cbify = function (dat, opts, fns, init, id, cb) {\n    var w = wrkr(fns, init, id, function (err, dat) {\n        w.terminate();\n        cb(err, dat);\n    });\n    w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);\n    return function () { w.terminate(); };\n};\n// auto stream\nvar astrm = function (strm) {\n    strm.ondata = function (dat, final) { return postMessage([dat, final], [dat.buffer]); };\n    return function (ev) { return strm.push(ev.data[0], ev.data[1]); };\n};\n// async stream attach\nvar astrmify = function (fns, strm, opts, init, id) {\n    var t;\n    var w = wrkr(fns, init, id, function (err, dat) {\n        if (err)\n            w.terminate(), strm.ondata.call(strm, err);\n        else {\n            if (dat[1])\n                w.terminate();\n            strm.ondata.call(strm, err, dat[0], dat[1]);\n        }\n    });\n    w.postMessage(opts);\n    strm.push = function (d, f) {\n        if (!strm.ondata)\n            err(5);\n        if (t)\n            strm.ondata(err(4, 0, 1), null, !!f);\n        w.postMessage([d, t = f], [d.buffer]);\n    };\n    strm.terminate = function () { w.terminate(); };\n};\n// read 2 bytes\nvar b2 = function (d, b) { return d[b] | (d[b + 1] << 8); };\n// read 4 bytes\nvar b4 = function (d, b) { return (d[b] | (d[b + 1] << 8) | (d[b + 2] << 16) | (d[b + 3] << 24)) >>> 0; };\nvar b8 = function (d, b) { return b4(d, b) + (b4(d, b + 4) * 4294967296); };\n// write bytes\nvar wbytes = function (d, b, v) {\n    for (; v; ++b)\n        d[b] = v, v >>>= 8;\n};\n// gzip header\nvar gzh = function (c, o) {\n    var fn = o.filename;\n    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix\n    if (o.mtime != 0)\n        wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));\n    if (fn) {\n        c[3] = 8;\n        for (var i = 0; i <= fn.length; ++i)\n            c[i + 10] = fn.charCodeAt(i);\n    }\n};\n// gzip footer: -8 to -4 = CRC, -4 to -0 is length\n// gzip start\nvar gzs = function (d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n        err(6, 'invalid gzip data');\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4)\n        st += d[10] | (d[11] << 8) + 2;\n    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\n        ;\n    return st + (flg & 2);\n};\n// gzip length\nvar gzl = function (d) {\n    var l = d.length;\n    return ((d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16) | (d[l - 1] << 24)) >>> 0;\n};\n// gzip header length\nvar gzhl = function (o) { return 10 + ((o.filename && (o.filename.length + 1)) || 0); };\n// zlib header\nvar zlh = function (c, o) {\n    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\n    c[0] = 120, c[1] = (fl << 6) | (fl ? (32 - 2 * fl) : 1);\n};\n// zlib valid\nvar zlv = function (d) {\n    if ((d[0] & 15) != 8 || (d[0] >>> 4) > 7 || ((d[0] << 8 | d[1]) % 31))\n        err(6, 'invalid zlib data');\n    if (d[1] & 32)\n        err(6, 'invalid zlib data: preset dictionaries not supported');\n};\nfunction AsyncCmpStrm(opts, cb) {\n    if (!cb && typeof opts == 'function')\n        cb = opts, opts = {};\n    this.ondata = cb;\n    return opts;\n}\n// zlib footer: -4 to -0 is Adler32\n/**\n * Streaming DEFLATE compression\n */\nvar Deflate = /*#__PURE__*/ (function () {\n    function Deflate(opts, cb) {\n        if (!cb && typeof opts == 'function')\n            cb = opts, opts = {};\n        this.ondata = cb;\n        this.o = opts || {};\n    }\n    Deflate.prototype.p = function (c, f) {\n        this.ondata(dopt(c, this.o, 0, 0, !f), f);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Deflate.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        this.d = final;\n        this.p(chunk, final || false);\n    };\n    return Deflate;\n}());\nexport { Deflate };\n/**\n * Asynchronous streaming DEFLATE compression\n */\nvar AsyncDeflate = /*#__PURE__*/ (function () {\n    function AsyncDeflate(opts, cb) {\n        astrmify([\n            bDflt,\n            function () { return [astrm, Deflate]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Deflate(ev.data);\n            onmessage = astrm(strm);\n        }, 6);\n    }\n    return AsyncDeflate;\n}());\nexport { AsyncDeflate };\nexport function deflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n    ], function (ev) { return pbf(deflateSync(ev.data[0], ev.data[1])); }, 0, cb);\n}\n/**\n * Compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param opts The compression options\n * @returns The deflated version of the data\n */\nexport function deflateSync(data, opts) {\n    return dopt(data, opts || {}, 0, 0);\n}\n/**\n * Streaming DEFLATE decompression\n */\nvar Inflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an inflation stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Inflate(cb) {\n        this.s = {};\n        this.p = new u8(0);\n        this.ondata = cb;\n    }\n    Inflate.prototype.e = function (c) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        var l = this.p.length;\n        var n = new u8(l + c.length);\n        n.set(this.p), n.set(c, l), this.p = n;\n    };\n    Inflate.prototype.c = function (final) {\n        this.d = this.s.i = final || false;\n        var bts = this.s.b;\n        var dt = inflt(this.p, this.o, this.s);\n        this.ondata(slc(dt, bts, this.s.b), this.d);\n        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n        this.p = slc(this.p, (this.s.p / 8) | 0), this.s.p &= 7;\n    };\n    /**\n     * Pushes a chunk to be inflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the final chunk\n     */\n    Inflate.prototype.push = function (chunk, final) {\n        this.e(chunk), this.c(final);\n    };\n    return Inflate;\n}());\nexport { Inflate };\n/**\n * Asynchronous streaming DEFLATE decompression\n */\nvar AsyncInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous inflation stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncInflate(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            function () { return [astrm, Inflate]; }\n        ], this, 0, function () {\n            var strm = new Inflate();\n            onmessage = astrm(strm);\n        }, 7);\n    }\n    return AsyncInflate;\n}());\nexport { AsyncInflate };\nexport function inflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt\n    ], function (ev) { return pbf(inflateSync(ev.data[0], gu8(ev.data[1]))); }, 1, cb);\n}\n/**\n * Expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function inflateSync(data, out) {\n    return inflt(data, out);\n}\n// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.\n/**\n * Streaming GZIP compression\n */\nvar Gzip = /*#__PURE__*/ (function () {\n    function Gzip(opts, cb) {\n        this.c = crc();\n        this.l = 0;\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gzip.prototype.push = function (chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Gzip.prototype.p = function (c, f) {\n        this.c.p(c);\n        this.l += c.length;\n        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, !f);\n        if (this.v)\n            gzh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);\n        this.ondata(raw, f);\n    };\n    return Gzip;\n}());\nexport { Gzip };\n/**\n * Asynchronous streaming GZIP compression\n */\nvar AsyncGzip = /*#__PURE__*/ (function () {\n    function AsyncGzip(opts, cb) {\n        astrmify([\n            bDflt,\n            gze,\n            function () { return [astrm, Deflate, Gzip]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Gzip(ev.data);\n            onmessage = astrm(strm);\n        }, 8);\n    }\n    return AsyncGzip;\n}());\nexport { AsyncGzip };\nexport function gzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n        gze,\n        function () { return [gzipSync]; }\n    ], function (ev) { return pbf(gzipSync(ev.data[0], ev.data[1])); }, 2, cb);\n}\n/**\n * Compresses data with GZIP\n * @param data The data to compress\n * @param opts The compression options\n * @returns The gzipped version of the data\n */\nexport function gzipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var c = crc(), l = data.length;\n    c.p(data);\n    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;\n    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;\n}\n/**\n * Streaming GZIP decompression\n */\nvar Gunzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a GUNZIP stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Gunzip(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be GUNZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gunzip.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            var s = this.p.length > 3 ? gzs(this.p) : 4;\n            if (s >= this.p.length && !final)\n                return;\n            this.p = this.p.subarray(s), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 8)\n                err(6, 'invalid gzip data');\n            this.p = this.p.subarray(0, -8);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Gunzip;\n}());\nexport { Gunzip };\n/**\n * Asynchronous streaming GZIP decompression\n */\nvar AsyncGunzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous GUNZIP stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncGunzip(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            guze,\n            function () { return [astrm, Inflate, Gunzip]; }\n        ], this, 0, function () {\n            var strm = new Gunzip();\n            onmessage = astrm(strm);\n        }, 9);\n    }\n    return AsyncGunzip;\n}());\nexport { AsyncGunzip };\nexport function gunzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt,\n        guze,\n        function () { return [gunzipSync]; }\n    ], function (ev) { return pbf(gunzipSync(ev.data[0])); }, 3, cb);\n}\n/**\n * Expands GZIP data\n * @param data The data to decompress\n * @param out Where to write the data. GZIP already encodes the output size, so providing this doesn't save memory.\n * @returns The decompressed version of the data\n */\nexport function gunzipSync(data, out) {\n    return inflt(data.subarray(gzs(data), -8), out || new u8(gzl(data)));\n}\n/**\n * Streaming Zlib compression\n */\nvar Zlib = /*#__PURE__*/ (function () {\n    function Zlib(opts, cb) {\n        this.c = adler();\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be zlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Zlib.prototype.push = function (chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Zlib.prototype.p = function (c, f) {\n        this.c.p(c);\n        var raw = dopt(c, this.o, this.v && 2, f && 4, !f);\n        if (this.v)\n            zlh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 4, this.c.d());\n        this.ondata(raw, f);\n    };\n    return Zlib;\n}());\nexport { Zlib };\n/**\n * Asynchronous streaming Zlib compression\n */\nvar AsyncZlib = /*#__PURE__*/ (function () {\n    function AsyncZlib(opts, cb) {\n        astrmify([\n            bDflt,\n            zle,\n            function () { return [astrm, Deflate, Zlib]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Zlib(ev.data);\n            onmessage = astrm(strm);\n        }, 10);\n    }\n    return AsyncZlib;\n}());\nexport { AsyncZlib };\nexport function zlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n        zle,\n        function () { return [zlibSync]; }\n    ], function (ev) { return pbf(zlibSync(ev.data[0], ev.data[1])); }, 4, cb);\n}\n/**\n * Compress data with Zlib\n * @param data The data to compress\n * @param opts The compression options\n * @returns The zlib-compressed version of the data\n */\nexport function zlibSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var a = adler();\n    a.p(data);\n    var d = dopt(data, opts, 2, 4);\n    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;\n}\n/**\n * Streaming Zlib decompression\n */\nvar Unzlib = /*#__PURE__*/ (function () {\n    /**\n     * Creates a Zlib decompression stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Unzlib(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be unzlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzlib.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            if (this.p.length < 2 && !final)\n                return;\n            this.p = this.p.subarray(2), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 4)\n                err(6, 'invalid zlib data');\n            this.p = this.p.subarray(0, -4);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Unzlib;\n}());\nexport { Unzlib };\n/**\n * Asynchronous streaming Zlib decompression\n */\nvar AsyncUnzlib = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous Zlib decompression stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncUnzlib(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            zule,\n            function () { return [astrm, Inflate, Unzlib]; }\n        ], this, 0, function () {\n            var strm = new Unzlib();\n            onmessage = astrm(strm);\n        }, 11);\n    }\n    return AsyncUnzlib;\n}());\nexport { AsyncUnzlib };\nexport function unzlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt,\n        zule,\n        function () { return [unzlibSync]; }\n    ], function (ev) { return pbf(unzlibSync(ev.data[0], gu8(ev.data[1]))); }, 5, cb);\n}\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function unzlibSync(data, out) {\n    return inflt((zlv(data), data.subarray(2, -4)), out);\n}\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzip as compress, AsyncGzip as AsyncCompress };\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzipSync as compressSync, Gzip as Compress };\n/**\n * Streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar Decompress = /*#__PURE__*/ (function () {\n    /**\n     * Creates a decompression stream\n     * @param cb The callback to call whenever data is decompressed\n     */\n    function Decompress(cb) {\n        this.G = Gunzip;\n        this.I = Inflate;\n        this.Z = Unzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Decompress.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (!this.s) {\n            if (this.p && this.p.length) {\n                var n = new u8(this.p.length + chunk.length);\n                n.set(this.p), n.set(chunk, this.p.length);\n            }\n            else\n                this.p = chunk;\n            if (this.p.length > 2) {\n                var _this_1 = this;\n                var cb = function () { _this_1.ondata.apply(_this_1, arguments); };\n                this.s = (this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8)\n                    ? new this.G(cb)\n                    : ((this.p[0] & 15) != 8 || (this.p[0] >> 4) > 7 || ((this.p[0] << 8 | this.p[1]) % 31))\n                        ? new this.I(cb)\n                        : new this.Z(cb);\n                this.s.push(this.p, final);\n                this.p = null;\n            }\n        }\n        else\n            this.s.push(chunk, final);\n    };\n    return Decompress;\n}());\nexport { Decompress };\n/**\n * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar AsyncDecompress = /*#__PURE__*/ (function () {\n    /**\n   * Creates an asynchronous decompression stream\n   * @param cb The callback to call whenever data is decompressed\n   */\n    function AsyncDecompress(cb) {\n        this.G = AsyncGunzip;\n        this.I = AsyncInflate;\n        this.Z = AsyncUnzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncDecompress.prototype.push = function (chunk, final) {\n        Decompress.prototype.push.call(this, chunk, final);\n    };\n    return AsyncDecompress;\n}());\nexport { AsyncDecompress };\nexport function decompress(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzip(data, opts, cb)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflate(data, opts, cb)\n            : unzlib(data, opts, cb);\n}\n/**\n * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function decompressSync(data, out) {\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzipSync(data, out)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflateSync(data, out)\n            : unzlibSync(data, out);\n}\n// flatten a directory structure\nvar fltn = function (d, p, t, o) {\n    for (var k in d) {\n        var val = d[k], n = p + k, op = o;\n        if (Array.isArray(val))\n            op = mrg(o, val[1]), val = val[0];\n        if (val instanceof u8)\n            t[n] = [val, op];\n        else {\n            t[n += '/'] = [new u8(0), op];\n            fltn(val, n, t, o);\n        }\n    }\n};\n// text encoder\nvar te = typeof TextEncoder != 'undefined' && /*#__PURE__*/ new TextEncoder();\n// text decoder\nvar td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();\n// text decoder stream\nvar tds = 0;\ntry {\n    td.decode(et, { stream: true });\n    tds = 1;\n}\ncatch (e) { }\n// decode UTF8\nvar dutf8 = function (d) {\n    for (var r = '', i = 0;;) {\n        var c = d[i++];\n        var eb = (c > 127) + (c > 223) + (c > 239);\n        if (i + eb > d.length)\n            return [r, slc(d, i - 1)];\n        if (!eb)\n            r += String.fromCharCode(c);\n        else if (eb == 3) {\n            c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63)) - 65536,\n                r += String.fromCharCode(55296 | (c >> 10), 56320 | (c & 1023));\n        }\n        else if (eb & 1)\n            r += String.fromCharCode((c & 31) << 6 | (d[i++] & 63));\n        else\n            r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63));\n    }\n};\n/**\n * Streaming UTF-8 decoding\n */\nvar DecodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is decoded\n     */\n    function DecodeUTF8(cb) {\n        this.ondata = cb;\n        if (tds)\n            this.t = new TextDecoder();\n        else\n            this.p = et;\n    }\n    /**\n     * Pushes a chunk to be decoded from UTF-8 binary\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    DecodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        final = !!final;\n        if (this.t) {\n            this.ondata(this.t.decode(chunk, { stream: true }), final);\n            if (final) {\n                if (this.t.decode().length)\n                    err(8);\n                this.t = null;\n            }\n            return;\n        }\n        if (!this.p)\n            err(4);\n        var dat = new u8(this.p.length + chunk.length);\n        dat.set(this.p);\n        dat.set(chunk, this.p.length);\n        var _a = dutf8(dat), ch = _a[0], np = _a[1];\n        if (final) {\n            if (np.length)\n                err(8);\n            this.p = null;\n        }\n        else\n            this.p = np;\n        this.ondata(ch, final);\n    };\n    return DecodeUTF8;\n}());\nexport { DecodeUTF8 };\n/**\n * Streaming UTF-8 encoding\n */\nvar EncodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is encoded\n     */\n    function EncodeUTF8(cb) {\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be encoded to UTF-8\n     * @param chunk The string data to push\n     * @param final Whether this is the last chunk\n     */\n    EncodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        this.ondata(strToU8(chunk), this.d = final || false);\n    };\n    return EncodeUTF8;\n}());\nexport { EncodeUTF8 };\n/**\n * Converts a string into a Uint8Array for use with compression/decompression methods\n * @param str The string to encode\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless decoding a binary string.\n * @returns The string encoded in UTF-8/Latin-1 binary\n */\nexport function strToU8(str, latin1) {\n    if (latin1) {\n        var ar_1 = new u8(str.length);\n        for (var i = 0; i < str.length; ++i)\n            ar_1[i] = str.charCodeAt(i);\n        return ar_1;\n    }\n    if (te)\n        return te.encode(str);\n    var l = str.length;\n    var ar = new u8(str.length + (str.length >> 1));\n    var ai = 0;\n    var w = function (v) { ar[ai++] = v; };\n    for (var i = 0; i < l; ++i) {\n        if (ai + 5 > ar.length) {\n            var n = new u8(ai + 8 + ((l - i) << 1));\n            n.set(ar);\n            ar = n;\n        }\n        var c = str.charCodeAt(i);\n        if (c < 128 || latin1)\n            w(c);\n        else if (c < 2048)\n            w(192 | (c >> 6)), w(128 | (c & 63));\n        else if (c > 55295 && c < 57344)\n            c = 65536 + (c & 1023 << 10) | (str.charCodeAt(++i) & 1023),\n                w(240 | (c >> 18)), w(128 | ((c >> 12) & 63)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n        else\n            w(224 | (c >> 12)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n    }\n    return slc(ar, 0, ai);\n}\n/**\n * Converts a Uint8Array to a string\n * @param dat The data to decode to string\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless encoding to binary string.\n * @returns The original UTF-8/Latin-1 string\n */\nexport function strFromU8(dat, latin1) {\n    if (latin1) {\n        var r = '';\n        for (var i = 0; i < dat.length; i += 16384)\n            r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));\n        return r;\n    }\n    else if (td)\n        return td.decode(dat);\n    else {\n        var _a = dutf8(dat), out = _a[0], ext = _a[1];\n        if (ext.length)\n            err(8);\n        return out;\n    }\n}\n;\n// deflate bit flag\nvar dbf = function (l) { return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0; };\n// skip local zip header\nvar slzh = function (d, b) { return b + 30 + b2(d, b + 26) + b2(d, b + 28); };\n// read zip header\nvar zh = function (d, b, z) {\n    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\n    var _a = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a[0], su = _a[1], off = _a[2];\n    return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];\n};\n// read zip64 extra field\nvar z64e = function (d, b) {\n    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))\n        ;\n    return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];\n};\n// extra field length\nvar exfl = function (ex) {\n    var le = 0;\n    if (ex) {\n        for (var k in ex) {\n            var l = ex[k].length;\n            if (l > 65535)\n                err(9);\n            le += l + 4;\n        }\n    }\n    return le;\n};\n// write zip header\nvar wzh = function (d, b, f, fn, u, c, ce, co) {\n    var fl = fn.length, ex = f.extra, col = co && co.length;\n    var exl = exfl(ex);\n    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;\n    if (ce != null)\n        d[b++] = 20, d[b++] = f.os;\n    d[b] = 20, b += 2; // spec compliance? what's that?\n    d[b++] = (f.flag << 1) | (c < 0 && 8), d[b++] = u && 8;\n    d[b++] = f.compression & 255, d[b++] = f.compression >> 8;\n    var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;\n    if (y < 0 || y > 119)\n        err(10);\n    wbytes(d, b, (y << 25) | ((dt.getMonth() + 1) << 21) | (dt.getDate() << 16) | (dt.getHours() << 11) | (dt.getMinutes() << 5) | (dt.getSeconds() >>> 1)), b += 4;\n    if (c != -1) {\n        wbytes(d, b, f.crc);\n        wbytes(d, b + 4, c < 0 ? -c - 2 : c);\n        wbytes(d, b + 8, f.size);\n    }\n    wbytes(d, b + 12, fl);\n    wbytes(d, b + 14, exl), b += 16;\n    if (ce != null) {\n        wbytes(d, b, col);\n        wbytes(d, b + 6, f.attrs);\n        wbytes(d, b + 10, ce), b += 14;\n    }\n    d.set(fn, b);\n    b += fl;\n    if (exl) {\n        for (var k in ex) {\n            var exf = ex[k], l = exf.length;\n            wbytes(d, b, +k);\n            wbytes(d, b + 2, l);\n            d.set(exf, b + 4), b += 4 + l;\n        }\n    }\n    if (col)\n        d.set(co, b), b += col;\n    return b;\n};\n// write zip footer (end of central directory)\nvar wzf = function (o, b, c, d, e) {\n    wbytes(o, b, 0x6054B50); // skip disk\n    wbytes(o, b + 8, c);\n    wbytes(o, b + 10, c);\n    wbytes(o, b + 12, d);\n    wbytes(o, b + 16, e);\n};\n/**\n * A pass-through stream to keep data uncompressed in a ZIP archive.\n */\nvar ZipPassThrough = /*#__PURE__*/ (function () {\n    /**\n     * Creates a pass-through stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     */\n    function ZipPassThrough(filename) {\n        this.filename = filename;\n        this.c = crc();\n        this.size = 0;\n        this.compression = 0;\n    }\n    /**\n     * Processes a chunk and pushes to the output stream. You can override this\n     * method in a subclass for custom behavior, but by default this passes\n     * the data through. You must call this.ondata(err, chunk, final) at some\n     * point in this method.\n     * @param chunk The chunk to process\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.process = function (chunk, final) {\n        this.ondata(null, chunk, final);\n    };\n    /**\n     * Pushes a chunk to be added. If you are subclassing this with a custom\n     * compression algorithm, note that you must push data from the source\n     * file only, pre-compression.\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        this.c.p(chunk);\n        this.size += chunk.length;\n        if (final)\n            this.crc = this.c.d();\n        this.process(chunk, final || false);\n    };\n    return ZipPassThrough;\n}());\nexport { ZipPassThrough };\n// I don't extend because TypeScript extension adds 1kB of runtime bloat\n/**\n * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate\n * for better performance\n */\nvar ZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function ZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new Deflate(opts, function (dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n    }\n    ZipDeflate.prototype.process = function (chunk, final) {\n        try {\n            this.d.push(chunk, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return ZipDeflate;\n}());\nexport { ZipDeflate };\n/**\n * Asynchronous streaming DEFLATE compression for ZIP archives\n */\nvar AsyncZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function AsyncZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new AsyncDeflate(opts, function (err, dat, final) {\n            _this_1.ondata(err, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n        this.terminate = this.d.terminate;\n    }\n    AsyncZipDeflate.prototype.process = function (chunk, final) {\n        this.d.push(chunk, final);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return AsyncZipDeflate;\n}());\nexport { AsyncZipDeflate };\n// TODO: Better tree shaking\n/**\n * A zippable archive to which files can incrementally be added\n */\nvar Zip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an empty ZIP archive to which files can be added\n     * @param cb The callback to call whenever data for the generated ZIP archive\n     *           is available\n     */\n    function Zip(cb) {\n        this.ondata = cb;\n        this.u = [];\n        this.d = 1;\n    }\n    /**\n     * Adds a file to the ZIP archive\n     * @param file The file stream to add\n     */\n    Zip.prototype.add = function (file) {\n        var _this_1 = this;\n        if (!this.ondata)\n            err(5);\n        // finishing or finished\n        if (this.d & 2)\n            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, false);\n        else {\n            var f = strToU8(file.filename), fl_1 = f.length;\n            var com = file.comment, o = com && strToU8(com);\n            var u = fl_1 != file.filename.length || (o && (com.length != o.length));\n            var hl_1 = fl_1 + exfl(file.extra) + 30;\n            if (fl_1 > 65535)\n                this.ondata(err(11, 0, 1), null, false);\n            var header = new u8(hl_1);\n            wzh(header, 0, file, f, u, -1);\n            var chks_1 = [header];\n            var pAll_1 = function () {\n                for (var _i = 0, chks_2 = chks_1; _i < chks_2.length; _i++) {\n                    var chk = chks_2[_i];\n                    _this_1.ondata(null, chk, false);\n                }\n                chks_1 = [];\n            };\n            var tr_1 = this.d;\n            this.d = 0;\n            var ind_1 = this.u.length;\n            var uf_1 = mrg(file, {\n                f: f,\n                u: u,\n                o: o,\n                t: function () {\n                    if (file.terminate)\n                        file.terminate();\n                },\n                r: function () {\n                    pAll_1();\n                    if (tr_1) {\n                        var nxt = _this_1.u[ind_1 + 1];\n                        if (nxt)\n                            nxt.r();\n                        else\n                            _this_1.d = 1;\n                    }\n                    tr_1 = 1;\n                }\n            });\n            var cl_1 = 0;\n            file.ondata = function (err, dat, final) {\n                if (err) {\n                    _this_1.ondata(err, dat, final);\n                    _this_1.terminate();\n                }\n                else {\n                    cl_1 += dat.length;\n                    chks_1.push(dat);\n                    if (final) {\n                        var dd = new u8(16);\n                        wbytes(dd, 0, 0x8074B50);\n                        wbytes(dd, 4, file.crc);\n                        wbytes(dd, 8, cl_1);\n                        wbytes(dd, 12, file.size);\n                        chks_1.push(dd);\n                        uf_1.c = cl_1, uf_1.b = hl_1 + cl_1 + 16, uf_1.crc = file.crc, uf_1.size = file.size;\n                        if (tr_1)\n                            uf_1.r();\n                        tr_1 = 1;\n                    }\n                    else if (tr_1)\n                        pAll_1();\n                }\n            };\n            this.u.push(uf_1);\n        }\n    };\n    /**\n     * Ends the process of adding files and prepares to emit the final chunks.\n     * This *must* be called after adding all desired files for the resulting\n     * ZIP file to work properly.\n     */\n    Zip.prototype.end = function () {\n        var _this_1 = this;\n        if (this.d & 2) {\n            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, true);\n            return;\n        }\n        if (this.d)\n            this.e();\n        else\n            this.u.push({\n                r: function () {\n                    if (!(_this_1.d & 1))\n                        return;\n                    _this_1.u.splice(-1, 1);\n                    _this_1.e();\n                },\n                t: function () { }\n            });\n        this.d = 3;\n    };\n    Zip.prototype.e = function () {\n        var bt = 0, l = 0, tl = 0;\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);\n        }\n        var out = new u8(tl + 22);\n        for (var _b = 0, _c = this.u; _b < _c.length; _b++) {\n            var f = _c[_b];\n            wzh(out, bt, f, f.f, f.u, -f.c - 2, l, f.o);\n            bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;\n        }\n        wzf(out, bt, this.u.length, tl, l);\n        this.ondata(null, out, true);\n        this.d = 2;\n    };\n    /**\n     * A method to terminate any internal workers used by the stream. Subsequent\n     * calls to add() will fail.\n     */\n    Zip.prototype.terminate = function () {\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            f.t();\n        }\n        this.d = 2;\n    };\n    return Zip;\n}());\nexport { Zip };\nexport function zip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    var r = {};\n    fltn(data, '', r, opts);\n    var k = Object.keys(r);\n    var lft = k.length, o = 0, tot = 0;\n    var slft = lft, files = new Array(lft);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var cbd = function (a, b) {\n        mt(function () { cb(a, b); });\n    };\n    mt(function () { cbd = cb; });\n    var cbf = function () {\n        var out = new u8(tot + 22), oe = o, cdl = tot - o;\n        tot = 0;\n        for (var i = 0; i < slft; ++i) {\n            var f = files[i];\n            try {\n                var l = f.c.length;\n                wzh(out, tot, f, f.f, f.u, l);\n                var badd = 30 + f.f.length + exfl(f.extra);\n                var loc = tot + badd;\n                out.set(f.c, loc);\n                wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;\n            }\n            catch (e) {\n                return cbd(e, null);\n            }\n        }\n        wzf(out, o, files.length, cdl, oe);\n        cbd(null, out);\n    };\n    if (!lft)\n        cbf();\n    var _loop_1 = function (i) {\n        var fn = k[i];\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var c = crc(), size = file.length;\n        c.p(file);\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        var compression = p.level == 0 ? 0 : 8;\n        var cbl = function (e, d) {\n            if (e) {\n                tAll();\n                cbd(e, null);\n            }\n            else {\n                var l = d.length;\n                files[i] = mrg(p, {\n                    size: size,\n                    crc: c.d(),\n                    c: d,\n                    f: f,\n                    m: m,\n                    u: s != fn.length || (m && (com.length != ms)),\n                    compression: compression\n                });\n                o += 30 + s + exl + l;\n                tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n                if (!--lft)\n                    cbf();\n            }\n        };\n        if (s > 65535)\n            cbl(err(11, 0, 1), null);\n        if (!compression)\n            cbl(null, file);\n        else if (size < 160000) {\n            try {\n                cbl(null, deflateSync(file, p));\n            }\n            catch (e) {\n                cbl(e, null);\n            }\n        }\n        else\n            term.push(deflate(file, p, cbl));\n    };\n    // Cannot use lft because it can decrease\n    for (var i = 0; i < slft; ++i) {\n        _loop_1(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously creates a ZIP file. Prefer using `zip` for better performance\n * with more than one file.\n * @param data The directory structure for the ZIP archive\n * @param opts The main options, merged with per-file options\n * @returns The generated ZIP archive\n */\nexport function zipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var r = {};\n    var files = [];\n    fltn(data, '', r, opts);\n    var o = 0;\n    var tot = 0;\n    for (var fn in r) {\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var compression = p.level == 0 ? 0 : 8;\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        if (s > 65535)\n            err(11);\n        var d = compression ? deflateSync(file, p) : file, l = d.length;\n        var c = crc();\n        c.p(file);\n        files.push(mrg(p, {\n            size: file.length,\n            crc: c.d(),\n            c: d,\n            f: f,\n            m: m,\n            u: s != fn.length || (m && (com.length != ms)),\n            o: o,\n            compression: compression\n        }));\n        o += 30 + s + exl + l;\n        tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n    }\n    var out = new u8(tot + 22), oe = o, cdl = tot - o;\n    for (var i = 0; i < files.length; ++i) {\n        var f = files[i];\n        wzh(out, f.o, f, f.f, f.u, f.c.length);\n        var badd = 30 + f.f.length + exfl(f.extra);\n        out.set(f.c, f.o + badd);\n        wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);\n    }\n    wzf(out, o, files.length, cdl, oe);\n    return out;\n}\n/**\n * Streaming pass-through decompression for ZIP archives\n */\nvar UnzipPassThrough = /*#__PURE__*/ (function () {\n    function UnzipPassThrough() {\n    }\n    UnzipPassThrough.prototype.push = function (data, final) {\n        this.ondata(null, data, final);\n    };\n    UnzipPassThrough.compression = 0;\n    return UnzipPassThrough;\n}());\nexport { UnzipPassThrough };\n/**\n * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for\n * better performance.\n */\nvar UnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function UnzipInflate() {\n        var _this_1 = this;\n        this.i = new Inflate(function (dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n    }\n    UnzipInflate.prototype.push = function (data, final) {\n        try {\n            this.i.push(data, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    UnzipInflate.compression = 8;\n    return UnzipInflate;\n}());\nexport { UnzipInflate };\n/**\n * Asynchronous streaming DEFLATE decompression for ZIP archives\n */\nvar AsyncUnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function AsyncUnzipInflate(_, sz) {\n        var _this_1 = this;\n        if (sz < 320000) {\n            this.i = new Inflate(function (dat, final) {\n                _this_1.ondata(null, dat, final);\n            });\n        }\n        else {\n            this.i = new AsyncInflate(function (err, dat, final) {\n                _this_1.ondata(err, dat, final);\n            });\n            this.terminate = this.i.terminate;\n        }\n    }\n    AsyncUnzipInflate.prototype.push = function (data, final) {\n        if (this.i.terminate)\n            data = slc(data, 0);\n        this.i.push(data, final);\n    };\n    AsyncUnzipInflate.compression = 8;\n    return AsyncUnzipInflate;\n}());\nexport { AsyncUnzipInflate };\n/**\n * A ZIP archive decompression stream that emits files as they are discovered\n */\nvar Unzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a ZIP decompression stream\n     * @param cb The callback to call whenever a file in the ZIP archive is found\n     */\n    function Unzip(cb) {\n        this.onfile = cb;\n        this.k = [];\n        this.o = {\n            0: UnzipPassThrough\n        };\n        this.p = et;\n    }\n    /**\n     * Pushes a chunk to be unzipped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzip.prototype.push = function (chunk, final) {\n        var _this_1 = this;\n        if (!this.onfile)\n            err(5);\n        if (!this.p)\n            err(4);\n        if (this.c > 0) {\n            var len = Math.min(this.c, chunk.length);\n            var toAdd = chunk.subarray(0, len);\n            this.c -= len;\n            if (this.d)\n                this.d.push(toAdd, !this.c);\n            else\n                this.k[0].push(toAdd);\n            chunk = chunk.subarray(len);\n            if (chunk.length)\n                return this.push(chunk, final);\n        }\n        else {\n            var f = 0, i = 0, is = void 0, buf = void 0;\n            if (!this.p.length)\n                buf = chunk;\n            else if (!chunk.length)\n                buf = this.p;\n            else {\n                buf = new u8(this.p.length + chunk.length);\n                buf.set(this.p), buf.set(chunk, this.p.length);\n            }\n            var l = buf.length, oc = this.c, add = oc && this.d;\n            var _loop_2 = function () {\n                var _a;\n                var sig = b4(buf, i);\n                if (sig == 0x4034B50) {\n                    f = 1, is = i;\n                    this_1.d = null;\n                    this_1.c = 0;\n                    var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);\n                    if (l > i + 30 + fnl + es) {\n                        var chks_3 = [];\n                        this_1.k.unshift(chks_3);\n                        f = 2;\n                        var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);\n                        var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);\n                        if (sc_1 == 4294967295) {\n                            _a = dd ? [-2] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];\n                        }\n                        else if (dd)\n                            sc_1 = -1;\n                        i += es;\n                        this_1.c = sc_1;\n                        var d_1;\n                        var file_1 = {\n                            name: fn_1,\n                            compression: cmp_1,\n                            start: function () {\n                                if (!file_1.ondata)\n                                    err(5);\n                                if (!sc_1)\n                                    file_1.ondata(null, et, true);\n                                else {\n                                    var ctr = _this_1.o[cmp_1];\n                                    if (!ctr)\n                                        file_1.ondata(err(14, 'unknown compression type ' + cmp_1, 1), null, false);\n                                    d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);\n                                    d_1.ondata = function (err, dat, final) { file_1.ondata(err, dat, final); };\n                                    for (var _i = 0, chks_4 = chks_3; _i < chks_4.length; _i++) {\n                                        var dat = chks_4[_i];\n                                        d_1.push(dat, false);\n                                    }\n                                    if (_this_1.k[0] == chks_3 && _this_1.c)\n                                        _this_1.d = d_1;\n                                    else\n                                        d_1.push(et, true);\n                                }\n                            },\n                            terminate: function () {\n                                if (d_1 && d_1.terminate)\n                                    d_1.terminate();\n                            }\n                        };\n                        if (sc_1 >= 0)\n                            file_1.size = sc_1, file_1.originalSize = su_1;\n                        this_1.onfile(file_1);\n                    }\n                    return \"break\";\n                }\n                else if (oc) {\n                    if (sig == 0x8074B50) {\n                        is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                    else if (sig == 0x2014B50) {\n                        is = i -= 4, f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                }\n            };\n            var this_1 = this;\n            for (; i < l - 4; ++i) {\n                var state_1 = _loop_2();\n                if (state_1 === \"break\")\n                    break;\n            }\n            this.p = et;\n            if (oc < 0) {\n                var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);\n                if (add)\n                    add.push(dat, !!f);\n                else\n                    this.k[+(f == 2)].push(dat);\n            }\n            if (f & 2)\n                return this.push(buf.subarray(i), final);\n            this.p = buf.subarray(i);\n        }\n        if (final) {\n            if (this.c)\n                err(13);\n            this.p = null;\n        }\n    };\n    /**\n     * Registers a decoder with the stream, allowing for files compressed with\n     * the compression type provided to be expanded correctly\n     * @param decoder The decoder constructor\n     */\n    Unzip.prototype.register = function (decoder) {\n        this.o[decoder.compression] = decoder;\n    };\n    return Unzip;\n}());\nexport { Unzip };\nvar mt = typeof queueMicrotask == 'function' ? queueMicrotask : typeof setTimeout == 'function' ? setTimeout : function (fn) { fn(); };\nexport function unzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var files = {};\n    var cbd = function (a, b) {\n        mt(function () { cb(a, b); });\n    };\n    mt(function () { cbd = cb; });\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558) {\n            cbd(err(13, 0, 1), null);\n            return tAll;\n        }\n    }\n    ;\n    var lft = b2(data, e + 8);\n    if (lft) {\n        var c = lft;\n        var o = b4(data, e + 16);\n        var z = o == 4294967295 || c == 65535;\n        if (z) {\n            var ze = b4(data, e - 12);\n            z = b4(data, ze) == 0x6064B50;\n            if (z) {\n                c = lft = b4(data, ze + 32);\n                o = b4(data, ze + 48);\n            }\n        }\n        var fltr = opts && opts.filter;\n        var _loop_3 = function (i) {\n            var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n            o = no;\n            var cbl = function (e, d) {\n                if (e) {\n                    tAll();\n                    cbd(e, null);\n                }\n                else {\n                    if (d)\n                        files[fn] = d;\n                    if (!--lft)\n                        cbd(null, files);\n                }\n            };\n            if (!fltr || fltr({\n                name: fn,\n                size: sc,\n                originalSize: su,\n                compression: c_1\n            })) {\n                if (!c_1)\n                    cbl(null, slc(data, b, b + sc));\n                else if (c_1 == 8) {\n                    var infl = data.subarray(b, b + sc);\n                    if (sc < 320000) {\n                        try {\n                            cbl(null, inflateSync(infl, new u8(su)));\n                        }\n                        catch (e) {\n                            cbl(e, null);\n                        }\n                    }\n                    else\n                        term.push(inflate(infl, { size: su }, cbl));\n                }\n                else\n                    cbl(err(14, 'unknown compression type ' + c_1, 1), null);\n            }\n            else\n                cbl(null, null);\n        };\n        for (var i = 0; i < c; ++i) {\n            _loop_3(i);\n        }\n    }\n    else\n        cbd(null, {});\n    return tAll;\n}\n/**\n * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better\n * performance with more than one file.\n * @param data The raw compressed ZIP file\n * @param opts The ZIP extraction options\n * @returns The decompressed files\n */\nexport function unzipSync(data, opts) {\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558)\n            err(13);\n    }\n    ;\n    var c = b2(data, e + 8);\n    if (!c)\n        return {};\n    var o = b4(data, e + 16);\n    var z = o == 4294967295 || c == 65535;\n    if (z) {\n        var ze = b4(data, e - 12);\n        z = b4(data, ze) == 0x6064B50;\n        if (z) {\n            c = b4(data, ze + 32);\n            o = b4(data, ze + 48);\n        }\n    }\n    var fltr = opts && opts.filter;\n    for (var i = 0; i < c; ++i) {\n        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        if (!fltr || fltr({\n            name: fn,\n            size: sc,\n            originalSize: su,\n            compression: c_2\n        })) {\n            if (!c_2)\n                files[fn] = slc(data, b, b + sc);\n            else if (c_2 == 8)\n                files[fn] = inflateSync(data.subarray(b, b + sc), new u8(su));\n            else\n                err(14, 'unknown compression type ' + c_2);\n        }\n    }\n    return files;\n}\n","import * as fflate from 'fflate';\nexport default class FFlateEncoder {\n    encode(arrayBuffer) {\n        return fflate.gzipSync(new Uint8Array(arrayBuffer)).buffer;\n    }\n    decode(arrayBuffer) {\n        return fflate.gunzipSync(new Uint8Array(arrayBuffer)).buffer;\n    }\n}\n","export const SPLIT_REGEX = /\\W+/g;\nexport const TEST_REGEX = /(\\w\\W+|\\W+\\w)/;\n/**\n * detect the type of a value\n *\n * @param value Value to analyze\n * @returns type of the value\n */\nexport function getType(value) {\n    if (Array.isArray(value)) {\n        return \"array\";\n    }\n    else if (typeof value === \"object\" && value) {\n        return \"object\";\n    }\n    else if (typeof value === \"string\" && TEST_REGEX.test(value)) {\n        return \"split\";\n    }\n    else {\n        return \"leaf\";\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport Loader from \"../io/Loader\";\nimport { getType, SPLIT_REGEX } from \"./Token\";\nimport md5 from \"blueimp-md5\";\n/**\n * Class for spitting objects into tokens.\n */\nexport default class Tokenizer {\n    constructor() {\n        this.loader = new Loader();\n    }\n    /**\n     * Load json or text files and turn them into tokens.\n     *\n     * @param files files to load and reduce.\n     */\n    load(...files) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (files.some(file => typeof file !== \"string\")) {\n                throw new Error(\"Each argument passed to load must be a string.\");\n            }\n            const sortedFiles = files.sort();\n            const allData = yield Promise.all(sortedFiles.map(this.loader.load));\n            return this.tokenize(Object.fromEntries(allData.map((data, index) => [sortedFiles[index], data])));\n        });\n    }\n    /**\n     * Takes a mapping of filename and their corresponding data, and turn them into tokens.\n     *\n     * @param items Mapping from filename to data.\n     * @returns All data stored as tokens.\n     */\n    tokenize(items) {\n        const header = {\n            registry: {},\n            files: {},\n        };\n        const counter = { next: 0 };\n        Object.entries(items).forEach(([file, value]) => {\n            header.files[file] = {\n                nameToken: this.tokenizeHelper(file, header.registry, counter, \"header\"),\n                token: this.tokenizeHelper(value, header.registry, counter, file),\n            };\n        });\n        return header;\n    }\n    registerToken(hash, value, registry, counter, file, reference) {\n        var _a;\n        const entry = (_a = registry[hash]) !== null && _a !== void 0 ? _a : (registry[hash] = {\n            type: getType(value),\n            hash,\n            value,\n            reference,\n            order: counter.next++,\n            count: 0,\n            files: new Set(),\n        });\n        entry.files.add(file);\n        entry.count++;\n        return entry;\n    }\n    tokenizeHelper(item, registry, counter, file) {\n        const type = getType(item);\n        if (type === \"array\") {\n            if (!Array.isArray(item)) {\n                throw new Error(\"item should be an array\");\n            }\n            const hashes = item.map(item => this.tokenizeHelper(item, registry, counter, file)).map(({ hash }) => hash);\n            const hash = md5(hashes.join(\",\"));\n            return this.registerToken(hash, item, registry, counter, file, hashes);\n        }\n        else if (type === \"object\") {\n            const entries = Object.entries(item);\n            const keysToken = this.tokenizeHelper(entries.map(([key]) => key), registry, counter, file);\n            const valuesToken = this.tokenizeHelper(entries.map(([, value]) => value), registry, counter, file);\n            const hash = md5(`${keysToken.hash}|${valuesToken.hash}`);\n            return this.registerToken(hash, item, registry, counter, file, [keysToken.hash, valuesToken.hash]);\n        }\n        else if (type === \"split\") {\n            const chunks = item.split(SPLIT_REGEX);\n            const separators = item.match(SPLIT_REGEX);\n            const chunksToken = this.tokenizeHelper(chunks, registry, counter, file);\n            const separatorsToken = this.tokenizeHelper(separators, registry, counter, file);\n            const hash = md5(`${chunksToken.hash}-${separatorsToken.hash}`);\n            return this.registerToken(hash, item, registry, counter, file, [chunksToken.hash, separatorsToken.hash]);\n        }\n        else {\n            const m = md5(JSON.stringify(item));\n            return this.registerToken(m, item, registry, counter, file);\n        }\n    }\n}\n","const DEFAULT_CONFIG = {\n    cacheable: true,\n    allowReferences: false,\n};\n/**\n * Class storing all data that can be extracted.\n */\nexport default class ExtractableData {\n    constructor(dataStore, config) {\n        this.extractor = new Extractor();\n        this.dataStore = dataStore;\n        this.config = Object.assign(Object.assign({}, DEFAULT_CONFIG), config);\n        this.fileNames = this.extractor.extractFileNames(dataStore.files, dataStore.headerTokens, this.config);\n        this.fileToSlot = Object.fromEntries(this.fileNames.map((file, index) => [file, index]));\n    }\n    /**\n     * Extract data form a stored file.\n     *\n     * @param filename filename to be extracted.\n     * @param allowReferences If true, within the extracted object, multiple nodes can reference the same object.\n     *  This helps performance and memory, but can lead to weird side effects if the extracted object\n     *  gets modified.\n     * @returns extracted data.\n     */\n    extract(filename, allowReferences) {\n        const slot = this.fileToSlot[filename];\n        const dataTokens = this.dataStore.getDataTokens(slot);\n        if (dataTokens) {\n            return this.extractor.extract(this.dataStore.headerTokens, dataTokens, Object.assign(Object.assign({}, this.config), { allowReferences: allowReferences !== null && allowReferences !== void 0 ? allowReferences : this.config.allowReferences }));\n        }\n    }\n}\nclass Extractor {\n    constructor() {\n        this.valueFetcher = {\n            \"array\": this.getArray.bind(this),\n            \"leaf\": undefined,\n            \"object\": this.getObject.bind(this),\n            \"split\": this.getSplit.bind(this),\n        };\n    }\n    extractFileNames(files, headerTokens, config) {\n        return files.map(index => this.extractToken(index, headerTokens, undefined, config));\n    }\n    extract(headerTokens, dataTokens, config) {\n        return this.extractToken(headerTokens.length + dataTokens.length - 1, headerTokens, dataTokens, config);\n    }\n    extractToken(index, headerTokens, dataTokens, config, forceAllowUseCache) {\n        const token = index < headerTokens.length ? headerTokens[index] : dataTokens === null || dataTokens === void 0 ? void 0 : dataTokens[index - headerTokens.length];\n        if (!token) {\n            throw new Error(\"Invalid token at index: \" + index);\n        }\n        if (token.type === \"leaf\") {\n            return token.value;\n        }\n        return this.extractValueOrCache(token, headerTokens, dataTokens, config, forceAllowUseCache || config.allowReferences, this.valueFetcher[token.type]);\n    }\n    getArray(token, headerTokens, dataTokens, config) {\n        if (!Array.isArray(token.value)) {\n            throw new Error(\"Invalid array token\");\n        }\n        return token.value.map(index => this.extractToken(index, headerTokens, dataTokens, config));\n    }\n    getObject(token, headerTokens, dataTokens, config) {\n        const [keyIndex, valueIndex] = token.value;\n        const keys = this.extractToken(keyIndex, headerTokens, dataTokens, config, true);\n        const values = this.extractToken(valueIndex, headerTokens, dataTokens, config);\n        return Object.fromEntries(keys.map((key, index) => [key, values[index]]));\n    }\n    getSplit(token, headerTokens, dataTokens, config) {\n        const [chunksIndex, separatorsIndex] = token.value;\n        const chunks = this.extractToken(chunksIndex, headerTokens, dataTokens, config, true);\n        const separators = this.extractToken(separatorsIndex, headerTokens, dataTokens, config, true);\n        return chunks.map((chunk, index) => { var _a; return `${chunk}${(_a = separators[index]) !== null && _a !== void 0 ? _a : \"\"}`; }).join(\"\");\n    }\n    extractValueOrCache(token, headerTokens, dataTokens, config, allowUseCache, getValue) {\n        if (token.cache !== undefined && allowUseCache) {\n            return token.cache;\n        }\n        if (!getValue) {\n            throw new Error(\"getValue not provided.\");\n        }\n        const value = getValue(token, headerTokens, dataTokens, config);\n        if (config.cacheable) {\n            token.cache = value;\n        }\n        return value;\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport Reducer from \"../reducer/Reducer\";\nimport { StreamDataView } from \"stream-data-view\";\nimport TokenEncoder from \"./TokenEncoder\";\nimport FFlateEncoder from \"./FFlateEncoder\";\nimport { version } from '../../package.json';\nimport Tokenizer from \"../tokenizer/Tokenizer\";\nimport ExtractableData from \"../expander/Extractor\";\nvar EncoderEnum;\n(function (EncoderEnum) {\n    EncoderEnum[EncoderEnum[\"NONE\"] = 0] = \"NONE\";\n    EncoderEnum[EncoderEnum[\"FFLATE\"] = 1] = \"FFLATE\";\n})(EncoderEnum || (EncoderEnum = {}));\n;\nconst ENCODERS = [\n    () => undefined,\n    () => new FFlateEncoder(),\n];\nexport default class Compressor {\n    applyEncoders(buffer, encoders) {\n        let resultBuffer = buffer;\n        encoders.forEach(encoder => {\n            resultBuffer = encoder.encode(resultBuffer);\n        });\n        return resultBuffer;\n    }\n    applyDecoders(buffer, decoders) {\n        let resultBuffer = buffer;\n        decoders.forEach(decoder => {\n            resultBuffer = decoder.decode(resultBuffer);\n        });\n        return resultBuffer;\n    }\n    /**\n     * Load json or text files and compress them into one big blob.\n     * This uses the default encoders.\n     *\n     * @param files files to load.\n     */\n    loadAndCompress(files) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const tokenizer = new Tokenizer();\n            const header = yield tokenizer.load(...files);\n            const reducer = new Reducer();\n            const dataStore = reducer.reduce(header);\n            return this.compressDataStore(dataStore);\n        });\n    }\n    /**\n     * Compress data into one big blob.\n     * This uses the default encoders.\n     *\n     * @param files files to load.\n     */\n    compress(data) {\n        const tokenizer = new Tokenizer();\n        const header = tokenizer.tokenize(data);\n        const reducer = new Reducer();\n        const dataStore = reducer.reduce(header);\n        return this.compressDataStore(dataStore);\n    }\n    loadAndExpand(file) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield fetch(file);\n            const arrayBuffer = yield response.arrayBuffer();\n            return this.expand(arrayBuffer);\n        });\n    }\n    expand(arrayBuffer, config) {\n        return new ExtractableData(this.expandDataStore(arrayBuffer), config);\n    }\n    compressDataStore(dataStore, encoderEnums = [EncoderEnum.FFLATE]) {\n        const streamDataView = new StreamDataView();\n        const tokenEncoder = new TokenEncoder(streamDataView);\n        //  Write header tokens\n        tokenEncoder.encodeTokens(dataStore.headerTokens);\n        //  Write fileNames\n        tokenEncoder.encodeNumberArray(dataStore.files);\n        const finalStream = new StreamDataView();\n        finalStream.setNextUint8(version.length);\n        finalStream.setNextString(version);\n        encoderEnums.forEach(encoderEnum => finalStream.setNextUint8(encoderEnum));\n        finalStream.setNextUint8(0);\n        const encoders = encoderEnums\n            .map(encoderEnum => ENCODERS[encoderEnum]())\n            .filter((encoder) => !!encoder);\n        //  Write header\n        const headerBuffer = this.applyEncoders(streamDataView.getBuffer(), encoders);\n        finalStream.setNextUint32(headerBuffer.byteLength);\n        finalStream.setNextBytes(headerBuffer);\n        //  Write each file's data tokens.\n        for (let index = 0; index < dataStore.files.length; index++) {\n            const subStream = new StreamDataView();\n            const subEncoder = new TokenEncoder(subStream);\n            subEncoder.encodeTokens(dataStore.getDataTokens(index));\n            //  save and compress buffer\n            const subBuffer = this.applyEncoders(subStream.getBuffer(), encoders);\n            finalStream.setNextUint32(subBuffer.byteLength);\n            finalStream.setNextBytes(subBuffer);\n        }\n        finalStream.setNextUint32(0);\n        return finalStream.getBuffer();\n    }\n    expandDataStore(arrayBuffer) {\n        let input = arrayBuffer;\n        const globalStream = new StreamDataView(input);\n        const compressedVersion = globalStream.getNextString(globalStream.getNextUint8());\n        if (compressedVersion != version) {\n            console.warn(`Compressor is v.%s but the data was compressed with v.%s`, version, compressedVersion);\n        }\n        const decoders = [];\n        do {\n            const encoderEnum = globalStream.getNextUint8();\n            if (encoderEnum === EncoderEnum.NONE) {\n                break;\n            }\n            const decoder = ENCODERS[encoderEnum]();\n            if (decoder) {\n                decoders.push(decoder);\n            }\n        } while (globalStream.getOffset() < globalStream.getLength());\n        console.log(decoders);\n        const headerByteLength = globalStream.getNextUint32();\n        console.log(headerByteLength);\n        const headerBuffer = this.applyDecoders(globalStream.getNextBytes(headerByteLength).buffer, decoders);\n        const headerTokenEncoder = new TokenEncoder(new StreamDataView(headerBuffer));\n        const headerTokens = headerTokenEncoder.decodeTokens();\n        const files = headerTokenEncoder.decodeNumberArray();\n        const subBuffers = [];\n        do {\n            const byteLength = globalStream.getNextUint32();\n            if (!byteLength) {\n                break;\n            }\n            subBuffers.push(globalStream.getNextBytes(byteLength));\n        } while (globalStream.getOffset() < globalStream.getLength());\n        const getDataTokens = (index) => {\n            const subBuffer = this.applyDecoders(subBuffers[index], decoders);\n            const streamDataView = new StreamDataView(subBuffer);\n            const tokenDecoder = new TokenEncoder(streamDataView);\n            return tokenDecoder.decodeTokens();\n        };\n        return {\n            headerTokens,\n            files,\n            getDataTokens,\n        };\n    }\n}\n","import Loader from \"./io/Loader\";\nimport TokenEncoder from \"./compression/TokenEncoder\";\nimport Compressor from \"./compression/Compressor\";\nconst exportedClasses = {\n    Loader,\n    Compressor,\n    TokenEncoder,\n};\nexport default exportedClasses;\nglobalThis.exports = exportedClasses;\n"],"names":["$","safeAdd","x","y","lsw","md5cmn","q","a","b","s","t","num","cnt","md5ff","c","d","md5gg","md5hh","md5ii","binlMD5","len","i","olda","oldb","oldc","oldd","length","binl2rstr","input","output","length32","String","fromCharCode","rstr2binl","undefined","length8","charCodeAt","rstr2hex","hexTab","charAt","str2rstrUTF8","unescape","encodeURIComponent","rawMD5","rstrMD5","rawHMACMD5","k","key","data","hash","bkey","ipad","opad","concat","rstrHMACMD5","md5","string","raw","module","exports","e","n","o","Object","defineProperty","enumerable","get","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","StreamDataView","this","encoding","decode","apply","Array","from","decodeURIComponent","escape","encode","Uint8Array","split","map","offset","autoResize","ArrayBuffer","view","DataView","littleEndian","fromByteString","fromTextString","setNextString","resize","TypeError","byteLength","slice","set","buffer","getBuffer","crop","getOffset","skip","resetOffset","setOffset","getInt8","getUint8","getNextInt8","getNextUint8","getInt16","getUint16","getNextInt16","getNextUint16","getInt32","getUint32","getNextInt32","getNextUint32","getFloat32","getFloat64","getNextFloat32","getNextFloat64","setInt8","handleAutoResize","setUint8","setNextInt8","setNextUint8","setInt16","setUint16","setNextInt16","setNextUint16","setInt32","setUint32","setNextInt32","setNextUint32","setFloat32","setFloat64","setNextFloat32","setNextFloat64","getBytes","getNextBytes","setBytes","isArray","setNextBytes","getString","indexOf","getNextString","setString","toByteString","toString","join","toUpperCase","toTextString","parseInt","getLength","clear","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","getter","__esModule","definition","obj","prop","Loader","load","file","thisArg","_arguments","generator","response","fetch","pop","extension","json","text","P","Promise","resolve","reject","fulfilled","step","next","rejected","result","done","then","DataType","Tag","NUMBER_DATA_TYPES","UINT8","INT8","UINT16","INT16","UINT32","INT32","FLOAT32","FLOAT64","TokenEncoder","constructor","streamDataView","encodeTokens","tokens","pos","count","encodeMulti","encodeToken","encodeTag","DONE","decodeTokens","tagOrDataType","decodeTagOrDataType","MULTI","decodeMulti","token","decodeToken","push","dataType","usedDataType","encodeDataType","getDataType","UNDEFINED","NULL","BOOLEAN_TRUE","BOOLEAN_FALSE","EMPTY_ARRAY","encodeSingleNumber","STRING","UNICODE","encodeString","OBJECT_8","OBJECT_16","OBJECT_32","encodeObjectToken","SPLIT_8","SPLIT_16","SPLIT_32","encodeSplitToken","ARRAY_8","ARRAY_16","ARRAY_32","OFFSET_ARRAY_8","OFFSET_ARRAY_16","OFFSET_ARRAY_32","encodeArrayToken","Error","decodeDataType","type","decodeSingleNumber","decodeString","decodeObjectToken","decodeSplitToken","decodeArrayToken","isOffsetDataType","arrayToken","numberType","indices","Math","min","encodeNumberArray","decodeNumberArray","objectToken","keysIndex","valuesIndex","splitToken","chunksIndex","separatorsIndex","tag","decodeTag","firstType","multiCount","maxCount","getNumberDataType","numberSatisfyDataType","fround","getBestType","array","some","number","every","max","size","bestType","numbers","getStringDataType","l","code","console","assert","dataTypeToType","letterCodes","forEach","charCodes","static","tokenEncoder","tokenDecoder","reset","testAction","fill","_","index","tester","log","check","JSON","stringify","decoded","Reducer","debug","reduce","header","hashToIndex","headerTokens","createReducedTokens","values","registry","filter","files","has","fileEntries","entries","sort","name1","name2","localeCompare","nameToken","dataTokens","root","subHashToIndex","assign","getDataTokens","sortedTokens","t1","t2","_a","_b","reference","u8","u16","Uint16Array","u32","Uint32Array","fleb","fdeb","clim","freb","eb","start","j","fl","revfl","fd","revfd","rev","hMap","cd","mb","co","le","rvb","sv","r_1","v","m","flt","fdt","flm","flrm","fdm","fdrm","bits","p","bits16","shft","slc","BYTES_PER_ELEMENT","subarray","ec","err","ind","msg","nt","captureStackTrace","wbits","wbits16","hTree","f","et","i0","i1","i2","maxSym","tr","mbt","ln","dt","lft","cst","i2_1","i2_2","i2_3","lc","cl","cli","cln","cls","w","clen","cf","wfblk","out","dat","wblk","final","syms","lf","df","li","bs","bl","dlt","mlb","ddt","mdb","_c","lclt","nlc","_d","lcdt","ndc","lcfreq","_e","lct","mlcb","nlcc","lm","ll","dm","dl","flen","ftlen","dtlen","llm","lcts","it","clct","dst","deo","crct","Int32Array","dopt","opt","pre","post","st","lvl","plvl","lst","ceil","msk_1","prev","head","bs1_1","bs2_1","hsh","lc_1","wi","hv","imod","pimod","rem","ch_1","dif","maxn","maxd","ml","nl","mmd","md","ti","lin","din","dflt","level","mem","wbytes","gzipSync","opts","cr","crc","filename","fn","mtime","floor","Date","now","gzh","gunzipSync","buf","sl","noBuf","noSt","cbuf","nbuf","bt","lbt","dbt","tbts","hLit","hcLen","tl","ldt","clt","clb","clbmsk","clm","lt","lms","dms","lpos","sym","add","dsym","end","inflt","flg","zs","gzs","td","TextDecoder","stream","queueMicrotask","setTimeout","FFlateEncoder","arrayBuffer","SPLIT_REGEX","TEST_REGEX","getType","test","Tokenizer","loader","sortedFiles","allData","all","tokenize","fromEntries","items","counter","tokenizeHelper","registerToken","entry","order","Set","item","hashes","keysToken","valuesToken","chunks","separators","match","chunksToken","separatorsToken","DEFAULT_CONFIG","cacheable","allowReferences","ExtractableData","dataStore","config","extractor","Extractor","fileNames","extractFileNames","fileToSlot","extract","slot","valueFetcher","getArray","bind","getObject","getSplit","extractToken","forceAllowUseCache","extractValueOrCache","keyIndex","valueIndex","keys","chunk","allowUseCache","getValue","cache","EncoderEnum","ENCODERS","exportedClasses","Compressor","applyEncoders","encoders","resultBuffer","encoder","applyDecoders","decoders","decoder","loadAndCompress","tokenizer","compressDataStore","compress","loadAndExpand","expand","expandDataStore","encoderEnums","FFLATE","finalStream","encoderEnum","headerBuffer","subStream","subBuffer","globalStream","compressedVersion","warn","NONE","headerByteLength","headerTokenEncoder","subBuffers","globalThis"],"sourceRoot":""}