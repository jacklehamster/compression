{"version":3,"file":"main.js","mappings":"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","sources":["webpack://@dobuki/compression/./node_modules/charenc/charenc.js","webpack://@dobuki/compression/./node_modules/crypt/crypt.js","webpack://@dobuki/compression/./node_modules/is-buffer/index.js","webpack://@dobuki/compression/./node_modules/md5/md5.js","webpack://@dobuki/compression/./node_modules/stream-data-view/dist/index.js","webpack://@dobuki/compression/webpack/bootstrap","webpack://@dobuki/compression/./src/io/Loader.ts","webpack://@dobuki/compression/./src/compression/TokenEncoder.ts","webpack://@dobuki/compression/./src/reducer/Reducer.ts","webpack://@dobuki/compression/./node_modules/fflate/esm/browser.js","webpack://@dobuki/compression/./src/compression/FFlateEncoder.ts","webpack://@dobuki/compression/./src/tokenizer/Token.ts","webpack://@dobuki/compression/./src/tokenizer/Tokenizer.ts","webpack://@dobuki/compression/./src/expander/Extractor.ts","webpack://@dobuki/compression/./src/compression/Compressor.ts","webpack://@dobuki/compression/./src/index.ts"],"sourcesContent":["var charenc = {\n  // UTF-8 encoding\n  utf8: {\n    // Convert a string to a byte array\n    stringToBytes: function(str) {\n      return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));\n    },\n\n    // Convert a byte array to a string\n    bytesToString: function(bytes) {\n      return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));\n    }\n  },\n\n  // Binary encoding\n  bin: {\n    // Convert a string to a byte array\n    stringToBytes: function(str) {\n      for (var bytes = [], i = 0; i < str.length; i++)\n        bytes.push(str.charCodeAt(i) & 0xFF);\n      return bytes;\n    },\n\n    // Convert a byte array to a string\n    bytesToString: function(bytes) {\n      for (var str = [], i = 0; i < bytes.length; i++)\n        str.push(String.fromCharCode(bytes[i]));\n      return str.join('');\n    }\n  }\n};\n\nmodule.exports = charenc;\n","(function() {\n  var base64map\n      = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n\n  crypt = {\n    // Bit-wise rotation left\n    rotl: function(n, b) {\n      return (n << b) | (n >>> (32 - b));\n    },\n\n    // Bit-wise rotation right\n    rotr: function(n, b) {\n      return (n << (32 - b)) | (n >>> b);\n    },\n\n    // Swap big-endian to little-endian and vice versa\n    endian: function(n) {\n      // If number given, swap endian\n      if (n.constructor == Number) {\n        return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;\n      }\n\n      // Else, assume array and swap all items\n      for (var i = 0; i < n.length; i++)\n        n[i] = crypt.endian(n[i]);\n      return n;\n    },\n\n    // Generate an array of any length of random bytes\n    randomBytes: function(n) {\n      for (var bytes = []; n > 0; n--)\n        bytes.push(Math.floor(Math.random() * 256));\n      return bytes;\n    },\n\n    // Convert a byte array to big-endian 32-bit words\n    bytesToWords: function(bytes) {\n      for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)\n        words[b >>> 5] |= bytes[i] << (24 - b % 32);\n      return words;\n    },\n\n    // Convert big-endian 32-bit words to a byte array\n    wordsToBytes: function(words) {\n      for (var bytes = [], b = 0; b < words.length * 32; b += 8)\n        bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);\n      return bytes;\n    },\n\n    // Convert a byte array to a hex string\n    bytesToHex: function(bytes) {\n      for (var hex = [], i = 0; i < bytes.length; i++) {\n        hex.push((bytes[i] >>> 4).toString(16));\n        hex.push((bytes[i] & 0xF).toString(16));\n      }\n      return hex.join('');\n    },\n\n    // Convert a hex string to a byte array\n    hexToBytes: function(hex) {\n      for (var bytes = [], c = 0; c < hex.length; c += 2)\n        bytes.push(parseInt(hex.substr(c, 2), 16));\n      return bytes;\n    },\n\n    // Convert a byte array to a base-64 string\n    bytesToBase64: function(bytes) {\n      for (var base64 = [], i = 0; i < bytes.length; i += 3) {\n        var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];\n        for (var j = 0; j < 4; j++)\n          if (i * 8 + j * 6 <= bytes.length * 8)\n            base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));\n          else\n            base64.push('=');\n      }\n      return base64.join('');\n    },\n\n    // Convert a base-64 string to a byte array\n    base64ToBytes: function(base64) {\n      // Remove non-base-64 characters\n      base64 = base64.replace(/[^A-Z0-9+\\/]/ig, '');\n\n      for (var bytes = [], i = 0, imod4 = 0; i < base64.length;\n          imod4 = ++i % 4) {\n        if (imod4 == 0) continue;\n        bytes.push(((base64map.indexOf(base64.charAt(i - 1))\n            & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2))\n            | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));\n      }\n      return bytes;\n    }\n  };\n\n  module.exports = crypt;\n})();\n","/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n","(function(){\r\n  var crypt = require('crypt'),\r\n      utf8 = require('charenc').utf8,\r\n      isBuffer = require('is-buffer'),\r\n      bin = require('charenc').bin,\r\n\r\n  // The core\r\n  md5 = function (message, options) {\r\n    // Convert to byte array\r\n    if (message.constructor == String)\r\n      if (options && options.encoding === 'binary')\r\n        message = bin.stringToBytes(message);\r\n      else\r\n        message = utf8.stringToBytes(message);\r\n    else if (isBuffer(message))\r\n      message = Array.prototype.slice.call(message, 0);\r\n    else if (!Array.isArray(message) && message.constructor !== Uint8Array)\r\n      message = message.toString();\r\n    // else, assume byte array already\r\n\r\n    var m = crypt.bytesToWords(message),\r\n        l = message.length * 8,\r\n        a =  1732584193,\r\n        b = -271733879,\r\n        c = -1732584194,\r\n        d =  271733878;\r\n\r\n    // Swap endian\r\n    for (var i = 0; i < m.length; i++) {\r\n      m[i] = ((m[i] <<  8) | (m[i] >>> 24)) & 0x00FF00FF |\r\n             ((m[i] << 24) | (m[i] >>>  8)) & 0xFF00FF00;\r\n    }\r\n\r\n    // Padding\r\n    m[l >>> 5] |= 0x80 << (l % 32);\r\n    m[(((l + 64) >>> 9) << 4) + 14] = l;\r\n\r\n    // Method shortcuts\r\n    var FF = md5._ff,\r\n        GG = md5._gg,\r\n        HH = md5._hh,\r\n        II = md5._ii;\r\n\r\n    for (var i = 0; i < m.length; i += 16) {\r\n\r\n      var aa = a,\r\n          bb = b,\r\n          cc = c,\r\n          dd = d;\r\n\r\n      a = FF(a, b, c, d, m[i+ 0],  7, -680876936);\r\n      d = FF(d, a, b, c, m[i+ 1], 12, -389564586);\r\n      c = FF(c, d, a, b, m[i+ 2], 17,  606105819);\r\n      b = FF(b, c, d, a, m[i+ 3], 22, -1044525330);\r\n      a = FF(a, b, c, d, m[i+ 4],  7, -176418897);\r\n      d = FF(d, a, b, c, m[i+ 5], 12,  1200080426);\r\n      c = FF(c, d, a, b, m[i+ 6], 17, -1473231341);\r\n      b = FF(b, c, d, a, m[i+ 7], 22, -45705983);\r\n      a = FF(a, b, c, d, m[i+ 8],  7,  1770035416);\r\n      d = FF(d, a, b, c, m[i+ 9], 12, -1958414417);\r\n      c = FF(c, d, a, b, m[i+10], 17, -42063);\r\n      b = FF(b, c, d, a, m[i+11], 22, -1990404162);\r\n      a = FF(a, b, c, d, m[i+12],  7,  1804603682);\r\n      d = FF(d, a, b, c, m[i+13], 12, -40341101);\r\n      c = FF(c, d, a, b, m[i+14], 17, -1502002290);\r\n      b = FF(b, c, d, a, m[i+15], 22,  1236535329);\r\n\r\n      a = GG(a, b, c, d, m[i+ 1],  5, -165796510);\r\n      d = GG(d, a, b, c, m[i+ 6],  9, -1069501632);\r\n      c = GG(c, d, a, b, m[i+11], 14,  643717713);\r\n      b = GG(b, c, d, a, m[i+ 0], 20, -373897302);\r\n      a = GG(a, b, c, d, m[i+ 5],  5, -701558691);\r\n      d = GG(d, a, b, c, m[i+10],  9,  38016083);\r\n      c = GG(c, d, a, b, m[i+15], 14, -660478335);\r\n      b = GG(b, c, d, a, m[i+ 4], 20, -405537848);\r\n      a = GG(a, b, c, d, m[i+ 9],  5,  568446438);\r\n      d = GG(d, a, b, c, m[i+14],  9, -1019803690);\r\n      c = GG(c, d, a, b, m[i+ 3], 14, -187363961);\r\n      b = GG(b, c, d, a, m[i+ 8], 20,  1163531501);\r\n      a = GG(a, b, c, d, m[i+13],  5, -1444681467);\r\n      d = GG(d, a, b, c, m[i+ 2],  9, -51403784);\r\n      c = GG(c, d, a, b, m[i+ 7], 14,  1735328473);\r\n      b = GG(b, c, d, a, m[i+12], 20, -1926607734);\r\n\r\n      a = HH(a, b, c, d, m[i+ 5],  4, -378558);\r\n      d = HH(d, a, b, c, m[i+ 8], 11, -2022574463);\r\n      c = HH(c, d, a, b, m[i+11], 16,  1839030562);\r\n      b = HH(b, c, d, a, m[i+14], 23, -35309556);\r\n      a = HH(a, b, c, d, m[i+ 1],  4, -1530992060);\r\n      d = HH(d, a, b, c, m[i+ 4], 11,  1272893353);\r\n      c = HH(c, d, a, b, m[i+ 7], 16, -155497632);\r\n      b = HH(b, c, d, a, m[i+10], 23, -1094730640);\r\n      a = HH(a, b, c, d, m[i+13],  4,  681279174);\r\n      d = HH(d, a, b, c, m[i+ 0], 11, -358537222);\r\n      c = HH(c, d, a, b, m[i+ 3], 16, -722521979);\r\n      b = HH(b, c, d, a, m[i+ 6], 23,  76029189);\r\n      a = HH(a, b, c, d, m[i+ 9],  4, -640364487);\r\n      d = HH(d, a, b, c, m[i+12], 11, -421815835);\r\n      c = HH(c, d, a, b, m[i+15], 16,  530742520);\r\n      b = HH(b, c, d, a, m[i+ 2], 23, -995338651);\r\n\r\n      a = II(a, b, c, d, m[i+ 0],  6, -198630844);\r\n      d = II(d, a, b, c, m[i+ 7], 10,  1126891415);\r\n      c = II(c, d, a, b, m[i+14], 15, -1416354905);\r\n      b = II(b, c, d, a, m[i+ 5], 21, -57434055);\r\n      a = II(a, b, c, d, m[i+12],  6,  1700485571);\r\n      d = II(d, a, b, c, m[i+ 3], 10, -1894986606);\r\n      c = II(c, d, a, b, m[i+10], 15, -1051523);\r\n      b = II(b, c, d, a, m[i+ 1], 21, -2054922799);\r\n      a = II(a, b, c, d, m[i+ 8],  6,  1873313359);\r\n      d = II(d, a, b, c, m[i+15], 10, -30611744);\r\n      c = II(c, d, a, b, m[i+ 6], 15, -1560198380);\r\n      b = II(b, c, d, a, m[i+13], 21,  1309151649);\r\n      a = II(a, b, c, d, m[i+ 4],  6, -145523070);\r\n      d = II(d, a, b, c, m[i+11], 10, -1120210379);\r\n      c = II(c, d, a, b, m[i+ 2], 15,  718787259);\r\n      b = II(b, c, d, a, m[i+ 9], 21, -343485551);\r\n\r\n      a = (a + aa) >>> 0;\r\n      b = (b + bb) >>> 0;\r\n      c = (c + cc) >>> 0;\r\n      d = (d + dd) >>> 0;\r\n    }\r\n\r\n    return crypt.endian([a, b, c, d]);\r\n  };\r\n\r\n  // Auxiliary functions\r\n  md5._ff  = function (a, b, c, d, x, s, t) {\r\n    var n = a + (b & c | ~b & d) + (x >>> 0) + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n  };\r\n  md5._gg  = function (a, b, c, d, x, s, t) {\r\n    var n = a + (b & d | c & ~d) + (x >>> 0) + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n  };\r\n  md5._hh  = function (a, b, c, d, x, s, t) {\r\n    var n = a + (b ^ c ^ d) + (x >>> 0) + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n  };\r\n  md5._ii  = function (a, b, c, d, x, s, t) {\r\n    var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n  };\r\n\r\n  // Package private blocksize\r\n  md5._blocksize = 16;\r\n  md5._digestsize = 16;\r\n\r\n  module.exports = function (message, options) {\r\n    if (message === undefined || message === null)\r\n      throw new Error('Illegal argument ' + message);\r\n\r\n    var digestbytes = crypt.wordsToBytes(md5(message, options));\r\n    return options && options.asBytes ? digestbytes :\r\n        options && options.asString ? bin.bytesToString(digestbytes) :\r\n        crypt.bytesToHex(digestbytes);\r\n  };\r\n\r\n})();\r\n","!function(t,e){if(\"object\"==typeof exports&&\"object\"==typeof module)module.exports=e();else if(\"function\"==typeof define&&define.amd)define([],e);else{var n=e();for(var i in n)(\"object\"==typeof exports?exports:t)[i]=n[i]}}(this,(function(){return(()=>{\"use strict\";var t={d:(e,n)=>{for(var i in n)t.o(n,i)&&!t.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:n[i]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(t,\"__esModule\",{value:!0})}},e={};t.r(e),t.d(e,{StreamDataView:()=>o});var n=function(){function t(t){this.encoding=t||\"utf-8\"}return t.prototype.decode=function(t){var e=String.fromCharCode.apply(null,Array.from(t));return\"utf-8\"===this.encoding?decodeURIComponent(escape(e)):e},t}(),i=function(){function t(t){this.encoding=t||\"utf-8\"}return t.prototype.encode=function(t){return\"utf-8\"===this.encoding&&(t=unescape(encodeURIComponent(t))),new Uint8Array(t.split(\"\").map((function(t){return t.charCodeAt(0)})))},t}(),o=function(){function t(t,e){this.offset=0,this.autoResize=!1,void 0===t&&(t=0,this.autoResize=!0),\"number\"==typeof t&&(t=new ArrayBuffer(t)),this.view=new DataView(t),this.littleEndian=!e}return t.fromByteString=function(e){var n=new t(e.split(\" \").length);return n.fromByteString(e),n},t.fromTextString=function(e,n){var o,s=new t((o=n?new i(\"utf-8\").encode(e):new i(\"ascii\").encode(e)).length);return s.setNextString(e,n,o.length),s},t.prototype.resize=function(t){var e=function(t,e){if(!(t instanceof ArrayBuffer))throw new TypeError(\"Source must be an instance of ArrayBuffer\");if(e<=t.byteLength)return t.slice(0,e);var n=new Uint8Array(t),i=new Uint8Array(new ArrayBuffer(e));return i.set(n),i.buffer}(this.getBuffer(),t);this.view=new DataView(e)},t.prototype.crop=function(){this.resize(this.getOffset())},t.prototype.getBuffer=function(){return this.view.buffer},t.prototype.skip=function(t){this.offset+=t},t.prototype.resetOffset=function(){this.offset=0},t.prototype.getOffset=function(){return this.offset},t.prototype.setOffset=function(t){this.offset=t},t.prototype.getInt8=function(t){return this.view.getInt8(t)},t.prototype.getUint8=function(t){return this.view.getUint8(t)},t.prototype.getNextInt8=function(){var t=this.getInt8(this.offset);return this.offset+=1,t},t.prototype.getNextUint8=function(){var t=this.getUint8(this.offset);return this.offset+=1,t},t.prototype.getInt16=function(t){return this.view.getInt16(t,this.littleEndian)},t.prototype.getUint16=function(t){return this.view.getUint16(t,this.littleEndian)},t.prototype.getNextInt16=function(){var t=this.getInt16(this.offset);return this.offset+=2,t},t.prototype.getNextUint16=function(){var t=this.getUint16(this.offset);return this.offset+=2,t},t.prototype.getInt32=function(t){return this.view.getInt32(t,this.littleEndian)},t.prototype.getUint32=function(t){return this.view.getUint32(t,this.littleEndian)},t.prototype.getNextInt32=function(){var t=this.getInt32(this.offset);return this.offset+=4,t},t.prototype.getNextUint32=function(){var t=this.getUint32(this.offset);return this.offset+=4,t},t.prototype.getFloat32=function(t){return this.view.getFloat32(t,this.littleEndian)},t.prototype.getFloat64=function(t){return this.view.getFloat64(t,this.littleEndian)},t.prototype.getNextFloat32=function(){var t=this.getFloat32(this.offset);return this.offset+=4,t},t.prototype.getNextFloat64=function(){var t=this.getFloat64(this.offset);return this.offset+=8,t},t.prototype.setInt8=function(t,e){this.handleAutoResize(t,1),this.view.setInt8(t,e)},t.prototype.setUint8=function(t,e){this.handleAutoResize(t,1),this.view.setUint8(t,e)},t.prototype.setNextInt8=function(t){this.setInt8(this.offset,t),this.offset+=1},t.prototype.setNextUint8=function(t){this.setUint8(this.offset,t),this.offset+=1},t.prototype.setInt16=function(t,e){this.handleAutoResize(t,2),this.view.setInt16(t,e,this.littleEndian)},t.prototype.setUint16=function(t,e){this.handleAutoResize(t,2),this.view.setUint16(t,e,this.littleEndian)},t.prototype.setNextInt16=function(t){this.setInt16(this.offset,t),this.offset+=2},t.prototype.setNextUint16=function(t){this.setUint16(this.offset,t),this.offset+=2},t.prototype.setInt32=function(t,e){this.handleAutoResize(t,4),this.view.setInt32(t,e,this.littleEndian)},t.prototype.setUint32=function(t,e){this.handleAutoResize(t,4),this.view.setUint32(t,e,this.littleEndian)},t.prototype.setNextInt32=function(t){this.setInt32(this.offset,t),this.offset+=4},t.prototype.setNextUint32=function(t){this.setUint32(this.offset,t),this.offset+=4},t.prototype.setFloat32=function(t,e){this.handleAutoResize(t,8),this.view.setFloat32(t,e,this.littleEndian)},t.prototype.setFloat64=function(t,e){this.handleAutoResize(t,8),this.view.setFloat64(t,e,this.littleEndian)},t.prototype.setNextFloat32=function(t){this.setFloat32(this.offset,t),this.offset+=4},t.prototype.setNextFloat64=function(t){this.setFloat64(this.offset,t),this.offset+=8},t.prototype.getBytes=function(t,e){void 0===t&&(t=0),e=e||this.view.buffer.byteLength-t;var n=this.getBuffer().slice(t,t+e);return new Uint8Array(n)},t.prototype.getNextBytes=function(t){var e=this.getBytes(this.offset,t);return this.offset+=t||0,e},t.prototype.setBytes=function(t,e){(e instanceof ArrayBuffer||Array.isArray(e))&&(e=new Uint8Array(e));var n=e;this.handleAutoResize(t,n.byteLength);for(var i=0;i<n.byteLength;i++)this.setUint8(t+i,n[i])},t.prototype.setNextBytes=function(t){Array.isArray(t)&&(t=new Uint8Array(t)),this.setBytes(this.offset,t),this.offset+=t.byteLength},t.prototype.getString=function(t,e,i,o){var s=this.getBytes(t,e);if(o){var r=s.indexOf(0);r>=0&&(s=s.slice(0,r))}return i?new n(\"utf-8\").decode(s):new n(\"ascii\").decode(s)},t.prototype.getNextString=function(t,e,n){var i=this.getString(this.offset,t,e,n);return this.offset+=t,i},t.prototype.setString=function(t,e,n,o){var s;s=n?new i(\"utf-8\").encode(e):new i(\"ascii\").encode(e),o=\"number\"==typeof o?o:s.byteLength,this.handleAutoResize(t,o);for(var r=0;r<o;r++)this.view.setUint8(t+r,s[r]||0);return o},t.prototype.setNextString=function(t,e,n){this.offset+=this.setString(this.offset,t,e,n)},t.prototype.toByteString=function(){return Array.from(new Uint8Array(this.getBuffer())).map((function(t){return(\"00\"+t.toString(16)).slice(-2)})).join(\" \").toUpperCase()},t.prototype.toTextString=function(t){return this.getString(0,this.view.byteLength,t)},t.prototype.fromByteString=function(t){var e=t.split(\" \"),n=new ArrayBuffer(e.length);this.view=new DataView(n),this.setNextBytes(new Uint8Array(e.map((function(t){return parseInt(t,16)})))),this.resetOffset()},t.prototype.getLength=function(){return this.view.byteLength},t.prototype.clear=function(){this.view=new DataView(new ArrayBuffer(this.view.byteLength)),this.offset=0},t.prototype.handleAutoResize=function(t,e){this.autoResize&&this.getBuffer().byteLength<t+e&&this.resize(t+e)},t}();return e})()}));","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nfunction extension(file) {\n    return file.split(\".\").pop();\n}\nexport default class Loader {\n    load(file) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield fetch(file);\n            return extension(file) === \"json\" ? yield response.json() : yield response.text();\n        });\n    }\n}\n","import { StreamDataView } from \"stream-data-view\";\nvar DataType;\n(function (DataType) {\n    DataType[DataType[\"UNDEFINED\"] = 0] = \"UNDEFINED\";\n    DataType[DataType[\"NULL\"] = 1] = \"NULL\";\n    DataType[DataType[\"BOOLEAN_FALSE\"] = 2] = \"BOOLEAN_FALSE\";\n    DataType[DataType[\"BOOLEAN_TRUE\"] = 3] = \"BOOLEAN_TRUE\";\n    DataType[DataType[\"INT8\"] = 4] = \"INT8\";\n    DataType[DataType[\"UINT8\"] = 5] = \"UINT8\";\n    DataType[DataType[\"INT16\"] = 6] = \"INT16\";\n    DataType[DataType[\"UINT16\"] = 7] = \"UINT16\";\n    DataType[DataType[\"INT32\"] = 8] = \"INT32\";\n    DataType[DataType[\"UINT32\"] = 9] = \"UINT32\";\n    DataType[DataType[\"FLOAT32\"] = 10] = \"FLOAT32\";\n    DataType[DataType[\"FLOAT64\"] = 11] = \"FLOAT64\";\n    DataType[DataType[\"STRING\"] = 12] = \"STRING\";\n    DataType[DataType[\"UNICODE\"] = 13] = \"UNICODE\";\n    DataType[DataType[\"OBJECT_8\"] = 17] = \"OBJECT_8\";\n    DataType[DataType[\"OBJECT_16\"] = 18] = \"OBJECT_16\";\n    DataType[DataType[\"OBJECT_32\"] = 19] = \"OBJECT_32\";\n    DataType[DataType[\"SPLIT_8\"] = 20] = \"SPLIT_8\";\n    DataType[DataType[\"SPLIT_16\"] = 21] = \"SPLIT_16\";\n    DataType[DataType[\"SPLIT_32\"] = 22] = \"SPLIT_32\";\n    DataType[DataType[\"ARRAY_8\"] = 23] = \"ARRAY_8\";\n    DataType[DataType[\"ARRAY_16\"] = 24] = \"ARRAY_16\";\n    DataType[DataType[\"ARRAY_32\"] = 25] = \"ARRAY_32\";\n    DataType[DataType[\"OFFSET_ARRAY_8\"] = 26] = \"OFFSET_ARRAY_8\";\n    DataType[DataType[\"OFFSET_ARRAY_16\"] = 27] = \"OFFSET_ARRAY_16\";\n    DataType[DataType[\"OFFSET_ARRAY_32\"] = 28] = \"OFFSET_ARRAY_32\";\n})(DataType || (DataType = {}));\nvar Tag;\n(function (Tag) {\n    Tag[Tag[\"DONE\"] = 100] = \"DONE\";\n    Tag[Tag[\"MULTI\"] = 101] = \"MULTI\";\n})(Tag || (Tag = {}));\n;\nconst NUMBER_DATA_TYPES = [\n    DataType.UINT8,\n    DataType.INT8,\n    DataType.UINT16,\n    DataType.INT16,\n    DataType.UINT32,\n    DataType.INT32,\n    DataType.FLOAT32,\n    DataType.FLOAT64,\n];\nexport default class TokenEncoder {\n    constructor(streamDataView) {\n        this.streamDataView = streamDataView;\n    }\n    encodeTokens(tokens) {\n        let pos = 0;\n        while (pos < tokens.length) {\n            const count = this.encodeMulti(tokens, pos);\n            if (count) {\n                pos += count;\n            }\n            else {\n                this.encodeToken(tokens[pos]);\n                pos++;\n            }\n        }\n        this.encodeTag(Tag.DONE);\n    }\n    decodeTokens() {\n        const tokens = [];\n        while (this.streamDataView.getOffset() < this.streamDataView.getLength()) {\n            const tagOrDataType = this.decodeTagOrDataType();\n            if (tagOrDataType === Tag.DONE) {\n                break;\n            }\n            if (tagOrDataType === Tag.MULTI) {\n                this.decodeMulti(tagOrDataType, tokens);\n            }\n            else {\n                tokens.push(this.decodeToken(tagOrDataType));\n            }\n        }\n        return tokens;\n    }\n    encodeToken(token, dataType) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.encodeDataType(this.getDataType(token));\n        switch (usedDataType) {\n            case DataType.UNDEFINED:\n            case DataType.NULL:\n            case DataType.BOOLEAN_TRUE:\n            case DataType.BOOLEAN_FALSE:\n                break;\n            case DataType.INT8:\n            case DataType.UINT8:\n            case DataType.INT16:\n            case DataType.UINT16:\n            case DataType.INT32:\n            case DataType.UINT32:\n            case DataType.FLOAT32:\n            case DataType.FLOAT64:\n                this.encodeSingleNumber(token.value, usedDataType);\n                break;\n            case DataType.STRING:\n            case DataType.UNICODE:\n                this.encodeString(token.value, usedDataType);\n                break;\n            case DataType.OBJECT_8:\n            case DataType.OBJECT_16:\n            case DataType.OBJECT_32:\n                this.encodeObjectToken(token, usedDataType);\n                break;\n            case DataType.SPLIT_8:\n            case DataType.SPLIT_16:\n            case DataType.SPLIT_32:\n                this.encodeSplitToken(token, usedDataType);\n                break;\n            case DataType.ARRAY_8:\n            case DataType.ARRAY_16:\n            case DataType.ARRAY_32:\n            case DataType.OFFSET_ARRAY_8:\n            case DataType.OFFSET_ARRAY_16:\n            case DataType.OFFSET_ARRAY_32:\n                this.encodeArrayToken(token, usedDataType);\n                break;\n            default:\n                throw new Error(\"Invalid dataType: \" + usedDataType);\n        }\n    }\n    decodeToken(dataType) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.decodeDataType();\n        switch (usedDataType) {\n            case DataType.UNDEFINED:\n                return { type: \"leaf\", value: undefined };\n            case DataType.NULL:\n                return { type: \"leaf\", value: null };\n            case DataType.BOOLEAN_TRUE:\n                return { type: \"leaf\", value: true };\n            case DataType.BOOLEAN_FALSE:\n                return { type: \"leaf\", value: false };\n            case DataType.INT8:\n            case DataType.UINT8:\n            case DataType.INT16:\n            case DataType.UINT16:\n            case DataType.INT32:\n            case DataType.UINT32:\n            case DataType.FLOAT32:\n            case DataType.FLOAT64:\n                return { type: \"leaf\", value: this.decodeSingleNumber(usedDataType) };\n            case DataType.STRING:\n            case DataType.UNICODE:\n                return { type: \"leaf\", value: this.decodeString(usedDataType) };\n            case DataType.OBJECT_8:\n            case DataType.OBJECT_16:\n            case DataType.OBJECT_32:\n                return this.decodeObjectToken(usedDataType);\n            case DataType.SPLIT_8:\n            case DataType.SPLIT_16:\n            case DataType.SPLIT_32:\n                return this.decodeSplitToken(usedDataType);\n            case DataType.ARRAY_8:\n            case DataType.ARRAY_16:\n            case DataType.ARRAY_32:\n            case DataType.OFFSET_ARRAY_8:\n            case DataType.OFFSET_ARRAY_16:\n            case DataType.OFFSET_ARRAY_32:\n                return this.decodeArrayToken(usedDataType);\n            default:\n                throw new Error(\"Invalid dataType: \" + usedDataType);\n        }\n    }\n    isOffsetDataType(dataType) {\n        return dataType === DataType.OFFSET_ARRAY_8 || dataType === DataType.OFFSET_ARRAY_16 || dataType === DataType.OFFSET_ARRAY_32;\n    }\n    encodeArrayToken(arrayToken, dataType) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.encodeDataType(this.getDataType(arrayToken));\n        const numberType = usedDataType === DataType.ARRAY_8 || usedDataType === DataType.OFFSET_ARRAY_8\n            ? DataType.UINT8\n            : usedDataType === DataType.ARRAY_16 || usedDataType === DataType.OFFSET_ARRAY_16\n                ? DataType.UINT16 : DataType.UINT32;\n        let indices = arrayToken.value;\n        if (this.isOffsetDataType(usedDataType)) {\n            const offset = Math.min(...indices);\n            indices = indices.map((value) => value - offset);\n            this.encodeSingleNumber(offset);\n        }\n        this.encodeNumberArray(indices, numberType);\n    }\n    decodeArrayToken(dataType) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.decodeDataType();\n        let offset = 0;\n        if (this.isOffsetDataType(usedDataType)) {\n            offset = this.decodeSingleNumber();\n        }\n        const numberType = usedDataType === DataType.ARRAY_8 || usedDataType === DataType.OFFSET_ARRAY_8\n            ? DataType.UINT8\n            : usedDataType === DataType.ARRAY_16 || usedDataType === DataType.OFFSET_ARRAY_16\n                ? DataType.UINT16 : DataType.UINT32;\n        const indices = this.decodeNumberArray(numberType)\n            .map(value => value + offset);\n        return {\n            type: \"array\",\n            value: indices,\n        };\n    }\n    encodeObjectToken(objectToken, dataType) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.encodeDataType(this.getDataType(objectToken));\n        const numberType = usedDataType === DataType.OBJECT_8 ? DataType.UINT8 : usedDataType === DataType.OBJECT_16 ? DataType.UINT16 : DataType.UINT32;\n        const [keysIndex, valuesIndex] = objectToken.value;\n        this.encodeSingleNumber(keysIndex, numberType);\n        this.encodeSingleNumber(valuesIndex, numberType);\n    }\n    decodeObjectToken(dataType) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.decodeDataType();\n        const numberType = usedDataType === DataType.OBJECT_8 ? DataType.UINT8 : usedDataType === DataType.OBJECT_16 ? DataType.UINT16 : DataType.UINT32;\n        return {\n            type: \"object\",\n            value: [this.decodeSingleNumber(numberType), this.decodeSingleNumber(numberType)],\n        };\n    }\n    encodeSplitToken(splitToken, dataType) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.encodeDataType(this.getDataType(splitToken));\n        const numberType = usedDataType === DataType.SPLIT_8 ? DataType.UINT8 : usedDataType === DataType.SPLIT_16 ? DataType.UINT16 : DataType.UINT32;\n        const [chunksIndex, separatorsIndex] = splitToken.value;\n        this.encodeSingleNumber(chunksIndex, numberType);\n        this.encodeSingleNumber(separatorsIndex, numberType);\n    }\n    decodeSplitToken(dataType) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.decodeDataType();\n        const numberType = usedDataType === DataType.SPLIT_8 ? DataType.UINT8 : usedDataType === DataType.SPLIT_16 ? DataType.UINT16 : DataType.UINT32;\n        return {\n            type: \"split\",\n            value: [this.decodeSingleNumber(numberType), this.decodeSingleNumber(numberType)],\n        };\n    }\n    encodeTag(tag) {\n        this.streamDataView.setNextUint8(tag);\n    }\n    decodeTag() {\n        return this.streamDataView.getNextUint8();\n    }\n    decodeTagOrDataType() {\n        return this.streamDataView.getNextUint8();\n    }\n    encodeDataType(dataType) {\n        this.streamDataView.setNextUint8(dataType);\n        return dataType;\n    }\n    decodeDataType() {\n        return this.streamDataView.getNextUint8();\n    }\n    encodeMulti(tokens, pos) {\n        const firstType = this.getDataType(tokens[pos]);\n        let multiCount;\n        const maxCount = Math.min(tokens.length - pos, 256);\n        for (multiCount = 1; multiCount < maxCount; multiCount++) {\n            if (this.getDataType(tokens[pos + multiCount]) !== firstType) {\n                break;\n            }\n        }\n        if (multiCount > 2) {\n            //  encode a multi, meaning that the same type is going to get repeated multiple times\n            this.encodeTag(Tag.MULTI);\n            this.encodeSingleNumber(multiCount % 256, DataType.UINT8);\n            this.encodeDataType(firstType);\n            for (let i = 0; i < multiCount; i++) {\n                this.encodeToken(tokens[pos + i], firstType);\n            }\n            return multiCount;\n        }\n        return 0;\n    }\n    decodeMulti(tag, tokens) {\n        if (tag === Tag.MULTI) {\n            const count = this.streamDataView.getNextUint8() || 256;\n            const dataType = this.decodeDataType();\n            for (let i = 0; i < count; i++) {\n                tokens.push(this.decodeToken(dataType));\n            }\n            return count;\n        }\n        return 0;\n    }\n    encodeSingleNumber(value, dataType) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.encodeDataType(this.getNumberDataType(value));\n        switch (usedDataType) {\n            case DataType.UINT8:\n                this.streamDataView.setNextUint8(value);\n                break;\n            case DataType.INT8:\n                this.streamDataView.setNextInt8(value);\n                break;\n            case DataType.UINT16:\n                this.streamDataView.setNextUint16(value);\n                break;\n            case DataType.INT16:\n                this.streamDataView.setNextInt16(value);\n                break;\n            case DataType.UINT32:\n                this.streamDataView.setNextUint32(value);\n                break;\n            case DataType.INT32:\n                this.streamDataView.setNextInt32(value);\n                break;\n            case DataType.FLOAT32:\n                this.streamDataView.setNextFloat32(value);\n                break;\n            case DataType.FLOAT64:\n                this.streamDataView.setNextFloat64(value);\n                break;\n            default:\n                throw new Error(\"Invalid dataType for number: \" + usedDataType);\n        }\n    }\n    decodeSingleNumber(dataType) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.decodeDataType();\n        switch (usedDataType) {\n            case DataType.UINT8:\n                return this.streamDataView.getNextUint8();\n            case DataType.INT8:\n                return this.streamDataView.getNextInt8();\n            case DataType.UINT16:\n                return this.streamDataView.getNextUint16();\n            case DataType.INT16:\n                return this.streamDataView.getNextInt16();\n            case DataType.UINT32:\n                return this.streamDataView.getNextUint32();\n            case DataType.INT32:\n                return this.streamDataView.getNextInt32();\n            case DataType.FLOAT32:\n                return this.streamDataView.getNextFloat32();\n            case DataType.FLOAT64:\n                return this.streamDataView.getNextFloat64();\n            default:\n                throw new Error(\"Invalid dataType for number: \" + usedDataType);\n        }\n    }\n    numberSatisfyDataType(value, dataType) {\n        const hasDecimal = value % 1 !== 0;\n        if (hasDecimal) {\n            switch (dataType) {\n                case DataType.FLOAT32:\n                    return Math.fround(value) === value;\n                case DataType.FLOAT64:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n        switch (dataType) {\n            case DataType.UINT8:\n                return value >= 0 && value <= 255;\n            case DataType.INT8:\n                return value >= -128 && value <= 127;\n            case DataType.UINT16:\n                return value >= 0 && value <= 65535;\n            case DataType.INT16:\n                return value >= -32768 && value <= 32767;\n            case DataType.UINT32:\n                return value >= 0;\n            case DataType.INT32:\n                return true;\n        }\n        return false;\n    }\n    getBestType(array) {\n        if (array.some(number => number % 1 !== 0)) {\n            //  decimal\n            if (array.every(number => this.numberSatisfyDataType(number, DataType.FLOAT32))) {\n                return DataType.FLOAT32;\n            }\n            return DataType.FLOAT64;\n        }\n        const min = Math.min(...array);\n        const max = Math.max(...array);\n        for (let dataType of NUMBER_DATA_TYPES) {\n            if (this.numberSatisfyDataType(min, dataType) && this.numberSatisfyDataType(max, dataType)) {\n                return dataType;\n            }\n        }\n        return DataType.FLOAT64;\n    }\n    encodeNumberArray(array, dataType) {\n        let pos;\n        for (pos = 0; pos < array.length;) {\n            const size = Math.min(255, array.length - pos);\n            this.encodeSingleNumber(size, DataType.UINT8);\n            if (!size) {\n                break;\n            }\n            const bestType = dataType !== null && dataType !== void 0 ? dataType : this.encodeDataType(this.getBestType(array));\n            for (let i = 0; i < size; i++) {\n                this.encodeSingleNumber(array[pos + i], bestType);\n            }\n            pos += size;\n        }\n    }\n    decodeNumberArray(dataType) {\n        let size;\n        const numbers = [];\n        do {\n            size = this.decodeSingleNumber(DataType.UINT8);\n            if (!size) {\n                break;\n            }\n            const type = dataType !== null && dataType !== void 0 ? dataType : this.decodeDataType();\n            for (let i = 0; i < size; i++) {\n                numbers.push(this.decodeSingleNumber(type));\n            }\n        } while (size >= 255);\n        return numbers;\n    }\n    getNumberDataType(value) {\n        for (let type of NUMBER_DATA_TYPES) {\n            if (this.numberSatisfyDataType(value, type)) {\n                return type;\n            }\n        }\n        return DataType.UNDEFINED;\n    }\n    getStringDataType(value) {\n        const letterCodes = value.split(\"\").map(l => l.charCodeAt(0));\n        if (letterCodes.every(code => code <= 255)) {\n            return DataType.STRING;\n        }\n        else {\n            return DataType.UNICODE;\n        }\n    }\n    getDataType(token) {\n        switch (token.type) {\n            case \"array\":\n            case \"object\":\n            case \"split\":\n                let indices = token.value;\n                let offset = 0;\n                if (token.type === \"array\" && indices.length > 3) {\n                    const min = Math.min(...indices);\n                    const max = Math.max(...indices);\n                    if (this.getNumberDataType(max - min) !== this.getNumberDataType(max)) {\n                        offset = min;\n                    }\n                    indices = indices.map(value => value - offset);\n                }\n                const bestType = this.getBestType(indices);\n                switch (token.type) {\n                    case \"object\":\n                        return bestType === DataType.UINT8\n                            ? DataType.OBJECT_8\n                            : bestType === DataType.UINT16\n                                ? DataType.OBJECT_16\n                                : DataType.OBJECT_32;\n                    case \"split\":\n                        return bestType === DataType.UINT8\n                            ? DataType.SPLIT_8\n                            : bestType === DataType.UINT16\n                                ? DataType.SPLIT_16\n                                : DataType.SPLIT_32;\n                    case \"array\":\n                        if (offset) {\n                            return bestType === DataType.UINT8\n                                ? DataType.OFFSET_ARRAY_8\n                                : bestType === DataType.UINT16\n                                    ? DataType.OFFSET_ARRAY_16\n                                    : DataType.OFFSET_ARRAY_32;\n                        }\n                        else {\n                            return bestType === DataType.UINT8\n                                ? DataType.ARRAY_8\n                                : bestType === DataType.UINT16\n                                    ? DataType.ARRAY_16\n                                    : DataType.ARRAY_32;\n                        }\n                }\n            case \"leaf\":\n                if (token.value === undefined) {\n                    return DataType.UNDEFINED;\n                }\n                else if (token.value === null) {\n                    return DataType.NULL;\n                }\n                else {\n                    switch (typeof token.value) {\n                        case \"boolean\":\n                            return token.value ? DataType.BOOLEAN_TRUE : DataType.BOOLEAN_FALSE;\n                        case \"string\":\n                            return this.getStringDataType(token.value);\n                        case \"number\":\n                            return this.getNumberDataType(token.value);\n                    }\n                }\n        }\n        throw new Error(`Unrecognized type for ${token.type} value: ${token.value}`);\n    }\n    dataTypeToType(dataType) {\n        switch (dataType) {\n            case DataType.ARRAY_8:\n            case DataType.ARRAY_16:\n            case DataType.ARRAY_32:\n                return \"array\";\n            case DataType.OBJECT_8:\n            case DataType.OBJECT_16:\n            case DataType.OBJECT_32:\n                return \"object\";\n            case DataType.SPLIT_8:\n            case DataType.SPLIT_16:\n            case DataType.SPLIT_32:\n                return \"split\";\n            default:\n                return \"leaf\";\n        }\n    }\n    encodeString(value, dataType) {\n        const letterCodes = value.split(\"\").map(l => l.charCodeAt(0));\n        letterCodes.push(0);\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.encodeDataType(this.getStringDataType(value));\n        const numberType = usedDataType === DataType.STRING ? DataType.UINT8 : DataType.UINT16;\n        letterCodes.forEach(code => this.encodeSingleNumber(code, numberType));\n    }\n    decodeString(dataType) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.decodeDataType();\n        const charCodes = [];\n        const numberType = usedDataType === DataType.STRING ? DataType.UINT8 : DataType.UINT16;\n        do {\n            const code = this.decodeSingleNumber(numberType);\n            if (!code) {\n                break;\n            }\n            charCodes.push(code);\n        } while (true);\n        return charCodes.map(code => String.fromCharCode(code)).join(\"\");\n    }\n    static selfTest() {\n        const testers = [\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction(DataType.STRING, dataType => tokenEncoder.encodeDataType(dataType), reset, () => tokenDecoder.decodeDataType());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction(DataType.UNDEFINED, dataType => tokenEncoder.encodeDataType(dataType), reset, () => tokenDecoder.decodeDataType());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction(33, number => tokenEncoder.encodeSingleNumber(number, DataType.INT8), reset, () => tokenDecoder.decodeSingleNumber(DataType.INT8));\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction([\n                    { type: \"leaf\", value: 123 },\n                    { type: \"leaf\", value: 45 },\n                    { type: \"leaf\", value: 67 },\n                    { type: \"leaf\", value: 89 },\n                ], header => tokenEncoder.encodeMulti(header, 0), reset, () => {\n                    const result = [];\n                    tokenDecoder.decodeMulti(tokenDecoder.decodeTag(), result);\n                    return result;\n                });\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction([\n                    { type: \"leaf\", value: 1000001 },\n                    { type: \"leaf\", value: 1002000 },\n                    { type: \"leaf\", value: 1003001 },\n                ], header => tokenEncoder.encodeMulti(header, 0), reset, () => {\n                    const result = [];\n                    tokenDecoder.decodeMulti(tokenDecoder.decodeTag(), result);\n                    return result;\n                });\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction([1, 2, 3, 4, 10, 20, 200], array => tokenEncoder.encodeNumberArray(array), reset, () => tokenDecoder.decodeNumberArray());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction([10000, -202, 3, 4, 10, 20, 3200], array => tokenEncoder.encodeNumberArray(array), reset, () => tokenDecoder.decodeNumberArray());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction(\"test-string\", string => tokenEncoder.encodeString(string), reset, () => tokenDecoder.decodeString());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction(\"test-string\", string => tokenEncoder.encodeString(string, DataType.STRING), reset, () => tokenDecoder.decodeString(DataType.STRING));\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction(\"test-😀😃😄😁😆\", string => tokenEncoder.encodeString(string), reset, () => tokenDecoder.decodeString());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"object\", value: [200, 201] }, o => tokenEncoder.encodeObjectToken(o), reset, () => tokenDecoder.decodeObjectToken());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"object\", value: [2000, 2001] }, o => tokenEncoder.encodeObjectToken(o), reset, () => tokenDecoder.decodeObjectToken());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"object\", value: [2000, 2001] }, o => tokenEncoder.encodeObjectToken(o, DataType.OBJECT_32), reset, () => tokenDecoder.decodeObjectToken(DataType.OBJECT_32));\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"split\", value: [200, 201] }, o => tokenEncoder.encodeSplitToken(o), reset, () => tokenDecoder.decodeSplitToken());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"split\", value: [2000, 2001] }, o => tokenEncoder.encodeSplitToken(o), reset, () => tokenDecoder.decodeSplitToken());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"split\", value: [2000, 2001] }, o => tokenEncoder.encodeSplitToken(o, DataType.SPLIT_32), reset, () => tokenDecoder.decodeSplitToken(DataType.SPLIT_32));\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"leaf\", value: \"token-string\" }, o => tokenEncoder.encodeToken(o), reset, () => tokenDecoder.decodeToken());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"leaf\", value: 123.5 }, o => tokenEncoder.encodeToken(o), reset, () => tokenDecoder.decodeToken());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"leaf\", value: \"😁😆\" }, o => tokenEncoder.encodeToken(o), reset, () => tokenDecoder.decodeToken());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"array\", value: [1, 10, 20, 30, 200] }, o => tokenEncoder.encodeToken(o), reset, () => tokenDecoder.decodeToken());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"array\", value: [1001, 1010, 1020, 1030, 1200] }, o => tokenEncoder.encodeToken(o), reset, () => tokenDecoder.decodeToken());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"array\", value: [10010, 10100, 10300, 20000] }, o => tokenEncoder.encodeToken(o), reset, () => tokenDecoder.decodeToken());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"array\", value: [10010, 10100, 10000] }, o => tokenEncoder.encodeToken(o), reset, () => tokenDecoder.decodeToken());\n            },\n        ];\n        testers.forEach(tester => {\n            const streamDataView = new StreamDataView();\n            const encoder = new TokenEncoder(streamDataView);\n            const decoder = new TokenEncoder(streamDataView);\n            const reset = () => streamDataView.resetOffset();\n            tester(encoder, decoder, reset);\n        });\n    }\n    static testAction(value, encode, reset, decode, check = (result, value) => console.assert(JSON.stringify(result) === JSON.stringify(value), `Not equal: \\n%s\\n!==\\n%s`, JSON.stringify(result), JSON.stringify(value))) {\n        encode(value);\n        reset();\n        const decoded = decode();\n        reset();\n        check(decoded, value);\n    }\n}\n","/**\n * Reduce header from using large tokens to reduce tokens.\n */\nexport default class Reducer {\n    constructor(debug) {\n        this.debug = debug !== null && debug !== void 0 ? debug : false;\n    }\n    /**\n     * Reduce header with smaller tokens for storage\n     *\n     * @param header Represents all data that we have.\n     * @returns DataStorage object that's the minimum we can store.\n     */\n    reduce(header) {\n        const hashToIndex = {};\n        //  start with header tokens\n        const headerTokens = this.createReducedTokens(Object.values(header.registry)\n            .filter(token => token.files.size > 1 || token.files.has(\"header\")), hashToIndex);\n        //  save files\n        const fileEntries = Object.entries(header.files).sort(([name1], [name2]) => name1.localeCompare(name2));\n        const files = fileEntries.map(([, token]) => hashToIndex[token.nameToken.hash]);\n        //  save all files separately\n        const dataTokens = fileEntries.map(([file, { token: root }]) => {\n            const subHashToIndex = Object.assign({}, hashToIndex);\n            const tokens = Object.values(header.registry).filter(token => token.files.has(file) && token !== root);\n            return this.createReducedTokens(tokens, subHashToIndex, headerTokens.length).concat(this.createReducedTokens([root], subHashToIndex, headerTokens.length));\n        });\n        return {\n            headerTokens,\n            files,\n            getDataTokens(index) {\n                return dataTokens[index];\n            },\n        };\n    }\n    createReducedTokens(tokens, hashToIndex, offset = 0) {\n        const sortedTokens = tokens.sort((t1, t2) => t2.count - t1.count);\n        sortedTokens.forEach(({ hash }, index) => {\n            hashToIndex[hash] = index + offset;\n        });\n        return sortedTokens.map(token => {\n            var _a, _b;\n            return (Object.assign({ type: token.type, value: (_b = (_a = token.reference) === null || _a === void 0 ? void 0 : _a.map(hash => hashToIndex[hash])) !== null && _b !== void 0 ? _b : token.value }, this.debug ? { debug: token.value } : {}));\n        });\n    }\n}\n","// DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n// https://tools.ietf.org/html/rfc1951\n// You may also wish to take a look at the guide I made about this program:\n// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad\n// Some of the following code is similar to that of UZIP.js:\n// https://github.com/photopea/UZIP.js\n// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.\n// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint\n// is better for memory in most engines (I *think*).\nvar ch2 = {};\nvar wk = (function (c, id, msg, transfer, cb) {\n    var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([\n        c + ';addEventListener(\"error\",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'\n    ], { type: 'text/javascript' }))));\n    w.onmessage = function (e) {\n        var d = e.data, ed = d.$e$;\n        if (ed) {\n            var err = new Error(ed[0]);\n            err['code'] = ed[1];\n            err.stack = ed[2];\n            cb(err, null);\n        }\n        else\n            cb(null, d);\n    };\n    w.postMessage(msg, transfer);\n    return w;\n});\n\n// aliases for shorter compressed code (most minifers don't do this)\nvar u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;\n// fixed length extra bits\nvar fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);\n// fixed distance extra bits\n// see fleb note\nvar fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);\n// code length index map\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n// get base, reverse index map from extra bits\nvar freb = function (eb, start) {\n    var b = new u16(31);\n    for (var i = 0; i < 31; ++i) {\n        b[i] = start += 1 << eb[i - 1];\n    }\n    // numbers here are at max 18 bits\n    var r = new u32(b[30]);\n    for (var i = 1; i < 30; ++i) {\n        for (var j = b[i]; j < b[i + 1]; ++j) {\n            r[j] = ((j - b[i]) << 5) | i;\n        }\n    }\n    return [b, r];\n};\nvar _a = freb(fleb, 2), fl = _a[0], revfl = _a[1];\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = _b[0], revfd = _b[1];\n// map of value to reverse (assuming 16 bits)\nvar rev = new u16(32768);\nfor (var i = 0; i < 32768; ++i) {\n    // reverse table algorithm from SO\n    var x = ((i & 0xAAAA) >>> 1) | ((i & 0x5555) << 1);\n    x = ((x & 0xCCCC) >>> 2) | ((x & 0x3333) << 2);\n    x = ((x & 0xF0F0) >>> 4) | ((x & 0x0F0F) << 4);\n    rev[i] = (((x & 0xFF00) >>> 8) | ((x & 0x00FF) << 8)) >>> 1;\n}\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nvar hMap = (function (cd, mb, r) {\n    var s = cd.length;\n    // index\n    var i = 0;\n    // u16 \"map\": index -> # of codes with bit length = index\n    var l = new u16(mb);\n    // length of cd must be 288 (total # of codes)\n    for (; i < s; ++i) {\n        if (cd[i])\n            ++l[cd[i] - 1];\n    }\n    // u16 \"map\": index -> minimum code for bit length = index\n    var le = new u16(mb);\n    for (i = 0; i < mb; ++i) {\n        le[i] = (le[i - 1] + l[i - 1]) << 1;\n    }\n    var co;\n    if (r) {\n        // u16 \"map\": index -> number of actual bits, symbol for code\n        co = new u16(1 << mb);\n        // bits to remove for reverser\n        var rvb = 15 - mb;\n        for (i = 0; i < s; ++i) {\n            // ignore 0 lengths\n            if (cd[i]) {\n                // num encoding both symbol and bits read\n                var sv = (i << 4) | cd[i];\n                // free bits\n                var r_1 = mb - cd[i];\n                // start value\n                var v = le[cd[i] - 1]++ << r_1;\n                // m is end value\n                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {\n                    // every 16 bit value starting with the code yields the same result\n                    co[rev[v] >>> rvb] = sv;\n                }\n            }\n        }\n    }\n    else {\n        co = new u16(s);\n        for (i = 0; i < s; ++i) {\n            if (cd[i]) {\n                co[i] = rev[le[cd[i] - 1]++] >>> (15 - cd[i]);\n            }\n        }\n    }\n    return co;\n});\n// fixed length tree\nvar flt = new u8(288);\nfor (var i = 0; i < 144; ++i)\n    flt[i] = 8;\nfor (var i = 144; i < 256; ++i)\n    flt[i] = 9;\nfor (var i = 256; i < 280; ++i)\n    flt[i] = 7;\nfor (var i = 280; i < 288; ++i)\n    flt[i] = 8;\n// fixed distance tree\nvar fdt = new u8(32);\nfor (var i = 0; i < 32; ++i)\n    fdt[i] = 5;\n// fixed length map\nvar flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);\n// fixed distance map\nvar fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);\n// find max of array\nvar max = function (a) {\n    var m = a[0];\n    for (var i = 1; i < a.length; ++i) {\n        if (a[i] > m)\n            m = a[i];\n    }\n    return m;\n};\n// read d, starting at bit p and mask with m\nvar bits = function (d, p, m) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;\n};\n// read d, starting at bit p continuing for at least 16 bits\nvar bits16 = function (d, p) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));\n};\n// get end of byte\nvar shft = function (p) { return ((p + 7) / 8) | 0; };\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nvar slc = function (v, s, e) {\n    if (s == null || s < 0)\n        s = 0;\n    if (e == null || e > v.length)\n        e = v.length;\n    // can't use .constructor in case user-supplied\n    var n = new (v.BYTES_PER_ELEMENT == 2 ? u16 : v.BYTES_PER_ELEMENT == 4 ? u32 : u8)(e - s);\n    n.set(v.subarray(s, e));\n    return n;\n};\n/**\n * Codes for errors generated within this library\n */\nexport var FlateErrorCode = {\n    UnexpectedEOF: 0,\n    InvalidBlockType: 1,\n    InvalidLengthLiteral: 2,\n    InvalidDistance: 3,\n    StreamFinished: 4,\n    NoStreamHandler: 5,\n    InvalidHeader: 6,\n    NoCallback: 7,\n    InvalidUTF8: 8,\n    ExtraFieldTooLong: 9,\n    InvalidDate: 10,\n    FilenameTooLong: 11,\n    StreamFinishing: 12,\n    InvalidZipData: 13,\n    UnknownCompressionMethod: 14\n};\n// error codes\nvar ec = [\n    'unexpected EOF',\n    'invalid block type',\n    'invalid length/literal',\n    'invalid distance',\n    'stream finished',\n    'no stream handler',\n    ,\n    'no callback',\n    'invalid UTF-8 data',\n    'extra field too long',\n    'date not in range 1980-2099',\n    'filename too long',\n    'stream finishing',\n    'invalid zip data'\n    // determined by unknown compression method\n];\n;\nvar err = function (ind, msg, nt) {\n    var e = new Error(msg || ec[ind]);\n    e.code = ind;\n    if (Error.captureStackTrace)\n        Error.captureStackTrace(e, err);\n    if (!nt)\n        throw e;\n    return e;\n};\n// expands raw DEFLATE data\nvar inflt = function (dat, buf, st) {\n    // source length\n    var sl = dat.length;\n    if (!sl || (st && st.f && !st.l))\n        return buf || new u8(0);\n    // have to estimate size\n    var noBuf = !buf || st;\n    // no state\n    var noSt = !st || st.i;\n    if (!st)\n        st = {};\n    // Assumes roughly 33% compression ratio average\n    if (!buf)\n        buf = new u8(sl * 3);\n    // ensure buffer can fit at least l elements\n    var cbuf = function (l) {\n        var bl = buf.length;\n        // need to increase size to fit\n        if (l > bl) {\n            // Double or set to necessary, whichever is greater\n            var nbuf = new u8(Math.max(bl * 2, l));\n            nbuf.set(buf);\n            buf = nbuf;\n        }\n    };\n    //  last chunk         bitpos           bytes\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    // total bits\n    var tbts = sl * 8;\n    do {\n        if (!lm) {\n            // BFINAL - this is only 1 when last chunk is next\n            final = bits(dat, pos, 1);\n            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n            var type = bits(dat, pos + 1, 3);\n            pos += 3;\n            if (!type) {\n                // go to end of byte boundary\n                var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;\n                if (t > sl) {\n                    if (noSt)\n                        err(0);\n                    break;\n                }\n                // ensure size\n                if (noBuf)\n                    cbuf(bt + l);\n                // Copy over uncompressed data\n                buf.set(dat.subarray(s, t), bt);\n                // Get new bitpos, update byte count\n                st.b = bt += l, st.p = pos = t * 8, st.f = final;\n                continue;\n            }\n            else if (type == 1)\n                lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n            else if (type == 2) {\n                //  literal                            lengths\n                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n                var tl = hLit + bits(dat, pos + 5, 31) + 1;\n                pos += 14;\n                // length+distance tree\n                var ldt = new u8(tl);\n                // code length tree\n                var clt = new u8(19);\n                for (var i = 0; i < hcLen; ++i) {\n                    // use index map to get real code\n                    clt[clim[i]] = bits(dat, pos + i * 3, 7);\n                }\n                pos += hcLen * 3;\n                // code lengths bits\n                var clb = max(clt), clbmsk = (1 << clb) - 1;\n                // code lengths map\n                var clm = hMap(clt, clb, 1);\n                for (var i = 0; i < tl;) {\n                    var r = clm[bits(dat, pos, clbmsk)];\n                    // bits read\n                    pos += r & 15;\n                    // symbol\n                    var s = r >>> 4;\n                    // code length to copy\n                    if (s < 16) {\n                        ldt[i++] = s;\n                    }\n                    else {\n                        //  copy   count\n                        var c = 0, n = 0;\n                        if (s == 16)\n                            n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n                        else if (s == 17)\n                            n = 3 + bits(dat, pos, 7), pos += 3;\n                        else if (s == 18)\n                            n = 11 + bits(dat, pos, 127), pos += 7;\n                        while (n--)\n                            ldt[i++] = c;\n                    }\n                }\n                //    length tree                 distance tree\n                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n                // max length bits\n                lbt = max(lt);\n                // max dist bits\n                dbt = max(dt);\n                lm = hMap(lt, lbt, 1);\n                dm = hMap(dt, dbt, 1);\n            }\n            else\n                err(1);\n            if (pos > tbts) {\n                if (noSt)\n                    err(0);\n                break;\n            }\n        }\n        // Make sure the buffer can hold this + the largest possible addition\n        // Maximum chunk size (practically, theoretically infinite) is 2^17;\n        if (noBuf)\n            cbuf(bt + 131072);\n        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n        var lpos = pos;\n        for (;; lpos = pos) {\n            // bits read, code\n            var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;\n            pos += c & 15;\n            if (pos > tbts) {\n                if (noSt)\n                    err(0);\n                break;\n            }\n            if (!c)\n                err(2);\n            if (sym < 256)\n                buf[bt++] = sym;\n            else if (sym == 256) {\n                lpos = pos, lm = null;\n                break;\n            }\n            else {\n                var add = sym - 254;\n                // no extra bits needed if less\n                if (sym > 264) {\n                    // index\n                    var i = sym - 257, b = fleb[i];\n                    add = bits(dat, pos, (1 << b) - 1) + fl[i];\n                    pos += b;\n                }\n                // dist\n                var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;\n                if (!d)\n                    err(3);\n                pos += d & 15;\n                var dt = fd[dsym];\n                if (dsym > 3) {\n                    var b = fdeb[dsym];\n                    dt += bits16(dat, pos) & ((1 << b) - 1), pos += b;\n                }\n                if (pos > tbts) {\n                    if (noSt)\n                        err(0);\n                    break;\n                }\n                if (noBuf)\n                    cbuf(bt + 131072);\n                var end = bt + add;\n                for (; bt < end; bt += 4) {\n                    buf[bt] = buf[bt - dt];\n                    buf[bt + 1] = buf[bt + 1 - dt];\n                    buf[bt + 2] = buf[bt + 2 - dt];\n                    buf[bt + 3] = buf[bt + 3 - dt];\n                }\n                bt = end;\n            }\n        }\n        st.l = lm, st.p = lpos, st.b = bt, st.f = final;\n        if (lm)\n            final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    } while (!final);\n    return bt == buf.length ? buf : slc(buf, 0, bt);\n};\n// starting at p, write the minimum number of bits that can hold v to d\nvar wbits = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n};\n// starting at p, write the minimum number of bits (>8) that can hold v to d\nvar wbits16 = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n    d[o + 2] |= v >>> 16;\n};\n// creates code lengths from a frequency table\nvar hTree = function (d, mb) {\n    // Need extra info to make a tree\n    var t = [];\n    for (var i = 0; i < d.length; ++i) {\n        if (d[i])\n            t.push({ s: i, f: d[i] });\n    }\n    var s = t.length;\n    var t2 = t.slice();\n    if (!s)\n        return [et, 0];\n    if (s == 1) {\n        var v = new u8(t[0].s + 1);\n        v[t[0].s] = 1;\n        return [v, 1];\n    }\n    t.sort(function (a, b) { return a.f - b.f; });\n    // after i2 reaches last ind, will be stopped\n    // freq must be greater than largest possible number of symbols\n    t.push({ s: -1, f: 25001 });\n    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;\n    t[0] = { s: -1, f: l.f + r.f, l: l, r: r };\n    // efficient algorithm from UZIP.js\n    // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n    // symbols that combined have high freq, will start processing i2 (high-freq,\n    // non-composite) symbols instead\n    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n    while (i1 != s - 1) {\n        l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n        t[i1++] = { s: -1, f: l.f + r.f, l: l, r: r };\n    }\n    var maxSym = t2[0].s;\n    for (var i = 1; i < s; ++i) {\n        if (t2[i].s > maxSym)\n            maxSym = t2[i].s;\n    }\n    // code lengths\n    var tr = new u16(maxSym + 1);\n    // max bits in tree\n    var mbt = ln(t[i1 - 1], tr, 0);\n    if (mbt > mb) {\n        // more algorithms from UZIP.js\n        // TODO: find out how this code works (debt)\n        //  ind    debt\n        var i = 0, dt = 0;\n        //    left            cost\n        var lft = mbt - mb, cst = 1 << lft;\n        t2.sort(function (a, b) { return tr[b.s] - tr[a.s] || a.f - b.f; });\n        for (; i < s; ++i) {\n            var i2_1 = t2[i].s;\n            if (tr[i2_1] > mb) {\n                dt += cst - (1 << (mbt - tr[i2_1]));\n                tr[i2_1] = mb;\n            }\n            else\n                break;\n        }\n        dt >>>= lft;\n        while (dt > 0) {\n            var i2_2 = t2[i].s;\n            if (tr[i2_2] < mb)\n                dt -= 1 << (mb - tr[i2_2]++ - 1);\n            else\n                ++i;\n        }\n        for (; i >= 0 && dt; --i) {\n            var i2_3 = t2[i].s;\n            if (tr[i2_3] == mb) {\n                --tr[i2_3];\n                ++dt;\n            }\n        }\n        mbt = mb;\n    }\n    return [new u8(tr), mbt];\n};\n// get the max length and assign length codes\nvar ln = function (n, l, d) {\n    return n.s == -1\n        ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))\n        : (l[n.s] = d);\n};\n// length codes generation\nvar lc = function (c) {\n    var s = c.length;\n    // Note that the semicolon was intentional\n    while (s && !c[--s])\n        ;\n    var cl = new u16(++s);\n    //  ind      num         streak\n    var cli = 0, cln = c[0], cls = 1;\n    var w = function (v) { cl[cli++] = v; };\n    for (var i = 1; i <= s; ++i) {\n        if (c[i] == cln && i != s)\n            ++cls;\n        else {\n            if (!cln && cls > 2) {\n                for (; cls > 138; cls -= 138)\n                    w(32754);\n                if (cls > 2) {\n                    w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305);\n                    cls = 0;\n                }\n            }\n            else if (cls > 3) {\n                w(cln), --cls;\n                for (; cls > 6; cls -= 6)\n                    w(8304);\n                if (cls > 2)\n                    w(((cls - 3) << 5) | 8208), cls = 0;\n            }\n            while (cls--)\n                w(cln);\n            cls = 1;\n            cln = c[i];\n        }\n    }\n    return [cl.subarray(0, cli), s];\n};\n// calculate the length of output from tree, code lengths\nvar clen = function (cf, cl) {\n    var l = 0;\n    for (var i = 0; i < cl.length; ++i)\n        l += cf[i] * cl[i];\n    return l;\n};\n// writes a fixed block\n// returns the new bit pos\nvar wfblk = function (out, pos, dat) {\n    // no need to write 00 as type: TypedArray defaults to 0\n    var s = dat.length;\n    var o = shft(pos + 2);\n    out[o] = s & 255;\n    out[o + 1] = s >>> 8;\n    out[o + 2] = out[o] ^ 255;\n    out[o + 3] = out[o + 1] ^ 255;\n    for (var i = 0; i < s; ++i)\n        out[o + i + 4] = dat[i];\n    return (o + 4 + s) * 8;\n};\n// writes a block\nvar wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\n    wbits(out, p++, final);\n    ++lf[256];\n    var _a = hTree(lf, 15), dlt = _a[0], mlb = _a[1];\n    var _b = hTree(df, 15), ddt = _b[0], mdb = _b[1];\n    var _c = lc(dlt), lclt = _c[0], nlc = _c[1];\n    var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];\n    var lcfreq = new u16(19);\n    for (var i = 0; i < lclt.length; ++i)\n        lcfreq[lclt[i] & 31]++;\n    for (var i = 0; i < lcdt.length; ++i)\n        lcfreq[lcdt[i] & 31]++;\n    var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];\n    var nlcc = 19;\n    for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)\n        ;\n    var flen = (bl + 5) << 3;\n    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);\n    if (flen <= ftlen && flen <= dtlen)\n        return wfblk(out, p, dat.subarray(bs, bs + bl));\n    var lm, ll, dm, dl;\n    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;\n    if (dtlen < ftlen) {\n        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n        var llm = hMap(lct, mlcb, 0);\n        wbits(out, p, nlc - 257);\n        wbits(out, p + 5, ndc - 1);\n        wbits(out, p + 10, nlcc - 4);\n        p += 14;\n        for (var i = 0; i < nlcc; ++i)\n            wbits(out, p + 3 * i, lct[clim[i]]);\n        p += 3 * nlcc;\n        var lcts = [lclt, lcdt];\n        for (var it = 0; it < 2; ++it) {\n            var clct = lcts[it];\n            for (var i = 0; i < clct.length; ++i) {\n                var len = clct[i] & 31;\n                wbits(out, p, llm[len]), p += lct[len];\n                if (len > 15)\n                    wbits(out, p, (clct[i] >>> 5) & 127), p += clct[i] >>> 12;\n            }\n        }\n    }\n    else {\n        lm = flm, ll = flt, dm = fdm, dl = fdt;\n    }\n    for (var i = 0; i < li; ++i) {\n        if (syms[i] > 255) {\n            var len = (syms[i] >>> 18) & 31;\n            wbits16(out, p, lm[len + 257]), p += ll[len + 257];\n            if (len > 7)\n                wbits(out, p, (syms[i] >>> 23) & 31), p += fleb[len];\n            var dst = syms[i] & 31;\n            wbits16(out, p, dm[dst]), p += dl[dst];\n            if (dst > 3)\n                wbits16(out, p, (syms[i] >>> 5) & 8191), p += fdeb[dst];\n        }\n        else {\n            wbits16(out, p, lm[syms[i]]), p += ll[syms[i]];\n        }\n    }\n    wbits16(out, p, lm[256]);\n    return p + ll[256];\n};\n// deflate options (nice << 13) | chain\nvar deo = /*#__PURE__*/ new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);\n// empty\nvar et = /*#__PURE__*/ new u8(0);\n// compresses data into a raw DEFLATE buffer\nvar dflt = function (dat, lvl, plvl, pre, post, lst) {\n    var s = dat.length;\n    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);\n    // writing to this writes to the output buffer\n    var w = o.subarray(pre, o.length - post);\n    var pos = 0;\n    if (!lvl || s < 8) {\n        for (var i = 0; i <= s; i += 65535) {\n            // end\n            var e = i + 65535;\n            if (e >= s) {\n                // write final block\n                w[pos >> 3] = lst;\n            }\n            pos = wfblk(w, pos + 1, dat.subarray(i, e));\n        }\n    }\n    else {\n        var opt = deo[lvl - 1];\n        var n = opt >>> 13, c = opt & 8191;\n        var msk_1 = (1 << plvl) - 1;\n        //    prev 2-byte val map    curr 2-byte val map\n        var prev = new u16(32768), head = new u16(msk_1 + 1);\n        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;\n        var hsh = function (i) { return (dat[i] ^ (dat[i + 1] << bs1_1) ^ (dat[i + 2] << bs2_1)) & msk_1; };\n        // 24576 is an arbitrary number of maximum symbols per block\n        // 424 buffer for last block\n        var syms = new u32(25000);\n        // length/literal freq   distance freq\n        var lf = new u16(288), df = new u16(32);\n        //  l/lcnt  exbits  index  l/lind  waitdx  bitpos\n        var lc_1 = 0, eb = 0, i = 0, li = 0, wi = 0, bs = 0;\n        for (; i < s; ++i) {\n            // hash value\n            // deopt when i > s - 3 - at end, deopt acceptable\n            var hv = hsh(i);\n            // index mod 32768    previous index mod\n            var imod = i & 32767, pimod = head[hv];\n            prev[imod] = pimod;\n            head[hv] = imod;\n            // We always should modify head and prev, but only add symbols if\n            // this data is not yet processed (\"wait\" for wait index)\n            if (wi <= i) {\n                // bytes remaining\n                var rem = s - i;\n                if ((lc_1 > 7000 || li > 24576) && rem > 423) {\n                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n                    li = lc_1 = eb = 0, bs = i;\n                    for (var j = 0; j < 286; ++j)\n                        lf[j] = 0;\n                    for (var j = 0; j < 30; ++j)\n                        df[j] = 0;\n                }\n                //  len    dist   chain\n                var l = 2, d = 0, ch_1 = c, dif = (imod - pimod) & 32767;\n                if (rem > 2 && hv == hsh(i - dif)) {\n                    var maxn = Math.min(n, rem) - 1;\n                    var maxd = Math.min(32767, i);\n                    // max possible length\n                    // not capped at dif because decompressors implement \"rolling\" index population\n                    var ml = Math.min(258, rem);\n                    while (dif <= maxd && --ch_1 && imod != pimod) {\n                        if (dat[i + l] == dat[i + l - dif]) {\n                            var nl = 0;\n                            for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)\n                                ;\n                            if (nl > l) {\n                                l = nl, d = dif;\n                                // break out early when we reach \"nice\" (we are satisfied enough)\n                                if (nl > maxn)\n                                    break;\n                                // now, find the rarest 2-byte sequence within this\n                                // length of literals and search for that instead.\n                                // Much faster than just using the start\n                                var mmd = Math.min(dif, nl - 2);\n                                var md = 0;\n                                for (var j = 0; j < mmd; ++j) {\n                                    var ti = (i - dif + j + 32768) & 32767;\n                                    var pti = prev[ti];\n                                    var cd = (ti - pti + 32768) & 32767;\n                                    if (cd > md)\n                                        md = cd, pimod = ti;\n                                }\n                            }\n                        }\n                        // check the previous match\n                        imod = pimod, pimod = prev[imod];\n                        dif += (imod - pimod + 32768) & 32767;\n                    }\n                }\n                // d will be nonzero only when a match was found\n                if (d) {\n                    // store both dist and len data in one Uint32\n                    // Make sure this is recognized as a len/dist with 28th bit (2^28)\n                    syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d];\n                    var lin = revfl[l] & 31, din = revfd[d] & 31;\n                    eb += fleb[lin] + fdeb[din];\n                    ++lf[257 + lin];\n                    ++df[din];\n                    wi = i + l;\n                    ++lc_1;\n                }\n                else {\n                    syms[li++] = dat[i];\n                    ++lf[dat[i]];\n                }\n            }\n        }\n        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);\n        // this is the easiest way to avoid needing to maintain state\n        if (!lst && pos & 7)\n            pos = wfblk(w, pos + 1, et);\n    }\n    return slc(o, 0, pre + shft(pos) + post);\n};\n// CRC32 table\nvar crct = /*#__PURE__*/ (function () {\n    var t = new Int32Array(256);\n    for (var i = 0; i < 256; ++i) {\n        var c = i, k = 9;\n        while (--k)\n            c = ((c & 1) && -306674912) ^ (c >>> 1);\n        t[i] = c;\n    }\n    return t;\n})();\n// CRC32\nvar crc = function () {\n    var c = -1;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var cr = c;\n            for (var i = 0; i < d.length; ++i)\n                cr = crct[(cr & 255) ^ d[i]] ^ (cr >>> 8);\n            c = cr;\n        },\n        d: function () { return ~c; }\n    };\n};\n// Alder32\nvar adler = function () {\n    var a = 1, b = 0;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var n = a, m = b;\n            var l = d.length | 0;\n            for (var i = 0; i != l;) {\n                var e = Math.min(i + 2655, l);\n                for (; i < e; ++i)\n                    m += n += d[i];\n                n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);\n            }\n            a = n, b = m;\n        },\n        d: function () {\n            a %= 65521, b %= 65521;\n            return (a & 255) << 24 | (a >>> 8) << 16 | (b & 255) << 8 | (b >>> 8);\n        }\n    };\n};\n;\n// deflate with opts\nvar dopt = function (dat, opt, pre, post, st) {\n    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : (12 + opt.mem), pre, post, !st);\n};\n// Walmart object spread\nvar mrg = function (a, b) {\n    var o = {};\n    for (var k in a)\n        o[k] = a[k];\n    for (var k in b)\n        o[k] = b[k];\n    return o;\n};\n// worker clone\n// This is possibly the craziest part of the entire codebase, despite how simple it may seem.\n// The only parameter to this function is a closure that returns an array of variables outside of the function scope.\n// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.\n// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).\n// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.\n// This took me three weeks to figure out how to do.\nvar wcln = function (fn, fnStr, td) {\n    var dt = fn();\n    var st = fn.toString();\n    var ks = st.slice(st.indexOf('[') + 1, st.lastIndexOf(']')).replace(/\\s+/g, '').split(',');\n    for (var i = 0; i < dt.length; ++i) {\n        var v = dt[i], k = ks[i];\n        if (typeof v == 'function') {\n            fnStr += ';' + k + '=';\n            var st_1 = v.toString();\n            if (v.prototype) {\n                // for global objects\n                if (st_1.indexOf('[native code]') != -1) {\n                    var spInd = st_1.indexOf(' ', 8) + 1;\n                    fnStr += st_1.slice(spInd, st_1.indexOf('(', spInd));\n                }\n                else {\n                    fnStr += st_1;\n                    for (var t in v.prototype)\n                        fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[t].toString();\n                }\n            }\n            else\n                fnStr += st_1;\n        }\n        else\n            td[k] = v;\n    }\n    return [fnStr, td];\n};\nvar ch = [];\n// clone bufs\nvar cbfs = function (v) {\n    var tl = [];\n    for (var k in v) {\n        if (v[k].buffer) {\n            tl.push((v[k] = new v[k].constructor(v[k])).buffer);\n        }\n    }\n    return tl;\n};\n// use a worker to execute code\nvar wrkr = function (fns, init, id, cb) {\n    var _a;\n    if (!ch[id]) {\n        var fnStr = '', td_1 = {}, m = fns.length - 1;\n        for (var i = 0; i < m; ++i)\n            _a = wcln(fns[i], fnStr, td_1), fnStr = _a[0], td_1 = _a[1];\n        ch[id] = wcln(fns[m], fnStr, td_1);\n    }\n    var td = mrg({}, ch[id][1]);\n    return wk(ch[id][0] + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + init.toString() + '}', id, td, cbfs(td), cb);\n};\n// base async inflate fn\nvar bInflt = function () { return [u8, u16, u32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gu8]; };\nvar bDflt = function () { return [u8, u16, u32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf]; };\n// gzip extra\nvar gze = function () { return [gzh, gzhl, wbytes, crc, crct]; };\n// gunzip extra\nvar guze = function () { return [gzs, gzl]; };\n// zlib extra\nvar zle = function () { return [zlh, wbytes, adler]; };\n// unzlib extra\nvar zule = function () { return [zlv]; };\n// post buf\nvar pbf = function (msg) { return postMessage(msg, [msg.buffer]); };\n// get u8\nvar gu8 = function (o) { return o && o.size && new u8(o.size); };\n// async helper\nvar cbify = function (dat, opts, fns, init, id, cb) {\n    var w = wrkr(fns, init, id, function (err, dat) {\n        w.terminate();\n        cb(err, dat);\n    });\n    w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);\n    return function () { w.terminate(); };\n};\n// auto stream\nvar astrm = function (strm) {\n    strm.ondata = function (dat, final) { return postMessage([dat, final], [dat.buffer]); };\n    return function (ev) { return strm.push(ev.data[0], ev.data[1]); };\n};\n// async stream attach\nvar astrmify = function (fns, strm, opts, init, id) {\n    var t;\n    var w = wrkr(fns, init, id, function (err, dat) {\n        if (err)\n            w.terminate(), strm.ondata.call(strm, err);\n        else {\n            if (dat[1])\n                w.terminate();\n            strm.ondata.call(strm, err, dat[0], dat[1]);\n        }\n    });\n    w.postMessage(opts);\n    strm.push = function (d, f) {\n        if (!strm.ondata)\n            err(5);\n        if (t)\n            strm.ondata(err(4, 0, 1), null, !!f);\n        w.postMessage([d, t = f], [d.buffer]);\n    };\n    strm.terminate = function () { w.terminate(); };\n};\n// read 2 bytes\nvar b2 = function (d, b) { return d[b] | (d[b + 1] << 8); };\n// read 4 bytes\nvar b4 = function (d, b) { return (d[b] | (d[b + 1] << 8) | (d[b + 2] << 16) | (d[b + 3] << 24)) >>> 0; };\nvar b8 = function (d, b) { return b4(d, b) + (b4(d, b + 4) * 4294967296); };\n// write bytes\nvar wbytes = function (d, b, v) {\n    for (; v; ++b)\n        d[b] = v, v >>>= 8;\n};\n// gzip header\nvar gzh = function (c, o) {\n    var fn = o.filename;\n    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix\n    if (o.mtime != 0)\n        wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));\n    if (fn) {\n        c[3] = 8;\n        for (var i = 0; i <= fn.length; ++i)\n            c[i + 10] = fn.charCodeAt(i);\n    }\n};\n// gzip footer: -8 to -4 = CRC, -4 to -0 is length\n// gzip start\nvar gzs = function (d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n        err(6, 'invalid gzip data');\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4)\n        st += d[10] | (d[11] << 8) + 2;\n    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\n        ;\n    return st + (flg & 2);\n};\n// gzip length\nvar gzl = function (d) {\n    var l = d.length;\n    return ((d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16) | (d[l - 1] << 24)) >>> 0;\n};\n// gzip header length\nvar gzhl = function (o) { return 10 + ((o.filename && (o.filename.length + 1)) || 0); };\n// zlib header\nvar zlh = function (c, o) {\n    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\n    c[0] = 120, c[1] = (fl << 6) | (fl ? (32 - 2 * fl) : 1);\n};\n// zlib valid\nvar zlv = function (d) {\n    if ((d[0] & 15) != 8 || (d[0] >>> 4) > 7 || ((d[0] << 8 | d[1]) % 31))\n        err(6, 'invalid zlib data');\n    if (d[1] & 32)\n        err(6, 'invalid zlib data: preset dictionaries not supported');\n};\nfunction AsyncCmpStrm(opts, cb) {\n    if (!cb && typeof opts == 'function')\n        cb = opts, opts = {};\n    this.ondata = cb;\n    return opts;\n}\n// zlib footer: -4 to -0 is Adler32\n/**\n * Streaming DEFLATE compression\n */\nvar Deflate = /*#__PURE__*/ (function () {\n    function Deflate(opts, cb) {\n        if (!cb && typeof opts == 'function')\n            cb = opts, opts = {};\n        this.ondata = cb;\n        this.o = opts || {};\n    }\n    Deflate.prototype.p = function (c, f) {\n        this.ondata(dopt(c, this.o, 0, 0, !f), f);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Deflate.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        this.d = final;\n        this.p(chunk, final || false);\n    };\n    return Deflate;\n}());\nexport { Deflate };\n/**\n * Asynchronous streaming DEFLATE compression\n */\nvar AsyncDeflate = /*#__PURE__*/ (function () {\n    function AsyncDeflate(opts, cb) {\n        astrmify([\n            bDflt,\n            function () { return [astrm, Deflate]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Deflate(ev.data);\n            onmessage = astrm(strm);\n        }, 6);\n    }\n    return AsyncDeflate;\n}());\nexport { AsyncDeflate };\nexport function deflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n    ], function (ev) { return pbf(deflateSync(ev.data[0], ev.data[1])); }, 0, cb);\n}\n/**\n * Compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param opts The compression options\n * @returns The deflated version of the data\n */\nexport function deflateSync(data, opts) {\n    return dopt(data, opts || {}, 0, 0);\n}\n/**\n * Streaming DEFLATE decompression\n */\nvar Inflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an inflation stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Inflate(cb) {\n        this.s = {};\n        this.p = new u8(0);\n        this.ondata = cb;\n    }\n    Inflate.prototype.e = function (c) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        var l = this.p.length;\n        var n = new u8(l + c.length);\n        n.set(this.p), n.set(c, l), this.p = n;\n    };\n    Inflate.prototype.c = function (final) {\n        this.d = this.s.i = final || false;\n        var bts = this.s.b;\n        var dt = inflt(this.p, this.o, this.s);\n        this.ondata(slc(dt, bts, this.s.b), this.d);\n        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n        this.p = slc(this.p, (this.s.p / 8) | 0), this.s.p &= 7;\n    };\n    /**\n     * Pushes a chunk to be inflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the final chunk\n     */\n    Inflate.prototype.push = function (chunk, final) {\n        this.e(chunk), this.c(final);\n    };\n    return Inflate;\n}());\nexport { Inflate };\n/**\n * Asynchronous streaming DEFLATE decompression\n */\nvar AsyncInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous inflation stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncInflate(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            function () { return [astrm, Inflate]; }\n        ], this, 0, function () {\n            var strm = new Inflate();\n            onmessage = astrm(strm);\n        }, 7);\n    }\n    return AsyncInflate;\n}());\nexport { AsyncInflate };\nexport function inflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt\n    ], function (ev) { return pbf(inflateSync(ev.data[0], gu8(ev.data[1]))); }, 1, cb);\n}\n/**\n * Expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function inflateSync(data, out) {\n    return inflt(data, out);\n}\n// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.\n/**\n * Streaming GZIP compression\n */\nvar Gzip = /*#__PURE__*/ (function () {\n    function Gzip(opts, cb) {\n        this.c = crc();\n        this.l = 0;\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gzip.prototype.push = function (chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Gzip.prototype.p = function (c, f) {\n        this.c.p(c);\n        this.l += c.length;\n        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, !f);\n        if (this.v)\n            gzh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);\n        this.ondata(raw, f);\n    };\n    return Gzip;\n}());\nexport { Gzip };\n/**\n * Asynchronous streaming GZIP compression\n */\nvar AsyncGzip = /*#__PURE__*/ (function () {\n    function AsyncGzip(opts, cb) {\n        astrmify([\n            bDflt,\n            gze,\n            function () { return [astrm, Deflate, Gzip]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Gzip(ev.data);\n            onmessage = astrm(strm);\n        }, 8);\n    }\n    return AsyncGzip;\n}());\nexport { AsyncGzip };\nexport function gzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n        gze,\n        function () { return [gzipSync]; }\n    ], function (ev) { return pbf(gzipSync(ev.data[0], ev.data[1])); }, 2, cb);\n}\n/**\n * Compresses data with GZIP\n * @param data The data to compress\n * @param opts The compression options\n * @returns The gzipped version of the data\n */\nexport function gzipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var c = crc(), l = data.length;\n    c.p(data);\n    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;\n    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;\n}\n/**\n * Streaming GZIP decompression\n */\nvar Gunzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a GUNZIP stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Gunzip(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be GUNZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gunzip.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            var s = this.p.length > 3 ? gzs(this.p) : 4;\n            if (s >= this.p.length && !final)\n                return;\n            this.p = this.p.subarray(s), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 8)\n                err(6, 'invalid gzip data');\n            this.p = this.p.subarray(0, -8);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Gunzip;\n}());\nexport { Gunzip };\n/**\n * Asynchronous streaming GZIP decompression\n */\nvar AsyncGunzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous GUNZIP stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncGunzip(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            guze,\n            function () { return [astrm, Inflate, Gunzip]; }\n        ], this, 0, function () {\n            var strm = new Gunzip();\n            onmessage = astrm(strm);\n        }, 9);\n    }\n    return AsyncGunzip;\n}());\nexport { AsyncGunzip };\nexport function gunzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt,\n        guze,\n        function () { return [gunzipSync]; }\n    ], function (ev) { return pbf(gunzipSync(ev.data[0])); }, 3, cb);\n}\n/**\n * Expands GZIP data\n * @param data The data to decompress\n * @param out Where to write the data. GZIP already encodes the output size, so providing this doesn't save memory.\n * @returns The decompressed version of the data\n */\nexport function gunzipSync(data, out) {\n    return inflt(data.subarray(gzs(data), -8), out || new u8(gzl(data)));\n}\n/**\n * Streaming Zlib compression\n */\nvar Zlib = /*#__PURE__*/ (function () {\n    function Zlib(opts, cb) {\n        this.c = adler();\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be zlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Zlib.prototype.push = function (chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Zlib.prototype.p = function (c, f) {\n        this.c.p(c);\n        var raw = dopt(c, this.o, this.v && 2, f && 4, !f);\n        if (this.v)\n            zlh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 4, this.c.d());\n        this.ondata(raw, f);\n    };\n    return Zlib;\n}());\nexport { Zlib };\n/**\n * Asynchronous streaming Zlib compression\n */\nvar AsyncZlib = /*#__PURE__*/ (function () {\n    function AsyncZlib(opts, cb) {\n        astrmify([\n            bDflt,\n            zle,\n            function () { return [astrm, Deflate, Zlib]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Zlib(ev.data);\n            onmessage = astrm(strm);\n        }, 10);\n    }\n    return AsyncZlib;\n}());\nexport { AsyncZlib };\nexport function zlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n        zle,\n        function () { return [zlibSync]; }\n    ], function (ev) { return pbf(zlibSync(ev.data[0], ev.data[1])); }, 4, cb);\n}\n/**\n * Compress data with Zlib\n * @param data The data to compress\n * @param opts The compression options\n * @returns The zlib-compressed version of the data\n */\nexport function zlibSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var a = adler();\n    a.p(data);\n    var d = dopt(data, opts, 2, 4);\n    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;\n}\n/**\n * Streaming Zlib decompression\n */\nvar Unzlib = /*#__PURE__*/ (function () {\n    /**\n     * Creates a Zlib decompression stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Unzlib(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be unzlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzlib.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            if (this.p.length < 2 && !final)\n                return;\n            this.p = this.p.subarray(2), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 4)\n                err(6, 'invalid zlib data');\n            this.p = this.p.subarray(0, -4);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Unzlib;\n}());\nexport { Unzlib };\n/**\n * Asynchronous streaming Zlib decompression\n */\nvar AsyncUnzlib = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous Zlib decompression stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncUnzlib(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            zule,\n            function () { return [astrm, Inflate, Unzlib]; }\n        ], this, 0, function () {\n            var strm = new Unzlib();\n            onmessage = astrm(strm);\n        }, 11);\n    }\n    return AsyncUnzlib;\n}());\nexport { AsyncUnzlib };\nexport function unzlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt,\n        zule,\n        function () { return [unzlibSync]; }\n    ], function (ev) { return pbf(unzlibSync(ev.data[0], gu8(ev.data[1]))); }, 5, cb);\n}\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function unzlibSync(data, out) {\n    return inflt((zlv(data), data.subarray(2, -4)), out);\n}\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzip as compress, AsyncGzip as AsyncCompress };\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzipSync as compressSync, Gzip as Compress };\n/**\n * Streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar Decompress = /*#__PURE__*/ (function () {\n    /**\n     * Creates a decompression stream\n     * @param cb The callback to call whenever data is decompressed\n     */\n    function Decompress(cb) {\n        this.G = Gunzip;\n        this.I = Inflate;\n        this.Z = Unzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Decompress.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (!this.s) {\n            if (this.p && this.p.length) {\n                var n = new u8(this.p.length + chunk.length);\n                n.set(this.p), n.set(chunk, this.p.length);\n            }\n            else\n                this.p = chunk;\n            if (this.p.length > 2) {\n                var _this_1 = this;\n                var cb = function () { _this_1.ondata.apply(_this_1, arguments); };\n                this.s = (this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8)\n                    ? new this.G(cb)\n                    : ((this.p[0] & 15) != 8 || (this.p[0] >> 4) > 7 || ((this.p[0] << 8 | this.p[1]) % 31))\n                        ? new this.I(cb)\n                        : new this.Z(cb);\n                this.s.push(this.p, final);\n                this.p = null;\n            }\n        }\n        else\n            this.s.push(chunk, final);\n    };\n    return Decompress;\n}());\nexport { Decompress };\n/**\n * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar AsyncDecompress = /*#__PURE__*/ (function () {\n    /**\n   * Creates an asynchronous decompression stream\n   * @param cb The callback to call whenever data is decompressed\n   */\n    function AsyncDecompress(cb) {\n        this.G = AsyncGunzip;\n        this.I = AsyncInflate;\n        this.Z = AsyncUnzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncDecompress.prototype.push = function (chunk, final) {\n        Decompress.prototype.push.call(this, chunk, final);\n    };\n    return AsyncDecompress;\n}());\nexport { AsyncDecompress };\nexport function decompress(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzip(data, opts, cb)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflate(data, opts, cb)\n            : unzlib(data, opts, cb);\n}\n/**\n * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function decompressSync(data, out) {\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzipSync(data, out)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflateSync(data, out)\n            : unzlibSync(data, out);\n}\n// flatten a directory structure\nvar fltn = function (d, p, t, o) {\n    for (var k in d) {\n        var val = d[k], n = p + k, op = o;\n        if (Array.isArray(val))\n            op = mrg(o, val[1]), val = val[0];\n        if (val instanceof u8)\n            t[n] = [val, op];\n        else {\n            t[n += '/'] = [new u8(0), op];\n            fltn(val, n, t, o);\n        }\n    }\n};\n// text encoder\nvar te = typeof TextEncoder != 'undefined' && /*#__PURE__*/ new TextEncoder();\n// text decoder\nvar td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();\n// text decoder stream\nvar tds = 0;\ntry {\n    td.decode(et, { stream: true });\n    tds = 1;\n}\ncatch (e) { }\n// decode UTF8\nvar dutf8 = function (d) {\n    for (var r = '', i = 0;;) {\n        var c = d[i++];\n        var eb = (c > 127) + (c > 223) + (c > 239);\n        if (i + eb > d.length)\n            return [r, slc(d, i - 1)];\n        if (!eb)\n            r += String.fromCharCode(c);\n        else if (eb == 3) {\n            c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63)) - 65536,\n                r += String.fromCharCode(55296 | (c >> 10), 56320 | (c & 1023));\n        }\n        else if (eb & 1)\n            r += String.fromCharCode((c & 31) << 6 | (d[i++] & 63));\n        else\n            r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63));\n    }\n};\n/**\n * Streaming UTF-8 decoding\n */\nvar DecodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is decoded\n     */\n    function DecodeUTF8(cb) {\n        this.ondata = cb;\n        if (tds)\n            this.t = new TextDecoder();\n        else\n            this.p = et;\n    }\n    /**\n     * Pushes a chunk to be decoded from UTF-8 binary\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    DecodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        final = !!final;\n        if (this.t) {\n            this.ondata(this.t.decode(chunk, { stream: true }), final);\n            if (final) {\n                if (this.t.decode().length)\n                    err(8);\n                this.t = null;\n            }\n            return;\n        }\n        if (!this.p)\n            err(4);\n        var dat = new u8(this.p.length + chunk.length);\n        dat.set(this.p);\n        dat.set(chunk, this.p.length);\n        var _a = dutf8(dat), ch = _a[0], np = _a[1];\n        if (final) {\n            if (np.length)\n                err(8);\n            this.p = null;\n        }\n        else\n            this.p = np;\n        this.ondata(ch, final);\n    };\n    return DecodeUTF8;\n}());\nexport { DecodeUTF8 };\n/**\n * Streaming UTF-8 encoding\n */\nvar EncodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is encoded\n     */\n    function EncodeUTF8(cb) {\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be encoded to UTF-8\n     * @param chunk The string data to push\n     * @param final Whether this is the last chunk\n     */\n    EncodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        this.ondata(strToU8(chunk), this.d = final || false);\n    };\n    return EncodeUTF8;\n}());\nexport { EncodeUTF8 };\n/**\n * Converts a string into a Uint8Array for use with compression/decompression methods\n * @param str The string to encode\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless decoding a binary string.\n * @returns The string encoded in UTF-8/Latin-1 binary\n */\nexport function strToU8(str, latin1) {\n    if (latin1) {\n        var ar_1 = new u8(str.length);\n        for (var i = 0; i < str.length; ++i)\n            ar_1[i] = str.charCodeAt(i);\n        return ar_1;\n    }\n    if (te)\n        return te.encode(str);\n    var l = str.length;\n    var ar = new u8(str.length + (str.length >> 1));\n    var ai = 0;\n    var w = function (v) { ar[ai++] = v; };\n    for (var i = 0; i < l; ++i) {\n        if (ai + 5 > ar.length) {\n            var n = new u8(ai + 8 + ((l - i) << 1));\n            n.set(ar);\n            ar = n;\n        }\n        var c = str.charCodeAt(i);\n        if (c < 128 || latin1)\n            w(c);\n        else if (c < 2048)\n            w(192 | (c >> 6)), w(128 | (c & 63));\n        else if (c > 55295 && c < 57344)\n            c = 65536 + (c & 1023 << 10) | (str.charCodeAt(++i) & 1023),\n                w(240 | (c >> 18)), w(128 | ((c >> 12) & 63)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n        else\n            w(224 | (c >> 12)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n    }\n    return slc(ar, 0, ai);\n}\n/**\n * Converts a Uint8Array to a string\n * @param dat The data to decode to string\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless encoding to binary string.\n * @returns The original UTF-8/Latin-1 string\n */\nexport function strFromU8(dat, latin1) {\n    if (latin1) {\n        var r = '';\n        for (var i = 0; i < dat.length; i += 16384)\n            r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));\n        return r;\n    }\n    else if (td)\n        return td.decode(dat);\n    else {\n        var _a = dutf8(dat), out = _a[0], ext = _a[1];\n        if (ext.length)\n            err(8);\n        return out;\n    }\n}\n;\n// deflate bit flag\nvar dbf = function (l) { return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0; };\n// skip local zip header\nvar slzh = function (d, b) { return b + 30 + b2(d, b + 26) + b2(d, b + 28); };\n// read zip header\nvar zh = function (d, b, z) {\n    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\n    var _a = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a[0], su = _a[1], off = _a[2];\n    return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];\n};\n// read zip64 extra field\nvar z64e = function (d, b) {\n    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))\n        ;\n    return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];\n};\n// extra field length\nvar exfl = function (ex) {\n    var le = 0;\n    if (ex) {\n        for (var k in ex) {\n            var l = ex[k].length;\n            if (l > 65535)\n                err(9);\n            le += l + 4;\n        }\n    }\n    return le;\n};\n// write zip header\nvar wzh = function (d, b, f, fn, u, c, ce, co) {\n    var fl = fn.length, ex = f.extra, col = co && co.length;\n    var exl = exfl(ex);\n    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;\n    if (ce != null)\n        d[b++] = 20, d[b++] = f.os;\n    d[b] = 20, b += 2; // spec compliance? what's that?\n    d[b++] = (f.flag << 1) | (c < 0 && 8), d[b++] = u && 8;\n    d[b++] = f.compression & 255, d[b++] = f.compression >> 8;\n    var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;\n    if (y < 0 || y > 119)\n        err(10);\n    wbytes(d, b, (y << 25) | ((dt.getMonth() + 1) << 21) | (dt.getDate() << 16) | (dt.getHours() << 11) | (dt.getMinutes() << 5) | (dt.getSeconds() >>> 1)), b += 4;\n    if (c != -1) {\n        wbytes(d, b, f.crc);\n        wbytes(d, b + 4, c < 0 ? -c - 2 : c);\n        wbytes(d, b + 8, f.size);\n    }\n    wbytes(d, b + 12, fl);\n    wbytes(d, b + 14, exl), b += 16;\n    if (ce != null) {\n        wbytes(d, b, col);\n        wbytes(d, b + 6, f.attrs);\n        wbytes(d, b + 10, ce), b += 14;\n    }\n    d.set(fn, b);\n    b += fl;\n    if (exl) {\n        for (var k in ex) {\n            var exf = ex[k], l = exf.length;\n            wbytes(d, b, +k);\n            wbytes(d, b + 2, l);\n            d.set(exf, b + 4), b += 4 + l;\n        }\n    }\n    if (col)\n        d.set(co, b), b += col;\n    return b;\n};\n// write zip footer (end of central directory)\nvar wzf = function (o, b, c, d, e) {\n    wbytes(o, b, 0x6054B50); // skip disk\n    wbytes(o, b + 8, c);\n    wbytes(o, b + 10, c);\n    wbytes(o, b + 12, d);\n    wbytes(o, b + 16, e);\n};\n/**\n * A pass-through stream to keep data uncompressed in a ZIP archive.\n */\nvar ZipPassThrough = /*#__PURE__*/ (function () {\n    /**\n     * Creates a pass-through stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     */\n    function ZipPassThrough(filename) {\n        this.filename = filename;\n        this.c = crc();\n        this.size = 0;\n        this.compression = 0;\n    }\n    /**\n     * Processes a chunk and pushes to the output stream. You can override this\n     * method in a subclass for custom behavior, but by default this passes\n     * the data through. You must call this.ondata(err, chunk, final) at some\n     * point in this method.\n     * @param chunk The chunk to process\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.process = function (chunk, final) {\n        this.ondata(null, chunk, final);\n    };\n    /**\n     * Pushes a chunk to be added. If you are subclassing this with a custom\n     * compression algorithm, note that you must push data from the source\n     * file only, pre-compression.\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        this.c.p(chunk);\n        this.size += chunk.length;\n        if (final)\n            this.crc = this.c.d();\n        this.process(chunk, final || false);\n    };\n    return ZipPassThrough;\n}());\nexport { ZipPassThrough };\n// I don't extend because TypeScript extension adds 1kB of runtime bloat\n/**\n * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate\n * for better performance\n */\nvar ZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function ZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new Deflate(opts, function (dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n    }\n    ZipDeflate.prototype.process = function (chunk, final) {\n        try {\n            this.d.push(chunk, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return ZipDeflate;\n}());\nexport { ZipDeflate };\n/**\n * Asynchronous streaming DEFLATE compression for ZIP archives\n */\nvar AsyncZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function AsyncZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new AsyncDeflate(opts, function (err, dat, final) {\n            _this_1.ondata(err, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n        this.terminate = this.d.terminate;\n    }\n    AsyncZipDeflate.prototype.process = function (chunk, final) {\n        this.d.push(chunk, final);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return AsyncZipDeflate;\n}());\nexport { AsyncZipDeflate };\n// TODO: Better tree shaking\n/**\n * A zippable archive to which files can incrementally be added\n */\nvar Zip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an empty ZIP archive to which files can be added\n     * @param cb The callback to call whenever data for the generated ZIP archive\n     *           is available\n     */\n    function Zip(cb) {\n        this.ondata = cb;\n        this.u = [];\n        this.d = 1;\n    }\n    /**\n     * Adds a file to the ZIP archive\n     * @param file The file stream to add\n     */\n    Zip.prototype.add = function (file) {\n        var _this_1 = this;\n        if (!this.ondata)\n            err(5);\n        // finishing or finished\n        if (this.d & 2)\n            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, false);\n        else {\n            var f = strToU8(file.filename), fl_1 = f.length;\n            var com = file.comment, o = com && strToU8(com);\n            var u = fl_1 != file.filename.length || (o && (com.length != o.length));\n            var hl_1 = fl_1 + exfl(file.extra) + 30;\n            if (fl_1 > 65535)\n                this.ondata(err(11, 0, 1), null, false);\n            var header = new u8(hl_1);\n            wzh(header, 0, file, f, u, -1);\n            var chks_1 = [header];\n            var pAll_1 = function () {\n                for (var _i = 0, chks_2 = chks_1; _i < chks_2.length; _i++) {\n                    var chk = chks_2[_i];\n                    _this_1.ondata(null, chk, false);\n                }\n                chks_1 = [];\n            };\n            var tr_1 = this.d;\n            this.d = 0;\n            var ind_1 = this.u.length;\n            var uf_1 = mrg(file, {\n                f: f,\n                u: u,\n                o: o,\n                t: function () {\n                    if (file.terminate)\n                        file.terminate();\n                },\n                r: function () {\n                    pAll_1();\n                    if (tr_1) {\n                        var nxt = _this_1.u[ind_1 + 1];\n                        if (nxt)\n                            nxt.r();\n                        else\n                            _this_1.d = 1;\n                    }\n                    tr_1 = 1;\n                }\n            });\n            var cl_1 = 0;\n            file.ondata = function (err, dat, final) {\n                if (err) {\n                    _this_1.ondata(err, dat, final);\n                    _this_1.terminate();\n                }\n                else {\n                    cl_1 += dat.length;\n                    chks_1.push(dat);\n                    if (final) {\n                        var dd = new u8(16);\n                        wbytes(dd, 0, 0x8074B50);\n                        wbytes(dd, 4, file.crc);\n                        wbytes(dd, 8, cl_1);\n                        wbytes(dd, 12, file.size);\n                        chks_1.push(dd);\n                        uf_1.c = cl_1, uf_1.b = hl_1 + cl_1 + 16, uf_1.crc = file.crc, uf_1.size = file.size;\n                        if (tr_1)\n                            uf_1.r();\n                        tr_1 = 1;\n                    }\n                    else if (tr_1)\n                        pAll_1();\n                }\n            };\n            this.u.push(uf_1);\n        }\n    };\n    /**\n     * Ends the process of adding files and prepares to emit the final chunks.\n     * This *must* be called after adding all desired files for the resulting\n     * ZIP file to work properly.\n     */\n    Zip.prototype.end = function () {\n        var _this_1 = this;\n        if (this.d & 2) {\n            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, true);\n            return;\n        }\n        if (this.d)\n            this.e();\n        else\n            this.u.push({\n                r: function () {\n                    if (!(_this_1.d & 1))\n                        return;\n                    _this_1.u.splice(-1, 1);\n                    _this_1.e();\n                },\n                t: function () { }\n            });\n        this.d = 3;\n    };\n    Zip.prototype.e = function () {\n        var bt = 0, l = 0, tl = 0;\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);\n        }\n        var out = new u8(tl + 22);\n        for (var _b = 0, _c = this.u; _b < _c.length; _b++) {\n            var f = _c[_b];\n            wzh(out, bt, f, f.f, f.u, -f.c - 2, l, f.o);\n            bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;\n        }\n        wzf(out, bt, this.u.length, tl, l);\n        this.ondata(null, out, true);\n        this.d = 2;\n    };\n    /**\n     * A method to terminate any internal workers used by the stream. Subsequent\n     * calls to add() will fail.\n     */\n    Zip.prototype.terminate = function () {\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            f.t();\n        }\n        this.d = 2;\n    };\n    return Zip;\n}());\nexport { Zip };\nexport function zip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    var r = {};\n    fltn(data, '', r, opts);\n    var k = Object.keys(r);\n    var lft = k.length, o = 0, tot = 0;\n    var slft = lft, files = new Array(lft);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var cbd = function (a, b) {\n        mt(function () { cb(a, b); });\n    };\n    mt(function () { cbd = cb; });\n    var cbf = function () {\n        var out = new u8(tot + 22), oe = o, cdl = tot - o;\n        tot = 0;\n        for (var i = 0; i < slft; ++i) {\n            var f = files[i];\n            try {\n                var l = f.c.length;\n                wzh(out, tot, f, f.f, f.u, l);\n                var badd = 30 + f.f.length + exfl(f.extra);\n                var loc = tot + badd;\n                out.set(f.c, loc);\n                wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;\n            }\n            catch (e) {\n                return cbd(e, null);\n            }\n        }\n        wzf(out, o, files.length, cdl, oe);\n        cbd(null, out);\n    };\n    if (!lft)\n        cbf();\n    var _loop_1 = function (i) {\n        var fn = k[i];\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var c = crc(), size = file.length;\n        c.p(file);\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        var compression = p.level == 0 ? 0 : 8;\n        var cbl = function (e, d) {\n            if (e) {\n                tAll();\n                cbd(e, null);\n            }\n            else {\n                var l = d.length;\n                files[i] = mrg(p, {\n                    size: size,\n                    crc: c.d(),\n                    c: d,\n                    f: f,\n                    m: m,\n                    u: s != fn.length || (m && (com.length != ms)),\n                    compression: compression\n                });\n                o += 30 + s + exl + l;\n                tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n                if (!--lft)\n                    cbf();\n            }\n        };\n        if (s > 65535)\n            cbl(err(11, 0, 1), null);\n        if (!compression)\n            cbl(null, file);\n        else if (size < 160000) {\n            try {\n                cbl(null, deflateSync(file, p));\n            }\n            catch (e) {\n                cbl(e, null);\n            }\n        }\n        else\n            term.push(deflate(file, p, cbl));\n    };\n    // Cannot use lft because it can decrease\n    for (var i = 0; i < slft; ++i) {\n        _loop_1(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously creates a ZIP file. Prefer using `zip` for better performance\n * with more than one file.\n * @param data The directory structure for the ZIP archive\n * @param opts The main options, merged with per-file options\n * @returns The generated ZIP archive\n */\nexport function zipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var r = {};\n    var files = [];\n    fltn(data, '', r, opts);\n    var o = 0;\n    var tot = 0;\n    for (var fn in r) {\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var compression = p.level == 0 ? 0 : 8;\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        if (s > 65535)\n            err(11);\n        var d = compression ? deflateSync(file, p) : file, l = d.length;\n        var c = crc();\n        c.p(file);\n        files.push(mrg(p, {\n            size: file.length,\n            crc: c.d(),\n            c: d,\n            f: f,\n            m: m,\n            u: s != fn.length || (m && (com.length != ms)),\n            o: o,\n            compression: compression\n        }));\n        o += 30 + s + exl + l;\n        tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n    }\n    var out = new u8(tot + 22), oe = o, cdl = tot - o;\n    for (var i = 0; i < files.length; ++i) {\n        var f = files[i];\n        wzh(out, f.o, f, f.f, f.u, f.c.length);\n        var badd = 30 + f.f.length + exfl(f.extra);\n        out.set(f.c, f.o + badd);\n        wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);\n    }\n    wzf(out, o, files.length, cdl, oe);\n    return out;\n}\n/**\n * Streaming pass-through decompression for ZIP archives\n */\nvar UnzipPassThrough = /*#__PURE__*/ (function () {\n    function UnzipPassThrough() {\n    }\n    UnzipPassThrough.prototype.push = function (data, final) {\n        this.ondata(null, data, final);\n    };\n    UnzipPassThrough.compression = 0;\n    return UnzipPassThrough;\n}());\nexport { UnzipPassThrough };\n/**\n * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for\n * better performance.\n */\nvar UnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function UnzipInflate() {\n        var _this_1 = this;\n        this.i = new Inflate(function (dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n    }\n    UnzipInflate.prototype.push = function (data, final) {\n        try {\n            this.i.push(data, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    UnzipInflate.compression = 8;\n    return UnzipInflate;\n}());\nexport { UnzipInflate };\n/**\n * Asynchronous streaming DEFLATE decompression for ZIP archives\n */\nvar AsyncUnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function AsyncUnzipInflate(_, sz) {\n        var _this_1 = this;\n        if (sz < 320000) {\n            this.i = new Inflate(function (dat, final) {\n                _this_1.ondata(null, dat, final);\n            });\n        }\n        else {\n            this.i = new AsyncInflate(function (err, dat, final) {\n                _this_1.ondata(err, dat, final);\n            });\n            this.terminate = this.i.terminate;\n        }\n    }\n    AsyncUnzipInflate.prototype.push = function (data, final) {\n        if (this.i.terminate)\n            data = slc(data, 0);\n        this.i.push(data, final);\n    };\n    AsyncUnzipInflate.compression = 8;\n    return AsyncUnzipInflate;\n}());\nexport { AsyncUnzipInflate };\n/**\n * A ZIP archive decompression stream that emits files as they are discovered\n */\nvar Unzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a ZIP decompression stream\n     * @param cb The callback to call whenever a file in the ZIP archive is found\n     */\n    function Unzip(cb) {\n        this.onfile = cb;\n        this.k = [];\n        this.o = {\n            0: UnzipPassThrough\n        };\n        this.p = et;\n    }\n    /**\n     * Pushes a chunk to be unzipped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzip.prototype.push = function (chunk, final) {\n        var _this_1 = this;\n        if (!this.onfile)\n            err(5);\n        if (!this.p)\n            err(4);\n        if (this.c > 0) {\n            var len = Math.min(this.c, chunk.length);\n            var toAdd = chunk.subarray(0, len);\n            this.c -= len;\n            if (this.d)\n                this.d.push(toAdd, !this.c);\n            else\n                this.k[0].push(toAdd);\n            chunk = chunk.subarray(len);\n            if (chunk.length)\n                return this.push(chunk, final);\n        }\n        else {\n            var f = 0, i = 0, is = void 0, buf = void 0;\n            if (!this.p.length)\n                buf = chunk;\n            else if (!chunk.length)\n                buf = this.p;\n            else {\n                buf = new u8(this.p.length + chunk.length);\n                buf.set(this.p), buf.set(chunk, this.p.length);\n            }\n            var l = buf.length, oc = this.c, add = oc && this.d;\n            var _loop_2 = function () {\n                var _a;\n                var sig = b4(buf, i);\n                if (sig == 0x4034B50) {\n                    f = 1, is = i;\n                    this_1.d = null;\n                    this_1.c = 0;\n                    var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);\n                    if (l > i + 30 + fnl + es) {\n                        var chks_3 = [];\n                        this_1.k.unshift(chks_3);\n                        f = 2;\n                        var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);\n                        var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);\n                        if (sc_1 == 4294967295) {\n                            _a = dd ? [-2] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];\n                        }\n                        else if (dd)\n                            sc_1 = -1;\n                        i += es;\n                        this_1.c = sc_1;\n                        var d_1;\n                        var file_1 = {\n                            name: fn_1,\n                            compression: cmp_1,\n                            start: function () {\n                                if (!file_1.ondata)\n                                    err(5);\n                                if (!sc_1)\n                                    file_1.ondata(null, et, true);\n                                else {\n                                    var ctr = _this_1.o[cmp_1];\n                                    if (!ctr)\n                                        file_1.ondata(err(14, 'unknown compression type ' + cmp_1, 1), null, false);\n                                    d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);\n                                    d_1.ondata = function (err, dat, final) { file_1.ondata(err, dat, final); };\n                                    for (var _i = 0, chks_4 = chks_3; _i < chks_4.length; _i++) {\n                                        var dat = chks_4[_i];\n                                        d_1.push(dat, false);\n                                    }\n                                    if (_this_1.k[0] == chks_3 && _this_1.c)\n                                        _this_1.d = d_1;\n                                    else\n                                        d_1.push(et, true);\n                                }\n                            },\n                            terminate: function () {\n                                if (d_1 && d_1.terminate)\n                                    d_1.terminate();\n                            }\n                        };\n                        if (sc_1 >= 0)\n                            file_1.size = sc_1, file_1.originalSize = su_1;\n                        this_1.onfile(file_1);\n                    }\n                    return \"break\";\n                }\n                else if (oc) {\n                    if (sig == 0x8074B50) {\n                        is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                    else if (sig == 0x2014B50) {\n                        is = i -= 4, f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                }\n            };\n            var this_1 = this;\n            for (; i < l - 4; ++i) {\n                var state_1 = _loop_2();\n                if (state_1 === \"break\")\n                    break;\n            }\n            this.p = et;\n            if (oc < 0) {\n                var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);\n                if (add)\n                    add.push(dat, !!f);\n                else\n                    this.k[+(f == 2)].push(dat);\n            }\n            if (f & 2)\n                return this.push(buf.subarray(i), final);\n            this.p = buf.subarray(i);\n        }\n        if (final) {\n            if (this.c)\n                err(13);\n            this.p = null;\n        }\n    };\n    /**\n     * Registers a decoder with the stream, allowing for files compressed with\n     * the compression type provided to be expanded correctly\n     * @param decoder The decoder constructor\n     */\n    Unzip.prototype.register = function (decoder) {\n        this.o[decoder.compression] = decoder;\n    };\n    return Unzip;\n}());\nexport { Unzip };\nvar mt = typeof queueMicrotask == 'function' ? queueMicrotask : typeof setTimeout == 'function' ? setTimeout : function (fn) { fn(); };\nexport function unzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var files = {};\n    var cbd = function (a, b) {\n        mt(function () { cb(a, b); });\n    };\n    mt(function () { cbd = cb; });\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558) {\n            cbd(err(13, 0, 1), null);\n            return tAll;\n        }\n    }\n    ;\n    var lft = b2(data, e + 8);\n    if (lft) {\n        var c = lft;\n        var o = b4(data, e + 16);\n        var z = o == 4294967295 || c == 65535;\n        if (z) {\n            var ze = b4(data, e - 12);\n            z = b4(data, ze) == 0x6064B50;\n            if (z) {\n                c = lft = b4(data, ze + 32);\n                o = b4(data, ze + 48);\n            }\n        }\n        var fltr = opts && opts.filter;\n        var _loop_3 = function (i) {\n            var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n            o = no;\n            var cbl = function (e, d) {\n                if (e) {\n                    tAll();\n                    cbd(e, null);\n                }\n                else {\n                    if (d)\n                        files[fn] = d;\n                    if (!--lft)\n                        cbd(null, files);\n                }\n            };\n            if (!fltr || fltr({\n                name: fn,\n                size: sc,\n                originalSize: su,\n                compression: c_1\n            })) {\n                if (!c_1)\n                    cbl(null, slc(data, b, b + sc));\n                else if (c_1 == 8) {\n                    var infl = data.subarray(b, b + sc);\n                    if (sc < 320000) {\n                        try {\n                            cbl(null, inflateSync(infl, new u8(su)));\n                        }\n                        catch (e) {\n                            cbl(e, null);\n                        }\n                    }\n                    else\n                        term.push(inflate(infl, { size: su }, cbl));\n                }\n                else\n                    cbl(err(14, 'unknown compression type ' + c_1, 1), null);\n            }\n            else\n                cbl(null, null);\n        };\n        for (var i = 0; i < c; ++i) {\n            _loop_3(i);\n        }\n    }\n    else\n        cbd(null, {});\n    return tAll;\n}\n/**\n * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better\n * performance with more than one file.\n * @param data The raw compressed ZIP file\n * @param opts The ZIP extraction options\n * @returns The decompressed files\n */\nexport function unzipSync(data, opts) {\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558)\n            err(13);\n    }\n    ;\n    var c = b2(data, e + 8);\n    if (!c)\n        return {};\n    var o = b4(data, e + 16);\n    var z = o == 4294967295 || c == 65535;\n    if (z) {\n        var ze = b4(data, e - 12);\n        z = b4(data, ze) == 0x6064B50;\n        if (z) {\n            c = b4(data, ze + 32);\n            o = b4(data, ze + 48);\n        }\n    }\n    var fltr = opts && opts.filter;\n    for (var i = 0; i < c; ++i) {\n        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        if (!fltr || fltr({\n            name: fn,\n            size: sc,\n            originalSize: su,\n            compression: c_2\n        })) {\n            if (!c_2)\n                files[fn] = slc(data, b, b + sc);\n            else if (c_2 == 8)\n                files[fn] = inflateSync(data.subarray(b, b + sc), new u8(su));\n            else\n                err(14, 'unknown compression type ' + c_2);\n        }\n    }\n    return files;\n}\n","import * as fflate from 'fflate';\nexport default class FFlateEncoder {\n    encode(arrayBuffer) {\n        return fflate.gzipSync(new Uint8Array(arrayBuffer)).buffer;\n    }\n    decode(arrayBuffer) {\n        return fflate.gunzipSync(new Uint8Array(arrayBuffer)).buffer;\n    }\n}\n","export const SPLIT_REGEX = /\\W+/g;\nexport const TEST_REGEX = /(\\w\\W+|\\W+\\w)/;\n/**\n * detect the type of a value\n *\n * @param value Value to analyze\n * @returns type of the value\n */\nexport function getType(value) {\n    if (Array.isArray(value)) {\n        return \"array\";\n    }\n    else if (typeof value === \"object\" && value) {\n        return \"object\";\n    }\n    else if (typeof value === \"string\" && TEST_REGEX.test(value)) {\n        return \"split\";\n    }\n    else {\n        return \"leaf\";\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nconst md5 = require(\"md5\");\nimport Loader from \"../io/Loader\";\nimport { getType, SPLIT_REGEX } from \"./Token\";\n/**\n * Class for spitting objects into tokens.\n */\nexport default class Tokenizer {\n    constructor() {\n        this.loader = new Loader();\n    }\n    /**\n     * Load json or text files and turn them into tokens.\n     *\n     * @param files files to load and reduce.\n     */\n    load(...files) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (files.some(file => typeof file !== \"string\")) {\n                throw new Error(\"Each argument passed to load must be a string.\");\n            }\n            const sortedFiles = files.sort();\n            const allData = yield Promise.all(sortedFiles.map(this.loader.load));\n            return this.tokenize(Object.fromEntries(allData.map((data, index) => [sortedFiles[index], data])));\n        });\n    }\n    /**\n     * Takes a mapping of filename and their corresponding data, and turn them into tokens.\n     *\n     * @param items Mapping from filename to data.\n     * @returns All data stored as tokens.\n     */\n    tokenize(items) {\n        const header = {\n            registry: {},\n            files: {},\n        };\n        const counter = { next: 0 };\n        Object.entries(items).forEach(([file, value]) => {\n            header.files[file] = {\n                nameToken: this.tokenizeHelper(file, header.registry, counter, \"header\"),\n                token: this.tokenizeHelper(value, header.registry, counter, file),\n            };\n        });\n        return header;\n    }\n    registerToken(hash, value, registry, counter, file, reference) {\n        var _a;\n        const entry = (_a = registry[hash]) !== null && _a !== void 0 ? _a : (registry[hash] = {\n            type: getType(value),\n            hash,\n            value,\n            reference,\n            order: counter.next++,\n            count: 0,\n            files: new Set(),\n        });\n        entry.files.add(file);\n        entry.count++;\n        return entry;\n    }\n    tokenizeHelper(item, registry, counter, file) {\n        const type = getType(item);\n        if (type === \"array\") {\n            if (!Array.isArray(item)) {\n                throw new Error(\"item should be an array\");\n            }\n            const hashes = item.map(item => this.tokenizeHelper(item, registry, counter, file)).map(({ hash }) => hash);\n            const hash = md5(hashes.join(\",\"));\n            return this.registerToken(hash, item, registry, counter, file, hashes);\n        }\n        else if (type === \"object\") {\n            const entries = Object.entries(item);\n            const keysToken = this.tokenizeHelper(entries.map(([key]) => key), registry, counter, file);\n            const valuesToken = this.tokenizeHelper(entries.map(([, value]) => value), registry, counter, file);\n            const hash = md5(`${keysToken.hash}|${valuesToken.hash}`);\n            return this.registerToken(hash, item, registry, counter, file, [keysToken.hash, valuesToken.hash]);\n        }\n        else if (type === \"split\") {\n            const chunks = item.split(SPLIT_REGEX);\n            const separators = item.match(SPLIT_REGEX);\n            const chunksToken = this.tokenizeHelper(chunks, registry, counter, file);\n            const separatorsToken = this.tokenizeHelper(separators, registry, counter, file);\n            const hash = md5(`${chunksToken.hash}-${separatorsToken.hash}`);\n            return this.registerToken(hash, item, registry, counter, file, [chunksToken.hash, separatorsToken.hash]);\n        }\n        else {\n            return this.registerToken(md5(JSON.stringify(item)), item, registry, counter, file);\n        }\n    }\n}\n","const DEFAULT_CONFIG = {\n    cacheable: true,\n    allowReferences: false,\n};\n/**\n * Class storing all data that can be extracted.\n */\nexport default class ExtractableData {\n    constructor(dataStore, config) {\n        this.extractor = new Extractor();\n        this.dataStore = dataStore;\n        this.config = Object.assign(Object.assign({}, DEFAULT_CONFIG), config);\n        const fileNames = this.extractor.extractFileNames(dataStore.files, dataStore.headerTokens, this.config);\n        this.fileToSlot = Object.fromEntries(fileNames.map((file, index) => [file, index]));\n    }\n    /**\n     * Extract data form a stored file.\n     *\n     * @param filename filename to be extracted.\n     * @param allowReferences If true, within the extracted object, multiple nodes can reference the same object.\n     *  This helps performance and memory, but can lead to weird side effects if the extracted object\n     *  gets modified.\n     * @returns extracted data.\n     */\n    extract(filename, allowReferences) {\n        const slot = this.fileToSlot[filename];\n        const dataTokens = this.dataStore.getDataTokens(slot);\n        if (dataTokens) {\n            return this.extractor.extract(this.dataStore.headerTokens, dataTokens, Object.assign(Object.assign({}, this.config), { allowReferences: allowReferences !== null && allowReferences !== void 0 ? allowReferences : this.config.allowReferences }));\n        }\n    }\n}\nclass Extractor {\n    constructor() {\n        this.valueFetcher = {\n            \"array\": this.getArray.bind(this),\n            \"leaf\": undefined,\n            \"object\": this.getObject.bind(this),\n            \"split\": this.getSplit.bind(this),\n        };\n    }\n    extractFileNames(files, headerTokens, config) {\n        return files.map(index => this.extractToken(index, headerTokens, undefined, config));\n    }\n    extract(headerTokens, dataTokens, config) {\n        return this.extractToken(headerTokens.length + dataTokens.length - 1, headerTokens, dataTokens, config);\n    }\n    extractToken(index, headerTokens, dataTokens, config, forceAllowUseCache) {\n        const token = index < headerTokens.length ? headerTokens[index] : dataTokens === null || dataTokens === void 0 ? void 0 : dataTokens[index - headerTokens.length];\n        if (!token) {\n            throw new Error(\"Invalid token at index: \" + index);\n        }\n        if (token.type === \"leaf\") {\n            return token.value;\n        }\n        return this.extractValueOrCache(token, headerTokens, dataTokens, config, forceAllowUseCache || config.allowReferences, this.valueFetcher[token.type]);\n    }\n    getArray(token, headerTokens, dataTokens, config) {\n        if (!Array.isArray(token.value)) {\n            throw new Error(\"Invalid array token\");\n        }\n        return token.value.map(index => this.extractToken(index, headerTokens, dataTokens, config));\n    }\n    getObject(token, headerTokens, dataTokens, config) {\n        const [keyIndex, valueIndex] = token.value;\n        const keys = this.extractToken(keyIndex, headerTokens, dataTokens, config, true);\n        const values = this.extractToken(valueIndex, headerTokens, dataTokens, config);\n        return Object.fromEntries(keys.map((key, index) => [key, values[index]]));\n    }\n    getSplit(token, headerTokens, dataTokens, config) {\n        const [chunksIndex, separatorsIndex] = token.value;\n        const chunks = this.extractToken(chunksIndex, headerTokens, dataTokens, config, true);\n        const separators = this.extractToken(separatorsIndex, headerTokens, dataTokens, config, true);\n        return chunks.map((chunk, index) => { var _a; return `${chunk}${(_a = separators[index]) !== null && _a !== void 0 ? _a : \"\"}`; }).join(\"\");\n    }\n    extractValueOrCache(token, headerTokens, dataTokens, config, allowUseCache, getValue) {\n        if (token.cache !== undefined && allowUseCache) {\n            return token.cache;\n        }\n        if (!getValue) {\n            throw new Error(\"getValue not provided.\");\n        }\n        const value = getValue(token, headerTokens, dataTokens, config);\n        if (config.cacheable) {\n            token.cache = value;\n        }\n        return value;\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport Reducer from \"../reducer/Reducer\";\nimport { StreamDataView } from \"stream-data-view\";\nimport TokenEncoder from \"./TokenEncoder\";\nimport FFlateEncoder from \"./FFlateEncoder\";\nimport { version } from '../../package.json';\nimport Tokenizer from \"../tokenizer/Tokenizer\";\nimport ExtractableData from \"../expander/Extractor\";\nvar EncoderEnum;\n(function (EncoderEnum) {\n    EncoderEnum[EncoderEnum[\"NONE\"] = 0] = \"NONE\";\n    EncoderEnum[EncoderEnum[\"FFLATE\"] = 1] = \"FFLATE\";\n})(EncoderEnum || (EncoderEnum = {}));\n;\nconst ENCODERS = [\n    () => undefined,\n    () => new FFlateEncoder(),\n];\nexport default class Compressor {\n    applyEncoders(buffer, encoders) {\n        let resultBuffer = buffer;\n        encoders.forEach(encoder => {\n            resultBuffer = encoder.encode(resultBuffer);\n        });\n        return resultBuffer;\n    }\n    applyDecoders(buffer, decoders) {\n        let resultBuffer = buffer;\n        decoders.forEach(decoder => {\n            resultBuffer = decoder.decode(resultBuffer);\n        });\n        return resultBuffer;\n    }\n    /**\n     * Load json or text files and compress them into one big blob.\n     * This uses the default encoders.\n     *\n     * @param files files to load.\n     */\n    loadAndCompress(files) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const tokenizer = new Tokenizer();\n            const header = yield tokenizer.load(...files);\n            const reducer = new Reducer();\n            const dataStore = reducer.reduce(header);\n            return this.compressDataStore(dataStore);\n        });\n    }\n    /**\n     * Compress data into one big blob.\n     * This uses the default encoders.\n     *\n     * @param files files to load.\n     */\n    compress(data) {\n        const tokenizer = new Tokenizer();\n        const header = tokenizer.tokenize(data);\n        const reducer = new Reducer();\n        const dataStore = reducer.reduce(header);\n        return this.compressDataStore(dataStore);\n    }\n    loadAndExpand(file) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield fetch(file);\n            const arrayBuffer = yield response.arrayBuffer();\n            return this.expand(arrayBuffer);\n        });\n    }\n    expand(arrayBuffer, config) {\n        return new ExtractableData(this.expandDataStore(arrayBuffer), config);\n    }\n    compressDataStore(dataStore, encoderEnums = [EncoderEnum.FFLATE]) {\n        const streamDataView = new StreamDataView();\n        const tokenEncoder = new TokenEncoder(streamDataView);\n        //  Write header tokens\n        tokenEncoder.encodeTokens(dataStore.headerTokens);\n        //  Write fileNames\n        tokenEncoder.encodeNumberArray(dataStore.files);\n        const finalStream = new StreamDataView();\n        finalStream.setNextUint8(version.length);\n        finalStream.setNextString(version);\n        encoderEnums.forEach(encoderEnum => finalStream.setNextUint8(encoderEnum));\n        finalStream.setNextUint8(0);\n        const encoders = encoderEnums\n            .map(encoderEnum => ENCODERS[encoderEnum]())\n            .filter((encoder) => !!encoder);\n        //  Write header\n        const headerBuffer = this.applyEncoders(streamDataView.getBuffer(), encoders);\n        finalStream.setNextUint32(headerBuffer.byteLength);\n        finalStream.setNextBytes(headerBuffer);\n        //  Write each file's data tokens.\n        for (let index = 0; index < dataStore.files.length; index++) {\n            const subStream = new StreamDataView();\n            const subEncoder = new TokenEncoder(subStream);\n            subEncoder.encodeTokens(dataStore.getDataTokens(index));\n            //  save and compress buffer\n            const subBuffer = this.applyEncoders(subStream.getBuffer(), encoders);\n            finalStream.setNextUint32(subBuffer.byteLength);\n            finalStream.setNextBytes(subBuffer);\n        }\n        finalStream.setNextUint32(0);\n        return finalStream.getBuffer();\n    }\n    expandDataStore(arrayBuffer) {\n        let input = arrayBuffer;\n        const globalStream = new StreamDataView(input);\n        const compressedVersion = globalStream.getNextString(globalStream.getNextUint8());\n        if (compressedVersion != version) {\n            console.warn(`Compressor is v.%s but the data was compressed with v.%s`, version, compressedVersion);\n        }\n        const decoders = [];\n        do {\n            const encoderEnum = globalStream.getNextUint8();\n            if (encoderEnum === EncoderEnum.NONE) {\n                break;\n            }\n            const decoder = ENCODERS[encoderEnum]();\n            if (decoder) {\n                decoders.push(decoder);\n            }\n        } while (globalStream.getOffset() < globalStream.getLength());\n        const headerByteLength = globalStream.getNextUint32();\n        const headerBuffer = this.applyDecoders(globalStream.getNextBytes(headerByteLength).buffer, decoders);\n        const headerTokenEncoder = new TokenEncoder(new StreamDataView(headerBuffer));\n        const headerTokens = headerTokenEncoder.decodeTokens();\n        const files = headerTokenEncoder.decodeNumberArray();\n        const subBuffers = [];\n        do {\n            const byteLength = globalStream.getNextUint32();\n            if (!byteLength) {\n                break;\n            }\n            subBuffers.push(globalStream.getNextBytes(byteLength));\n        } while (globalStream.getOffset() < globalStream.getLength());\n        const getDataTokens = (index) => {\n            const subBuffer = this.applyDecoders(subBuffers[index], decoders);\n            const streamDataView = new StreamDataView(subBuffer);\n            const tokenDecoder = new TokenEncoder(streamDataView);\n            return tokenDecoder.decodeTokens();\n        };\n        return {\n            headerTokens,\n            files,\n            getDataTokens,\n        };\n    }\n}\n","import Loader from \"./io/Loader\";\nimport TokenEncoder from \"./compression/TokenEncoder\";\nimport Compressor from \"./compression/Compressor\";\nconst exportedClasses = {\n    Loader,\n    Compressor,\n    TokenEncoder,\n};\nexport default exportedClasses;\nglobalThis.exports = exportedClasses;\n"],"names":["charenc","utf8","stringToBytes","str","bin","unescape","encodeURIComponent","bytesToString","bytes","decodeURIComponent","escape","i","length","push","charCodeAt","String","fromCharCode","join","module","exports","base64map","crypt","rotl","n","b","rotr","endian","constructor","Number","randomBytes","Math","floor","random","bytesToWords","words","wordsToBytes","bytesToHex","hex","toString","hexToBytes","c","parseInt","substr","bytesToBase64","base64","triplet","j","charAt","base64ToBytes","replace","imod4","indexOf","pow","isBuffer","obj","readFloatLE","slice","isSlowBuffer","_isBuffer","md5","message","options","encoding","Array","prototype","call","isArray","Uint8Array","m","l","a","d","FF","_ff","GG","_gg","HH","_hh","II","_ii","aa","bb","cc","dd","x","s","t","_blocksize","_digestsize","Error","digestbytes","asBytes","asString","e","o","Object","defineProperty","enumerable","get","hasOwnProperty","r","Symbol","toStringTag","value","StreamDataView","this","decode","apply","from","encode","split","map","offset","autoResize","ArrayBuffer","view","DataView","littleEndian","fromByteString","fromTextString","setNextString","resize","TypeError","byteLength","set","buffer","getBuffer","crop","getOffset","skip","resetOffset","setOffset","getInt8","getUint8","getNextInt8","getNextUint8","getInt16","getUint16","getNextInt16","getNextUint16","getInt32","getUint32","getNextInt32","getNextUint32","getFloat32","getFloat64","getNextFloat32","getNextFloat64","setInt8","handleAutoResize","setUint8","setNextInt8","setNextUint8","setInt16","setUint16","setNextInt16","setNextUint16","setInt32","setUint32","setNextInt32","setNextUint32","setFloat32","setFloat64","setNextFloat32","setNextFloat64","getBytes","getNextBytes","setBytes","setNextBytes","getString","getNextString","setString","toByteString","toUpperCase","toTextString","getLength","clear","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","Loader","load","file","thisArg","_arguments","generator","response","fetch","pop","extension","json","text","P","Promise","resolve","reject","fulfilled","step","next","rejected","result","done","then","DataType","Tag","NUMBER_DATA_TYPES","UINT8","INT8","UINT16","INT16","UINT32","INT32","FLOAT32","FLOAT64","TokenEncoder","streamDataView","encodeTokens","tokens","pos","count","encodeMulti","encodeToken","encodeTag","DONE","decodeTokens","tagOrDataType","decodeTagOrDataType","MULTI","decodeMulti","decodeToken","token","dataType","usedDataType","encodeDataType","getDataType","UNDEFINED","NULL","BOOLEAN_TRUE","BOOLEAN_FALSE","encodeSingleNumber","STRING","UNICODE","encodeString","OBJECT_8","OBJECT_16","OBJECT_32","encodeObjectToken","SPLIT_8","SPLIT_16","SPLIT_32","encodeSplitToken","ARRAY_8","ARRAY_16","ARRAY_32","OFFSET_ARRAY_8","OFFSET_ARRAY_16","OFFSET_ARRAY_32","encodeArrayToken","decodeDataType","type","decodeSingleNumber","decodeString","decodeObjectToken","decodeSplitToken","decodeArrayToken","isOffsetDataType","arrayToken","numberType","indices","min","encodeNumberArray","decodeNumberArray","objectToken","keysIndex","valuesIndex","splitToken","chunksIndex","separatorsIndex","tag","decodeTag","firstType","multiCount","maxCount","getNumberDataType","numberSatisfyDataType","fround","getBestType","array","some","number","every","max","size","bestType","numbers","getStringDataType","code","dataTypeToType","letterCodes","forEach","charCodes","static","tokenEncoder","tokenDecoder","reset","testAction","header","string","tester","check","console","assert","JSON","stringify","decoded","Reducer","debug","reduce","hashToIndex","headerTokens","createReducedTokens","values","registry","filter","files","has","fileEntries","entries","sort","name1","name2","localeCompare","nameToken","hash","dataTokens","root","subHashToIndex","assign","concat","getDataTokens","index","sortedTokens","t1","t2","_a","_b","reference","u8","u16","Uint16Array","u32","Uint32Array","fleb","fdeb","clim","freb","eb","start","fl","revfl","fd","revfd","rev","hMap","cd","mb","co","le","rvb","sv","r_1","v","flt","fdt","flm","flrm","fdm","fdrm","bits","p","bits16","shft","slc","BYTES_PER_ELEMENT","subarray","ec","err","ind","msg","nt","captureStackTrace","wbits","wbits16","hTree","f","et","i0","i1","i2","maxSym","tr","mbt","ln","dt","lft","cst","i2_1","i2_2","i2_3","lc","cl","cli","cln","cls","w","clen","cf","wfblk","out","dat","wblk","final","syms","lf","df","li","bs","bl","dlt","mlb","ddt","mdb","_c","lclt","nlc","_d","lcdt","ndc","lcfreq","_e","lct","mlcb","nlcc","lm","ll","dm","dl","flen","ftlen","dtlen","llm","lcts","it","clct","len","dst","deo","crct","Int32Array","k","dopt","opt","pre","post","st","lvl","plvl","lst","ceil","msk_1","prev","head","bs1_1","bs2_1","hsh","lc_1","wi","hv","imod","pimod","rem","ch_1","dif","maxn","maxd","ml","nl","mmd","md","ti","lin","din","dflt","level","mem","log","wbytes","gzipSync","data","opts","cr","crc","filename","fn","mtime","Date","now","gzh","gunzipSync","buf","sl","noBuf","noSt","cbuf","nbuf","bt","lbt","dbt","tbts","hLit","hcLen","tl","ldt","clt","clb","clbmsk","clm","lt","lms","dms","lpos","sym","add","dsym","end","inflt","flg","zs","gzs","td","TextDecoder","stream","queueMicrotask","setTimeout","FFlateEncoder","arrayBuffer","SPLIT_REGEX","TEST_REGEX","getType","test","Tokenizer","loader","sortedFiles","allData","all","tokenize","fromEntries","items","counter","tokenizeHelper","registerToken","entry","order","Set","item","hashes","keysToken","key","valuesToken","chunks","separators","match","chunksToken","separatorsToken","DEFAULT_CONFIG","cacheable","allowReferences","ExtractableData","dataStore","config","extractor","Extractor","fileNames","extractFileNames","fileToSlot","extract","slot","valueFetcher","getArray","bind","getObject","getSplit","extractToken","forceAllowUseCache","extractValueOrCache","keyIndex","valueIndex","keys","chunk","allowUseCache","getValue","cache","EncoderEnum","ENCODERS","exportedClasses","Compressor","applyEncoders","encoders","resultBuffer","encoder","applyDecoders","decoders","decoder","loadAndCompress","tokenizer","compressDataStore","compress","loadAndExpand","expand","expandDataStore","encoderEnums","FFLATE","finalStream","encoderEnum","headerBuffer","subStream","subBuffer","input","globalStream","compressedVersion","warn","NONE","headerByteLength","headerTokenEncoder","subBuffers","globalThis"],"sourceRoot":""}