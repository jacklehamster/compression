{"version":3,"file":"main.js","mappings":"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","sources":["webpack://@dobuki/compression/./node_modules/blueimp-md5/js/md5.js","webpack://@dobuki/compression/./node_modules/stream-data-view/dist/index.js","webpack://@dobuki/compression/webpack/bootstrap","webpack://@dobuki/compression/webpack/runtime/compat get default export","webpack://@dobuki/compression/webpack/runtime/define property getters","webpack://@dobuki/compression/webpack/runtime/hasOwnProperty shorthand","webpack://@dobuki/compression/./src/io/Loader.ts","webpack://@dobuki/compression/./src/compression/DataType.ts","webpack://@dobuki/compression/./src/compression/TokenEncoder.ts","webpack://@dobuki/compression/./src/reducer/Reducer.ts","webpack://@dobuki/compression/./node_modules/fflate/esm/browser.js","webpack://@dobuki/compression/./src/compression/FFlateEncoder.ts","webpack://@dobuki/compression/./src/tokenizer/Token.ts","webpack://@dobuki/compression/./src/tokenizer/Tokenizer.ts","webpack://@dobuki/compression/./src/expander/Extractor.ts","webpack://@dobuki/compression/./src/compression/Compressor.ts","webpack://@dobuki/compression/./src/index.ts"],"sourcesContent":["/*\n * JavaScript MD5\n * https://github.com/blueimp/JavaScript-MD5\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n *\n * Based on\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n * Digest Algorithm, as defined in RFC 1321.\n * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for more info.\n */\n\n/* global define */\n\n/* eslint-disable strict */\n\n;(function ($) {\n  'use strict'\n\n  /**\n   * Add integers, wrapping at 2^32.\n   * This uses 16-bit operations internally to work around bugs in interpreters.\n   *\n   * @param {number} x First integer\n   * @param {number} y Second integer\n   * @returns {number} Sum\n   */\n  function safeAdd(x, y) {\n    var lsw = (x & 0xffff) + (y & 0xffff)\n    var msw = (x >> 16) + (y >> 16) + (lsw >> 16)\n    return (msw << 16) | (lsw & 0xffff)\n  }\n\n  /**\n   * Bitwise rotate a 32-bit number to the left.\n   *\n   * @param {number} num 32-bit number\n   * @param {number} cnt Rotation count\n   * @returns {number} Rotated number\n   */\n  function bitRotateLeft(num, cnt) {\n    return (num << cnt) | (num >>> (32 - cnt))\n  }\n\n  /**\n   * Basic operation the algorithm uses.\n   *\n   * @param {number} q q\n   * @param {number} a a\n   * @param {number} b b\n   * @param {number} x x\n   * @param {number} s s\n   * @param {number} t t\n   * @returns {number} Result\n   */\n  function md5cmn(q, a, b, x, s, t) {\n    return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b)\n  }\n  /**\n   * Basic operation the algorithm uses.\n   *\n   * @param {number} a a\n   * @param {number} b b\n   * @param {number} c c\n   * @param {number} d d\n   * @param {number} x x\n   * @param {number} s s\n   * @param {number} t t\n   * @returns {number} Result\n   */\n  function md5ff(a, b, c, d, x, s, t) {\n    return md5cmn((b & c) | (~b & d), a, b, x, s, t)\n  }\n  /**\n   * Basic operation the algorithm uses.\n   *\n   * @param {number} a a\n   * @param {number} b b\n   * @param {number} c c\n   * @param {number} d d\n   * @param {number} x x\n   * @param {number} s s\n   * @param {number} t t\n   * @returns {number} Result\n   */\n  function md5gg(a, b, c, d, x, s, t) {\n    return md5cmn((b & d) | (c & ~d), a, b, x, s, t)\n  }\n  /**\n   * Basic operation the algorithm uses.\n   *\n   * @param {number} a a\n   * @param {number} b b\n   * @param {number} c c\n   * @param {number} d d\n   * @param {number} x x\n   * @param {number} s s\n   * @param {number} t t\n   * @returns {number} Result\n   */\n  function md5hh(a, b, c, d, x, s, t) {\n    return md5cmn(b ^ c ^ d, a, b, x, s, t)\n  }\n  /**\n   * Basic operation the algorithm uses.\n   *\n   * @param {number} a a\n   * @param {number} b b\n   * @param {number} c c\n   * @param {number} d d\n   * @param {number} x x\n   * @param {number} s s\n   * @param {number} t t\n   * @returns {number} Result\n   */\n  function md5ii(a, b, c, d, x, s, t) {\n    return md5cmn(c ^ (b | ~d), a, b, x, s, t)\n  }\n\n  /**\n   * Calculate the MD5 of an array of little-endian words, and a bit length.\n   *\n   * @param {Array} x Array of little-endian words\n   * @param {number} len Bit length\n   * @returns {Array<number>} MD5 Array\n   */\n  function binlMD5(x, len) {\n    /* append padding */\n    x[len >> 5] |= 0x80 << len % 32\n    x[(((len + 64) >>> 9) << 4) + 14] = len\n\n    var i\n    var olda\n    var oldb\n    var oldc\n    var oldd\n    var a = 1732584193\n    var b = -271733879\n    var c = -1732584194\n    var d = 271733878\n\n    for (i = 0; i < x.length; i += 16) {\n      olda = a\n      oldb = b\n      oldc = c\n      oldd = d\n\n      a = md5ff(a, b, c, d, x[i], 7, -680876936)\n      d = md5ff(d, a, b, c, x[i + 1], 12, -389564586)\n      c = md5ff(c, d, a, b, x[i + 2], 17, 606105819)\n      b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330)\n      a = md5ff(a, b, c, d, x[i + 4], 7, -176418897)\n      d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426)\n      c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341)\n      b = md5ff(b, c, d, a, x[i + 7], 22, -45705983)\n      a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416)\n      d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417)\n      c = md5ff(c, d, a, b, x[i + 10], 17, -42063)\n      b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162)\n      a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682)\n      d = md5ff(d, a, b, c, x[i + 13], 12, -40341101)\n      c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290)\n      b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329)\n\n      a = md5gg(a, b, c, d, x[i + 1], 5, -165796510)\n      d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632)\n      c = md5gg(c, d, a, b, x[i + 11], 14, 643717713)\n      b = md5gg(b, c, d, a, x[i], 20, -373897302)\n      a = md5gg(a, b, c, d, x[i + 5], 5, -701558691)\n      d = md5gg(d, a, b, c, x[i + 10], 9, 38016083)\n      c = md5gg(c, d, a, b, x[i + 15], 14, -660478335)\n      b = md5gg(b, c, d, a, x[i + 4], 20, -405537848)\n      a = md5gg(a, b, c, d, x[i + 9], 5, 568446438)\n      d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690)\n      c = md5gg(c, d, a, b, x[i + 3], 14, -187363961)\n      b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501)\n      a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467)\n      d = md5gg(d, a, b, c, x[i + 2], 9, -51403784)\n      c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473)\n      b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734)\n\n      a = md5hh(a, b, c, d, x[i + 5], 4, -378558)\n      d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463)\n      c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562)\n      b = md5hh(b, c, d, a, x[i + 14], 23, -35309556)\n      a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060)\n      d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353)\n      c = md5hh(c, d, a, b, x[i + 7], 16, -155497632)\n      b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640)\n      a = md5hh(a, b, c, d, x[i + 13], 4, 681279174)\n      d = md5hh(d, a, b, c, x[i], 11, -358537222)\n      c = md5hh(c, d, a, b, x[i + 3], 16, -722521979)\n      b = md5hh(b, c, d, a, x[i + 6], 23, 76029189)\n      a = md5hh(a, b, c, d, x[i + 9], 4, -640364487)\n      d = md5hh(d, a, b, c, x[i + 12], 11, -421815835)\n      c = md5hh(c, d, a, b, x[i + 15], 16, 530742520)\n      b = md5hh(b, c, d, a, x[i + 2], 23, -995338651)\n\n      a = md5ii(a, b, c, d, x[i], 6, -198630844)\n      d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415)\n      c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905)\n      b = md5ii(b, c, d, a, x[i + 5], 21, -57434055)\n      a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571)\n      d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606)\n      c = md5ii(c, d, a, b, x[i + 10], 15, -1051523)\n      b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799)\n      a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359)\n      d = md5ii(d, a, b, c, x[i + 15], 10, -30611744)\n      c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380)\n      b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649)\n      a = md5ii(a, b, c, d, x[i + 4], 6, -145523070)\n      d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379)\n      c = md5ii(c, d, a, b, x[i + 2], 15, 718787259)\n      b = md5ii(b, c, d, a, x[i + 9], 21, -343485551)\n\n      a = safeAdd(a, olda)\n      b = safeAdd(b, oldb)\n      c = safeAdd(c, oldc)\n      d = safeAdd(d, oldd)\n    }\n    return [a, b, c, d]\n  }\n\n  /**\n   * Convert an array of little-endian words to a string\n   *\n   * @param {Array<number>} input MD5 Array\n   * @returns {string} MD5 string\n   */\n  function binl2rstr(input) {\n    var i\n    var output = ''\n    var length32 = input.length * 32\n    for (i = 0; i < length32; i += 8) {\n      output += String.fromCharCode((input[i >> 5] >>> i % 32) & 0xff)\n    }\n    return output\n  }\n\n  /**\n   * Convert a raw string to an array of little-endian words\n   * Characters >255 have their high-byte silently ignored.\n   *\n   * @param {string} input Raw input string\n   * @returns {Array<number>} Array of little-endian words\n   */\n  function rstr2binl(input) {\n    var i\n    var output = []\n    output[(input.length >> 2) - 1] = undefined\n    for (i = 0; i < output.length; i += 1) {\n      output[i] = 0\n    }\n    var length8 = input.length * 8\n    for (i = 0; i < length8; i += 8) {\n      output[i >> 5] |= (input.charCodeAt(i / 8) & 0xff) << i % 32\n    }\n    return output\n  }\n\n  /**\n   * Calculate the MD5 of a raw string\n   *\n   * @param {string} s Input string\n   * @returns {string} Raw MD5 string\n   */\n  function rstrMD5(s) {\n    return binl2rstr(binlMD5(rstr2binl(s), s.length * 8))\n  }\n\n  /**\n   * Calculates the HMAC-MD5 of a key and some data (raw strings)\n   *\n   * @param {string} key HMAC key\n   * @param {string} data Raw input string\n   * @returns {string} Raw MD5 string\n   */\n  function rstrHMACMD5(key, data) {\n    var i\n    var bkey = rstr2binl(key)\n    var ipad = []\n    var opad = []\n    var hash\n    ipad[15] = opad[15] = undefined\n    if (bkey.length > 16) {\n      bkey = binlMD5(bkey, key.length * 8)\n    }\n    for (i = 0; i < 16; i += 1) {\n      ipad[i] = bkey[i] ^ 0x36363636\n      opad[i] = bkey[i] ^ 0x5c5c5c5c\n    }\n    hash = binlMD5(ipad.concat(rstr2binl(data)), 512 + data.length * 8)\n    return binl2rstr(binlMD5(opad.concat(hash), 512 + 128))\n  }\n\n  /**\n   * Convert a raw string to a hex string\n   *\n   * @param {string} input Raw input string\n   * @returns {string} Hex encoded string\n   */\n  function rstr2hex(input) {\n    var hexTab = '0123456789abcdef'\n    var output = ''\n    var x\n    var i\n    for (i = 0; i < input.length; i += 1) {\n      x = input.charCodeAt(i)\n      output += hexTab.charAt((x >>> 4) & 0x0f) + hexTab.charAt(x & 0x0f)\n    }\n    return output\n  }\n\n  /**\n   * Encode a string as UTF-8\n   *\n   * @param {string} input Input string\n   * @returns {string} UTF8 string\n   */\n  function str2rstrUTF8(input) {\n    return unescape(encodeURIComponent(input))\n  }\n\n  /**\n   * Encodes input string as raw MD5 string\n   *\n   * @param {string} s Input string\n   * @returns {string} Raw MD5 string\n   */\n  function rawMD5(s) {\n    return rstrMD5(str2rstrUTF8(s))\n  }\n  /**\n   * Encodes input string as Hex encoded string\n   *\n   * @param {string} s Input string\n   * @returns {string} Hex encoded string\n   */\n  function hexMD5(s) {\n    return rstr2hex(rawMD5(s))\n  }\n  /**\n   * Calculates the raw HMAC-MD5 for the given key and data\n   *\n   * @param {string} k HMAC key\n   * @param {string} d Input string\n   * @returns {string} Raw MD5 string\n   */\n  function rawHMACMD5(k, d) {\n    return rstrHMACMD5(str2rstrUTF8(k), str2rstrUTF8(d))\n  }\n  /**\n   * Calculates the Hex encoded HMAC-MD5 for the given key and data\n   *\n   * @param {string} k HMAC key\n   * @param {string} d Input string\n   * @returns {string} Raw MD5 string\n   */\n  function hexHMACMD5(k, d) {\n    return rstr2hex(rawHMACMD5(k, d))\n  }\n\n  /**\n   * Calculates MD5 value for a given string.\n   * If a key is provided, calculates the HMAC-MD5 value.\n   * Returns a Hex encoded string unless the raw argument is given.\n   *\n   * @param {string} string Input string\n   * @param {string} [key] HMAC key\n   * @param {boolean} [raw] Raw output switch\n   * @returns {string} MD5 output\n   */\n  function md5(string, key, raw) {\n    if (!key) {\n      if (!raw) {\n        return hexMD5(string)\n      }\n      return rawMD5(string)\n    }\n    if (!raw) {\n      return hexHMACMD5(key, string)\n    }\n    return rawHMACMD5(key, string)\n  }\n\n  if (typeof define === 'function' && define.amd) {\n    define(function () {\n      return md5\n    })\n  } else if (typeof module === 'object' && module.exports) {\n    module.exports = md5\n  } else {\n    $.md5 = md5\n  }\n})(this)\n","!function(t,e){if(\"object\"==typeof exports&&\"object\"==typeof module)module.exports=e();else if(\"function\"==typeof define&&define.amd)define([],e);else{var n=e();for(var i in n)(\"object\"==typeof exports?exports:t)[i]=n[i]}}(this,(function(){return(()=>{\"use strict\";var t={d:(e,n)=>{for(var i in n)t.o(n,i)&&!t.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:n[i]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(t,\"__esModule\",{value:!0})}},e={};t.r(e),t.d(e,{StreamDataView:()=>o});var n=function(){function t(t){this.encoding=t||\"utf-8\"}return t.prototype.decode=function(t){var e=String.fromCharCode.apply(null,Array.from(t));return\"utf-8\"===this.encoding?decodeURIComponent(escape(e)):e},t}(),i=function(){function t(t){this.encoding=t||\"utf-8\"}return t.prototype.encode=function(t){return\"utf-8\"===this.encoding&&(t=unescape(encodeURIComponent(t))),new Uint8Array(t.split(\"\").map((function(t){return t.charCodeAt(0)})))},t}(),o=function(){function t(t,e){this.offset=0,this.autoResize=!1,void 0===t&&(t=0,this.autoResize=!0),\"number\"==typeof t&&(t=new ArrayBuffer(t)),this.view=new DataView(t),this.littleEndian=!e}return t.fromByteString=function(e){var n=new t(e.split(\" \").length);return n.fromByteString(e),n},t.fromTextString=function(e,n){var o,s=new t((o=n?new i(\"utf-8\").encode(e):new i(\"ascii\").encode(e)).length);return s.setNextString(e,n,o.length),s},t.prototype.resize=function(t){var e=function(t,e){if(!(t instanceof ArrayBuffer))throw new TypeError(\"Source must be an instance of ArrayBuffer\");if(e<=t.byteLength)return t.slice(0,e);var n=new Uint8Array(t),i=new Uint8Array(new ArrayBuffer(e));return i.set(n),i.buffer}(this.getBuffer(),t);this.view=new DataView(e)},t.prototype.crop=function(){this.resize(this.getOffset())},t.prototype.getBuffer=function(){return this.view.buffer},t.prototype.skip=function(t){this.offset+=t},t.prototype.resetOffset=function(){this.offset=0},t.prototype.getOffset=function(){return this.offset},t.prototype.setOffset=function(t){this.offset=t},t.prototype.getInt8=function(t){return this.view.getInt8(t)},t.prototype.getUint8=function(t){return this.view.getUint8(t)},t.prototype.getNextInt8=function(){var t=this.getInt8(this.offset);return this.offset+=1,t},t.prototype.getNextUint8=function(){var t=this.getUint8(this.offset);return this.offset+=1,t},t.prototype.getInt16=function(t){return this.view.getInt16(t,this.littleEndian)},t.prototype.getUint16=function(t){return this.view.getUint16(t,this.littleEndian)},t.prototype.getNextInt16=function(){var t=this.getInt16(this.offset);return this.offset+=2,t},t.prototype.getNextUint16=function(){var t=this.getUint16(this.offset);return this.offset+=2,t},t.prototype.getInt32=function(t){return this.view.getInt32(t,this.littleEndian)},t.prototype.getUint32=function(t){return this.view.getUint32(t,this.littleEndian)},t.prototype.getNextInt32=function(){var t=this.getInt32(this.offset);return this.offset+=4,t},t.prototype.getNextUint32=function(){var t=this.getUint32(this.offset);return this.offset+=4,t},t.prototype.getFloat32=function(t){return this.view.getFloat32(t,this.littleEndian)},t.prototype.getFloat64=function(t){return this.view.getFloat64(t,this.littleEndian)},t.prototype.getNextFloat32=function(){var t=this.getFloat32(this.offset);return this.offset+=4,t},t.prototype.getNextFloat64=function(){var t=this.getFloat64(this.offset);return this.offset+=8,t},t.prototype.setInt8=function(t,e){this.handleAutoResize(t,1),this.view.setInt8(t,e)},t.prototype.setUint8=function(t,e){this.handleAutoResize(t,1),this.view.setUint8(t,e)},t.prototype.setNextInt8=function(t){this.setInt8(this.offset,t),this.offset+=1},t.prototype.setNextUint8=function(t){this.setUint8(this.offset,t),this.offset+=1},t.prototype.setInt16=function(t,e){this.handleAutoResize(t,2),this.view.setInt16(t,e,this.littleEndian)},t.prototype.setUint16=function(t,e){this.handleAutoResize(t,2),this.view.setUint16(t,e,this.littleEndian)},t.prototype.setNextInt16=function(t){this.setInt16(this.offset,t),this.offset+=2},t.prototype.setNextUint16=function(t){this.setUint16(this.offset,t),this.offset+=2},t.prototype.setInt32=function(t,e){this.handleAutoResize(t,4),this.view.setInt32(t,e,this.littleEndian)},t.prototype.setUint32=function(t,e){this.handleAutoResize(t,4),this.view.setUint32(t,e,this.littleEndian)},t.prototype.setNextInt32=function(t){this.setInt32(this.offset,t),this.offset+=4},t.prototype.setNextUint32=function(t){this.setUint32(this.offset,t),this.offset+=4},t.prototype.setFloat32=function(t,e){this.handleAutoResize(t,8),this.view.setFloat32(t,e,this.littleEndian)},t.prototype.setFloat64=function(t,e){this.handleAutoResize(t,8),this.view.setFloat64(t,e,this.littleEndian)},t.prototype.setNextFloat32=function(t){this.setFloat32(this.offset,t),this.offset+=4},t.prototype.setNextFloat64=function(t){this.setFloat64(this.offset,t),this.offset+=8},t.prototype.getBytes=function(t,e){void 0===t&&(t=0),e=e||this.view.buffer.byteLength-t;var n=this.getBuffer().slice(t,t+e);return new Uint8Array(n)},t.prototype.getNextBytes=function(t){var e=this.getBytes(this.offset,t);return this.offset+=t||0,e},t.prototype.setBytes=function(t,e){(e instanceof ArrayBuffer||Array.isArray(e))&&(e=new Uint8Array(e));var n=e;this.handleAutoResize(t,n.byteLength);for(var i=0;i<n.byteLength;i++)this.setUint8(t+i,n[i])},t.prototype.setNextBytes=function(t){Array.isArray(t)&&(t=new Uint8Array(t)),this.setBytes(this.offset,t),this.offset+=t.byteLength},t.prototype.getString=function(t,e,i,o){var s=this.getBytes(t,e);if(o){var r=s.indexOf(0);r>=0&&(s=s.slice(0,r))}return i?new n(\"utf-8\").decode(s):new n(\"ascii\").decode(s)},t.prototype.getNextString=function(t,e,n){var i=this.getString(this.offset,t,e,n);return this.offset+=t,i},t.prototype.setString=function(t,e,n,o){var s;s=n?new i(\"utf-8\").encode(e):new i(\"ascii\").encode(e),o=\"number\"==typeof o?o:s.byteLength,this.handleAutoResize(t,o);for(var r=0;r<o;r++)this.view.setUint8(t+r,s[r]||0);return o},t.prototype.setNextString=function(t,e,n){this.offset+=this.setString(this.offset,t,e,n)},t.prototype.toByteString=function(){return Array.from(new Uint8Array(this.getBuffer())).map((function(t){return(\"00\"+t.toString(16)).slice(-2)})).join(\" \").toUpperCase()},t.prototype.toTextString=function(t){return this.getString(0,this.view.byteLength,t)},t.prototype.fromByteString=function(t){var e=t.split(\" \"),n=new ArrayBuffer(e.length);this.view=new DataView(n),this.setNextBytes(new Uint8Array(e.map((function(t){return parseInt(t,16)})))),this.resetOffset()},t.prototype.getLength=function(){return this.view.byteLength},t.prototype.clear=function(){this.view=new DataView(new ArrayBuffer(this.view.byteLength)),this.offset=0},t.prototype.handleAutoResize=function(t,e){this.autoResize&&this.getBuffer().byteLength<t+e&&this.resize(t+e)},t}();return e})()}));","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nfunction extension(file) {\n    return file.split(\".\").pop();\n}\nexport default class Loader {\n    load(file) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield fetch(file);\n            return extension(file) === \"json\" ? yield response.json() : yield response.text();\n        });\n    }\n}\n","export var DataType;\n(function (DataType) {\n    DataType[DataType[\"UNDEFINED\"] = 0] = \"UNDEFINED\";\n    DataType[DataType[\"NULL\"] = 1] = \"NULL\";\n    DataType[DataType[\"BOOLEAN_FALSE\"] = 2] = \"BOOLEAN_FALSE\";\n    DataType[DataType[\"BOOLEAN_TRUE\"] = 3] = \"BOOLEAN_TRUE\";\n    DataType[DataType[\"INT8\"] = 4] = \"INT8\";\n    DataType[DataType[\"UINT8\"] = 5] = \"UINT8\";\n    DataType[DataType[\"INT16\"] = 6] = \"INT16\";\n    DataType[DataType[\"UINT16\"] = 7] = \"UINT16\";\n    DataType[DataType[\"INT32\"] = 8] = \"INT32\";\n    DataType[DataType[\"UINT32\"] = 9] = \"UINT32\";\n    DataType[DataType[\"FLOAT32\"] = 10] = \"FLOAT32\";\n    DataType[DataType[\"FLOAT64\"] = 11] = \"FLOAT64\";\n    DataType[DataType[\"STRING\"] = 12] = \"STRING\";\n    DataType[DataType[\"UNICODE\"] = 13] = \"UNICODE\";\n    DataType[DataType[\"OBJECT_8\"] = 17] = \"OBJECT_8\";\n    DataType[DataType[\"OBJECT_16\"] = 18] = \"OBJECT_16\";\n    DataType[DataType[\"OBJECT_32\"] = 19] = \"OBJECT_32\";\n    DataType[DataType[\"SPLIT_8\"] = 20] = \"SPLIT_8\";\n    DataType[DataType[\"SPLIT_16\"] = 21] = \"SPLIT_16\";\n    DataType[DataType[\"SPLIT_32\"] = 22] = \"SPLIT_32\";\n    DataType[DataType[\"ARRAY_8\"] = 23] = \"ARRAY_8\";\n    DataType[DataType[\"ARRAY_16\"] = 24] = \"ARRAY_16\";\n    DataType[DataType[\"ARRAY_32\"] = 25] = \"ARRAY_32\";\n    DataType[DataType[\"OFFSET_ARRAY_8\"] = 26] = \"OFFSET_ARRAY_8\";\n    DataType[DataType[\"OFFSET_ARRAY_16\"] = 27] = \"OFFSET_ARRAY_16\";\n    DataType[DataType[\"OFFSET_ARRAY_32\"] = 28] = \"OFFSET_ARRAY_32\";\n    DataType[DataType[\"EMPTY_ARRAY\"] = 29] = \"EMPTY_ARRAY\";\n    DataType[DataType[\"REFERENCE_8\"] = 30] = \"REFERENCE_8\";\n    DataType[DataType[\"REFERENCE_16\"] = 31] = \"REFERENCE_16\";\n    DataType[DataType[\"REFERENCE_32\"] = 32] = \"REFERENCE_32\";\n    DataType[DataType[\"COMPLEX_OBJECT\"] = 33] = \"COMPLEX_OBJECT\";\n})(DataType || (DataType = {}));\nexport const NUMBER_DATA_TYPES = [\n    DataType.UINT8,\n    DataType.INT8,\n    DataType.UINT16,\n    DataType.INT16,\n    DataType.UINT32,\n    DataType.INT32,\n    DataType.FLOAT32,\n    DataType.FLOAT64,\n];\nexport class DataTypeUtils {\n    numberSatisfyDataType(value, dataType) {\n        const hasDecimal = value % 1 !== 0;\n        if (hasDecimal) {\n            switch (dataType) {\n                case DataType.FLOAT32:\n                    return Math.fround(value) === value;\n                case DataType.FLOAT64:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n        switch (dataType) {\n            case DataType.UINT8:\n                return value >= 0 && value <= 255;\n            case DataType.INT8:\n                return value >= -128 && value <= 127;\n            case DataType.UINT16:\n                return value >= 0 && value <= 65535;\n            case DataType.INT16:\n                return value >= -32768 && value <= 32767;\n            case DataType.UINT32:\n                return value >= 0;\n            case DataType.INT32:\n                return true;\n        }\n        return false;\n    }\n    getBestType(array) {\n        if (array.some(number => number % 1 !== 0)) {\n            //  decimal\n            if (array.every(number => this.numberSatisfyDataType(number, DataType.FLOAT32))) {\n                return DataType.FLOAT32;\n            }\n            return DataType.FLOAT64;\n        }\n        const min = Math.min(...array);\n        const max = Math.max(...array);\n        for (let dataType of NUMBER_DATA_TYPES) {\n            if (this.numberSatisfyDataType(min, dataType) && this.numberSatisfyDataType(max, dataType)) {\n                return dataType;\n            }\n        }\n        return DataType.FLOAT64;\n    }\n    getNumberDataType(value) {\n        for (let type of NUMBER_DATA_TYPES) {\n            if (this.numberSatisfyDataType(value, type)) {\n                return type;\n            }\n        }\n        return DataType.UNDEFINED;\n    }\n    getStringDataType(value) {\n        const letterCodes = value.split(\"\").map(l => l.charCodeAt(0));\n        if (letterCodes.every(code => code <= 255)) {\n            return DataType.STRING;\n        }\n        else {\n            return DataType.UNICODE;\n        }\n    }\n    getFullTokenDataType(token) {\n        switch (token.type) {\n            case \"array\":\n                return DataType.ARRAY_8;\n            case \"object\":\n                return DataType.OBJECT_8;\n            case \"split\":\n                return DataType.SPLIT_8;\n            default:\n                return this.getDataType(token);\n        }\n    }\n    getDataType(token) {\n        switch (token.type) {\n            case \"array\":\n            case \"object\":\n            case \"split\":\n                let indices = token.value;\n                if (!indices.length) {\n                    console.assert(token.type === \"array\");\n                    return DataType.EMPTY_ARRAY;\n                }\n                let offset = 0;\n                if (token.type === \"array\" && indices.length > 3) {\n                    const min = Math.min(...indices);\n                    const max = Math.max(...indices);\n                    if (this.getNumberDataType(max - min) !== this.getNumberDataType(max)) {\n                        offset = min;\n                    }\n                    indices = indices.map(value => value - offset);\n                }\n                const bestType = this.getBestType(indices);\n                switch (token.type) {\n                    case \"object\":\n                        return bestType === DataType.UINT8\n                            ? DataType.OBJECT_8\n                            : bestType === DataType.UINT16\n                                ? DataType.OBJECT_16\n                                : DataType.OBJECT_32;\n                    case \"split\":\n                        return bestType === DataType.UINT8\n                            ? DataType.SPLIT_8\n                            : bestType === DataType.UINT16\n                                ? DataType.SPLIT_16\n                                : DataType.SPLIT_32;\n                    case \"array\":\n                        if (offset) {\n                            return bestType === DataType.UINT8\n                                ? DataType.OFFSET_ARRAY_8\n                                : bestType === DataType.UINT16\n                                    ? DataType.OFFSET_ARRAY_16\n                                    : DataType.OFFSET_ARRAY_32;\n                        }\n                        else {\n                            return bestType === DataType.UINT8\n                                ? DataType.ARRAY_8\n                                : bestType === DataType.UINT16\n                                    ? DataType.ARRAY_16\n                                    : DataType.ARRAY_32;\n                        }\n                }\n            case \"leaf\":\n                if (token.value === undefined) {\n                    return DataType.UNDEFINED;\n                }\n                else if (token.value === null) {\n                    return DataType.NULL;\n                }\n                else {\n                    switch (typeof token.value) {\n                        case \"boolean\":\n                            return token.value ? DataType.BOOLEAN_TRUE : DataType.BOOLEAN_FALSE;\n                        case \"string\":\n                            return this.getStringDataType(token.value);\n                        case \"number\":\n                            return this.getNumberDataType(token.value);\n                    }\n                }\n                break;\n            case \"reference\":\n                switch (this.getNumberDataType(token.value)) {\n                    case DataType.UINT8:\n                        return DataType.REFERENCE_8;\n                    case DataType.UINT16:\n                        return DataType.REFERENCE_16;\n                    case DataType.UINT32:\n                        return DataType.REFERENCE_32;\n                }\n                throw new Error(\"Invalid reference value: \" + token.value);\n        }\n        throw new Error(`Unrecognized type for ${token.type} value: ${token.value}`);\n    }\n    dataTypeToType(dataType) {\n        switch (dataType) {\n            case DataType.EMPTY_ARRAY:\n            case DataType.ARRAY_8:\n            case DataType.ARRAY_16:\n            case DataType.ARRAY_32:\n                return \"array\";\n            case DataType.OBJECT_8:\n            case DataType.OBJECT_16:\n            case DataType.OBJECT_32:\n                return \"object\";\n            case DataType.SPLIT_8:\n            case DataType.SPLIT_16:\n            case DataType.SPLIT_32:\n                return \"split\";\n            case DataType.REFERENCE_8:\n            case DataType.REFERENCE_16:\n            case DataType.REFERENCE_32:\n                return \"reference\";\n            default:\n                return \"leaf\";\n        }\n    }\n}\n","//18033\nimport { StreamDataView } from \"stream-data-view\";\nimport { DataType, DataTypeUtils } from \"./DataType\";\nexport default class TokenEncoder {\n    constructor(streamDataView) {\n        this.dataTypeUtils = new DataTypeUtils();\n        this.streamDataView = streamDataView;\n    }\n    encodeTokens(tokens) {\n        let pos = 0;\n        while (pos < tokens.length) {\n            const count = this.encodeMulti(tokens, pos);\n            if (count) {\n                pos += count;\n            }\n        }\n        this.encodeMulti([], pos);\n    }\n    decodeTokens() {\n        const tokens = [];\n        while (this.streamDataView.getOffset() < this.streamDataView.getLength()) {\n            if (!this.decodeMulti(tokens)) {\n                break;\n            }\n        }\n        return tokens;\n    }\n    encodeToken(token, dataType, multiInfo) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.encodeDataType(this.dataTypeUtils.getDataType(token));\n        switch (usedDataType) {\n            case DataType.UNDEFINED:\n            case DataType.NULL:\n            case DataType.BOOLEAN_TRUE:\n            case DataType.BOOLEAN_FALSE:\n            case DataType.EMPTY_ARRAY:\n                break;\n            case DataType.INT8:\n            case DataType.UINT8:\n            case DataType.INT16:\n            case DataType.UINT16:\n            case DataType.INT32:\n            case DataType.UINT32:\n            case DataType.FLOAT32:\n            case DataType.FLOAT64:\n                this.encodeSingleNumber(token.value, usedDataType);\n                break;\n            case DataType.STRING:\n            case DataType.UNICODE:\n                this.encodeString(token.value, usedDataType, multiInfo);\n                break;\n            case DataType.OBJECT_8:\n            case DataType.OBJECT_16:\n            case DataType.OBJECT_32:\n                this.encodeObjectToken(token, usedDataType);\n                break;\n            case DataType.SPLIT_8:\n            case DataType.SPLIT_16:\n            case DataType.SPLIT_32:\n                this.encodeSplitToken(token, usedDataType);\n                break;\n            case DataType.ARRAY_8:\n            case DataType.ARRAY_16:\n            case DataType.ARRAY_32:\n            case DataType.OFFSET_ARRAY_8:\n            case DataType.OFFSET_ARRAY_16:\n            case DataType.OFFSET_ARRAY_32:\n                this.encodeArrayToken(token, usedDataType);\n                break;\n            case DataType.REFERENCE_8:\n            case DataType.REFERENCE_16:\n            case DataType.REFERENCE_32:\n                this.encodeReferenceToken(token, usedDataType);\n                break;\n            default:\n                throw new Error(\"Invalid dataType: \" + usedDataType);\n        }\n    }\n    decodeToken(dataType, multiInfo) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.decodeDataType();\n        switch (usedDataType) {\n            case DataType.UNDEFINED:\n                return { type: \"leaf\", value: undefined };\n            case DataType.NULL:\n                return { type: \"leaf\", value: null };\n            case DataType.BOOLEAN_TRUE:\n                return { type: \"leaf\", value: true };\n            case DataType.BOOLEAN_FALSE:\n                return { type: \"leaf\", value: false };\n            case DataType.EMPTY_ARRAY:\n                return { type: \"array\", value: [] };\n            case DataType.INT8:\n            case DataType.UINT8:\n            case DataType.INT16:\n            case DataType.UINT16:\n            case DataType.INT32:\n            case DataType.UINT32:\n            case DataType.FLOAT32:\n            case DataType.FLOAT64:\n                return { type: \"leaf\", value: this.decodeSingleNumber(usedDataType) };\n            case DataType.STRING:\n            case DataType.UNICODE:\n                return { type: \"leaf\", value: this.decodeString(usedDataType, multiInfo) };\n            case DataType.OBJECT_8:\n            case DataType.OBJECT_16:\n            case DataType.OBJECT_32:\n                return this.decodeObjectToken(usedDataType);\n            case DataType.SPLIT_8:\n            case DataType.SPLIT_16:\n            case DataType.SPLIT_32:\n                return this.decodeSplitToken(usedDataType);\n            case DataType.ARRAY_8:\n            case DataType.ARRAY_16:\n            case DataType.ARRAY_32:\n            case DataType.OFFSET_ARRAY_8:\n            case DataType.OFFSET_ARRAY_16:\n            case DataType.OFFSET_ARRAY_32:\n                return this.decodeArrayToken(usedDataType);\n            default:\n                throw new Error(\"Invalid dataType: \" + usedDataType);\n        }\n    }\n    isOffsetDataType(dataType) {\n        return dataType === DataType.OFFSET_ARRAY_8 || dataType === DataType.OFFSET_ARRAY_16 || dataType === DataType.OFFSET_ARRAY_32;\n    }\n    encodeArrayToken(arrayToken, dataType) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.encodeDataType(this.dataTypeUtils.getDataType(arrayToken));\n        const numberType = usedDataType === DataType.ARRAY_8 || usedDataType === DataType.OFFSET_ARRAY_8\n            ? DataType.UINT8\n            : usedDataType === DataType.ARRAY_16 || usedDataType === DataType.OFFSET_ARRAY_16\n                ? DataType.UINT16 : DataType.UINT32;\n        let indices = arrayToken.value;\n        if (this.isOffsetDataType(usedDataType)) {\n            const offset = Math.min(...indices);\n            indices = indices.map((value) => value - offset);\n            this.encodeSingleNumber(offset);\n        }\n        this.encodeNumberArray(indices, numberType);\n    }\n    decodeArrayToken(dataType) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.decodeDataType();\n        let offset = 0;\n        if (this.isOffsetDataType(usedDataType)) {\n            offset = this.decodeSingleNumber();\n        }\n        const numberType = usedDataType === DataType.ARRAY_8 || usedDataType === DataType.OFFSET_ARRAY_8\n            ? DataType.UINT8\n            : usedDataType === DataType.ARRAY_16 || usedDataType === DataType.OFFSET_ARRAY_16\n                ? DataType.UINT16 : DataType.UINT32;\n        const indices = this.decodeNumberArray(numberType)\n            .map(value => value + offset);\n        return {\n            type: \"array\",\n            value: indices,\n        };\n    }\n    encodeObjectToken(objectToken, dataType) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.encodeDataType(this.dataTypeUtils.getDataType(objectToken));\n        const numberType = usedDataType === DataType.OBJECT_8 ? DataType.UINT8 : usedDataType === DataType.OBJECT_16 ? DataType.UINT16 : DataType.UINT32;\n        const [keysIndex, valuesIndex] = objectToken.value;\n        this.encodeSingleNumber(keysIndex, numberType);\n        this.encodeSingleNumber(valuesIndex, numberType);\n    }\n    decodeObjectToken(dataType) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.decodeDataType();\n        const numberType = usedDataType === DataType.OBJECT_8 ? DataType.UINT8 : usedDataType === DataType.OBJECT_16 ? DataType.UINT16 : DataType.UINT32;\n        return {\n            type: \"object\",\n            value: [this.decodeSingleNumber(numberType), this.decodeSingleNumber(numberType)],\n        };\n    }\n    encodeSplitToken(splitToken, dataType) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.encodeDataType(this.dataTypeUtils.getDataType(splitToken));\n        const numberType = usedDataType === DataType.SPLIT_8 ? DataType.UINT8 : usedDataType === DataType.SPLIT_16 ? DataType.UINT16 : DataType.UINT32;\n        const [chunksIndex, separatorsIndex] = splitToken.value;\n        this.encodeSingleNumber(chunksIndex, numberType);\n        this.encodeSingleNumber(separatorsIndex, numberType);\n    }\n    decodeSplitToken(dataType) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.decodeDataType();\n        const numberType = usedDataType === DataType.SPLIT_8 ? DataType.UINT8 : usedDataType === DataType.SPLIT_16 ? DataType.UINT16 : DataType.UINT32;\n        return {\n            type: \"split\",\n            value: [this.decodeSingleNumber(numberType), this.decodeSingleNumber(numberType)],\n        };\n    }\n    encodeReferenceToken(token, dataType) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.encodeDataType(this.dataTypeUtils.getDataType(token));\n        const numberType = usedDataType === DataType.REFERENCE_8 ? DataType.UINT8 : usedDataType === DataType.REFERENCE_16 ? DataType.UINT16 : DataType.UINT32;\n        const index = token.value;\n        this.encodeSingleNumber(index, numberType);\n    }\n    decodeReferenceToken(dataType) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.decodeDataType();\n        const numberType = usedDataType === DataType.REFERENCE_8 ? DataType.UINT8 : usedDataType === DataType.REFERENCE_16 ? DataType.UINT16 : DataType.UINT32;\n        return {\n            type: \"reference\",\n            value: this.decodeSingleNumber(numberType),\n        };\n    }\n    encodeDataType(dataType) {\n        this.streamDataView.setNextUint8(dataType);\n        return dataType;\n    }\n    decodeDataType() {\n        return this.streamDataView.getNextUint8();\n    }\n    encodeMulti(tokens, pos) {\n        if (pos >= tokens.length) {\n            this.encodeSingleNumber(0, DataType.UINT8);\n            return 0;\n        }\n        const firstType = this.dataTypeUtils.getDataType(tokens[pos]);\n        let multiCount;\n        const maxCount = Math.min(tokens.length - pos, 255);\n        for (multiCount = 1; multiCount < maxCount; multiCount++) {\n            if (this.dataTypeUtils.getDataType(tokens[pos + multiCount]) !== firstType) {\n                break;\n            }\n        }\n        //  encode a multi, meaning that the same type is going to get repeated multiple times\n        this.encodeSingleNumber(multiCount, DataType.UINT8);\n        this.encodeDataType(firstType);\n        const multiInfo = {};\n        for (let i = 0; i < multiCount; i++) {\n            this.encodeToken(tokens[pos + i], firstType, multiInfo);\n        }\n        return multiCount;\n    }\n    decodeMulti(tokens) {\n        const count = this.streamDataView.getNextUint8();\n        if (!count) {\n            return 0;\n        }\n        const dataType = this.decodeDataType();\n        const multiInfo = {};\n        for (let i = 0; i < count; i++) {\n            const token = this.decodeToken(dataType, multiInfo);\n            tokens.push(token);\n        }\n        return count;\n    }\n    encodeSingleNumber(value, dataType) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.encodeDataType(this.dataTypeUtils.getNumberDataType(value));\n        switch (usedDataType) {\n            case DataType.UINT8:\n                this.streamDataView.setNextUint8(value);\n                break;\n            case DataType.INT8:\n                this.streamDataView.setNextInt8(value);\n                break;\n            case DataType.UINT16:\n                this.streamDataView.setNextUint16(value);\n                break;\n            case DataType.INT16:\n                this.streamDataView.setNextInt16(value);\n                break;\n            case DataType.UINT32:\n                this.streamDataView.setNextUint32(value);\n                break;\n            case DataType.INT32:\n                this.streamDataView.setNextInt32(value);\n                break;\n            case DataType.FLOAT32:\n                this.streamDataView.setNextFloat32(value);\n                break;\n            case DataType.FLOAT64:\n                this.streamDataView.setNextFloat64(value);\n                break;\n            default:\n                throw new Error(\"Invalid dataType for number: \" + usedDataType);\n        }\n    }\n    decodeSingleNumber(dataType) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.decodeDataType();\n        switch (usedDataType) {\n            case DataType.UINT8:\n                return this.streamDataView.getNextUint8();\n            case DataType.INT8:\n                return this.streamDataView.getNextInt8();\n            case DataType.UINT16:\n                return this.streamDataView.getNextUint16();\n            case DataType.INT16:\n                return this.streamDataView.getNextInt16();\n            case DataType.UINT32:\n                return this.streamDataView.getNextUint32();\n            case DataType.INT32:\n                return this.streamDataView.getNextInt32();\n            case DataType.FLOAT32:\n                return this.streamDataView.getNextFloat32();\n            case DataType.FLOAT64:\n                return this.streamDataView.getNextFloat64();\n            default:\n                throw new Error(\"Invalid dataType for number: \" + usedDataType);\n        }\n    }\n    encodeNumberArray(array, dataType) {\n        let pos;\n        for (pos = 0; pos < array.length;) {\n            const size = Math.min(255, array.length - pos);\n            this.encodeSingleNumber(size, DataType.UINT8);\n            if (!size) {\n                break;\n            }\n            const bestType = dataType !== null && dataType !== void 0 ? dataType : this.encodeDataType(this.dataTypeUtils.getBestType(array));\n            for (let i = 0; i < size; i++) {\n                this.encodeSingleNumber(array[pos + i], bestType);\n            }\n            pos += size;\n        }\n        if (pos === 255) {\n            //  Reached the max size of 255, but the next one is 0.\n            this.encodeSingleNumber(0, DataType.UINT8);\n        }\n    }\n    decodeNumberArray(dataType) {\n        let size;\n        const numbers = [];\n        do {\n            size = this.decodeSingleNumber(DataType.UINT8);\n            if (!size) {\n                break;\n            }\n            const type = dataType !== null && dataType !== void 0 ? dataType : this.decodeDataType();\n            for (let i = 0; i < size; i++) {\n                numbers.push(this.decodeSingleNumber(type));\n            }\n        } while (size >= 255);\n        return numbers;\n    }\n    encodeString(value, dataType, multiInfo) {\n        const letterCodes = value.split(\"\").map(l => l.charCodeAt(0));\n        // const min = Math.min(...letterCodes);\n        if (!multiInfo || multiInfo.lastStringLength !== value.length) {\n            letterCodes.push(0);\n        }\n        // console.log(letterCodes, value, (letterCodes).map((value) => !value ? 0 : value - min + 1));\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.encodeDataType(this.dataTypeUtils.getStringDataType(value));\n        const numberType = usedDataType === DataType.STRING ? DataType.UINT8 : DataType.UINT16;\n        letterCodes.forEach(code => this.encodeSingleNumber(code, numberType));\n        if (multiInfo) {\n            multiInfo.lastStringLength = value.length;\n        }\n    }\n    decodeString(dataType, multiInfo) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.decodeDataType();\n        const charCodes = [];\n        const numberType = usedDataType === DataType.STRING ? DataType.UINT8 : DataType.UINT16;\n        do {\n            const code = this.decodeSingleNumber(numberType);\n            if (!code) {\n                break;\n            }\n            charCodes.push(code);\n            if ((multiInfo === null || multiInfo === void 0 ? void 0 : multiInfo.lastStringLength) && charCodes.length >= (multiInfo === null || multiInfo === void 0 ? void 0 : multiInfo.lastStringLength)) {\n                break;\n            }\n        } while (true);\n        const string = charCodes.map(code => String.fromCharCode(code)).join(\"\");\n        if (multiInfo) {\n            multiInfo.lastStringLength = string.length;\n        }\n        return string;\n    }\n    static selfTest() {\n        const testers = [\n            //  0\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction(DataType.STRING, dataType => tokenEncoder.encodeDataType(dataType), reset, () => tokenDecoder.decodeDataType());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction(DataType.UNDEFINED, dataType => tokenEncoder.encodeDataType(dataType), reset, () => tokenDecoder.decodeDataType());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction(33, number => tokenEncoder.encodeSingleNumber(number, DataType.INT8), reset, () => tokenDecoder.decodeSingleNumber(DataType.INT8));\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction([\n                    { type: \"leaf\", value: 123 },\n                    { type: \"leaf\", value: 45 },\n                    { type: \"leaf\", value: 67 },\n                    { type: \"leaf\", value: 89 },\n                ], header => tokenEncoder.encodeMulti(header, 0), reset, () => {\n                    const result = [];\n                    tokenDecoder.decodeMulti(result);\n                    return result;\n                });\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction([\n                    { type: \"leaf\", value: 1000001 },\n                    { type: \"leaf\", value: 1002000 },\n                    { type: \"leaf\", value: 1003001 },\n                ], header => tokenEncoder.encodeMulti(header, 0), reset, () => {\n                    const result = [];\n                    tokenDecoder.decodeMulti(result);\n                    return result;\n                });\n            },\n            //  5\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction([1, 2, 3, 4, 10, 20, 200], array => tokenEncoder.encodeNumberArray(array), reset, () => tokenDecoder.decodeNumberArray());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction(new Array(2000).fill(null).map((_, index) => index), array => tokenEncoder.encodeNumberArray(array), reset, () => tokenDecoder.decodeNumberArray());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction([10000, -202, 3, 4, 10, 20, 3200], array => tokenEncoder.encodeNumberArray(array), reset, () => tokenDecoder.decodeNumberArray());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction(\"teststring\", string => tokenEncoder.encodeString(string), reset, () => tokenDecoder.decodeString());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction(\"teststring\", string => tokenEncoder.encodeString(string, DataType.STRING), reset, () => tokenDecoder.decodeString(DataType.STRING));\n            },\n            //  10\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction(\"test😀😃😄😁😆\", string => tokenEncoder.encodeString(string), reset, () => tokenDecoder.decodeString());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"object\", value: [200, 201] }, o => tokenEncoder.encodeObjectToken(o), reset, () => tokenDecoder.decodeObjectToken());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"object\", value: [2000, 2001] }, o => tokenEncoder.encodeObjectToken(o), reset, () => tokenDecoder.decodeObjectToken());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"object\", value: [2000, 2001] }, o => tokenEncoder.encodeObjectToken(o, DataType.OBJECT_32), reset, () => tokenDecoder.decodeObjectToken(DataType.OBJECT_32));\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"split\", value: [200, 201] }, o => tokenEncoder.encodeSplitToken(o), reset, () => tokenDecoder.decodeSplitToken());\n            },\n            //  15\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"split\", value: [2000, 2001] }, o => tokenEncoder.encodeSplitToken(o), reset, () => tokenDecoder.decodeSplitToken());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"split\", value: [2000, 2001] }, o => tokenEncoder.encodeSplitToken(o, DataType.SPLIT_32), reset, () => tokenDecoder.decodeSplitToken(DataType.SPLIT_32));\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"leaf\", value: \"tokenstring\" }, o => tokenEncoder.encodeToken(o), reset, () => tokenDecoder.decodeToken());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"leaf\", value: 123.5 }, o => tokenEncoder.encodeToken(o), reset, () => tokenDecoder.decodeToken());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"leaf\", value: \"😁😆\" }, o => tokenEncoder.encodeToken(o), reset, () => tokenDecoder.decodeToken());\n            },\n            //  20\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"array\", value: [1, 10, 20, 30, 200] }, o => tokenEncoder.encodeToken(o), reset, () => tokenDecoder.decodeToken());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"array\", value: [1001, 1010, 1020, 1030, 1200] }, o => tokenEncoder.encodeToken(o), reset, () => tokenDecoder.decodeToken());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"array\", value: [10010, 10100, 10300, 20000] }, o => tokenEncoder.encodeToken(o), reset, () => tokenDecoder.decodeToken());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"array\", value: [10010, 10100, 10000] }, o => tokenEncoder.encodeToken(o), reset, () => tokenDecoder.decodeToken());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"array\", value: new Array(260).fill(null).map((_, index) => index) }, o => tokenEncoder.encodeToken(o), reset, () => tokenDecoder.decodeToken());\n            },\n            //  25\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction(new Array(100).fill(null).map((_, index) => {\n                    const token = {\n                        type: \"array\",\n                        value: new Array(index).fill(null).map((_, index) => index),\n                    };\n                    return token;\n                }), o => tokenEncoder.encodeTokens(o), reset, () => tokenDecoder.decodeTokens());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction(new Array(260).fill(null).map((_, index) => {\n                    const token = {\n                        type: \"array\",\n                        value: new Array(index).fill(null).map((_, index) => index),\n                    };\n                    return token;\n                }), o => tokenEncoder.encodeTokens(o), reset, () => tokenDecoder.decodeTokens());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction(new Array(260).fill(null).map((_, index) => {\n                    const token = {\n                        type: \"array\",\n                        value: [1],\n                    };\n                    return token;\n                }), o => tokenEncoder.encodeTokens(o), reset, () => tokenDecoder.decodeTokens());\n            },\n        ];\n        testers.forEach((tester, index) => {\n            const streamDataView = new StreamDataView();\n            const encoder = new TokenEncoder(streamDataView);\n            const decoder = new TokenEncoder(streamDataView);\n            const reset = () => streamDataView.resetOffset();\n            tester(encoder, decoder, reset);\n            console.info(`✅ Passed test ${index}.`);\n        });\n    }\n    static testAction(value, encode, reset, decode, check = (result, value) => console.assert(JSON.stringify(result) === JSON.stringify(value), `Not equal: \\n%s\\n!==\\n%s`, JSON.stringify(result), JSON.stringify(value))) {\n        encode(value);\n        reset();\n        const decoded = decode();\n        reset();\n        check(decoded, value);\n    }\n}\n","import { DataType, DataTypeUtils } from \"../compression/DataType\";\n/**\n * Reduce header from using large tokens to reduce tokens.\n */\nexport default class Reducer {\n    constructor(debug) {\n        this.dataTypeUtils = new DataTypeUtils();\n        this.debug = debug !== null && debug !== void 0 ? debug : false;\n    }\n    /**\n     * Reduce header with smaller tokens for storage\n     *\n     * @param header Represents all data that we have.\n     * @returns DataStorage object that's the minimum we can store.\n     */\n    reduce(header) {\n        const hashToIndex = {};\n        //  start with header tokens\n        const headerTokens = this.createReducedTokens(Object.values(header.registry)\n            .filter(token => token.files.size > 1 || token.files.has(\"header\")), hashToIndex);\n        //  save files\n        const fileEntries = Object.entries(header.files).sort(([name1], [name2]) => name1.localeCompare(name2));\n        const files = fileEntries.map(([, token]) => hashToIndex[token.nameToken.hash]);\n        //  save all files separately\n        const dataTokens = fileEntries.map(([file, { token: root }]) => {\n            const subHashToIndex = Object.assign({}, hashToIndex);\n            const tokens = Object.values(header.registry).filter(token => token.files.has(file) && token !== root);\n            return this.createReducedTokens(tokens, subHashToIndex, headerTokens.length).concat(this.createReducedTokens([root], subHashToIndex, headerTokens.length));\n        });\n        return {\n            originalDataSize: header.originalDataSize,\n            headerTokens,\n            files,\n            getDataTokens: (index) => dataTokens[index],\n        };\n    }\n    /**\n     * Sort tokens by frequency.\n     */\n    sortTokens(tokens) {\n        tokens.sort((t1, t2) => t2.count - t1.count);\n    }\n    /**\n     * Organize tokens in groups of 255\n     * @param tokens\n     */\n    organizeTokens(tokens) {\n        if (!tokens.length) {\n            return tokens;\n        }\n        const buckets = [];\n        tokens.forEach(token => {\n            const dataType = this.dataTypeUtils.getFullTokenDataType(token);\n            let bucket = undefined;\n            for (let b of buckets) {\n                if (b.length < 255 && this.dataTypeUtils.getFullTokenDataType(b[0]) === dataType) {\n                    bucket = b;\n                    break;\n                }\n            }\n            if (!bucket) {\n                bucket = [];\n                buckets.push(bucket);\n            }\n            bucket.push(token);\n        });\n        buckets.forEach(bucket => {\n            const dataType = this.dataTypeUtils.getFullTokenDataType(bucket[0]);\n            switch (dataType) {\n                case DataType.UINT8:\n                case DataType.UINT16:\n                case DataType.UINT32:\n                case DataType.INT8:\n                case DataType.INT16:\n                case DataType.INT32:\n                case DataType.FLOAT32:\n                case DataType.FLOAT64:\n                    bucket.sort((a, b) => b.value - a.value);\n                    break;\n                case DataType.STRING:\n                case DataType.UNICODE:\n                    bucket.sort((a, b) => b.value.length - a.value.length);\n                    break;\n                case DataType.ARRAY_8:\n                case DataType.ARRAY_16:\n                case DataType.ARRAY_32:\n                    bucket.sort((a, b) => b.value.length - a.value.length);\n                    break;\n            }\n        });\n        const resultTokens = [];\n        buckets.forEach(bucket => bucket.forEach(token => resultTokens.push(token)));\n        return resultTokens;\n    }\n    createReducedTokens(tokens, hashToIndex, offset = 0) {\n        this.sortTokens(tokens);\n        const organizedTokens = this.organizeTokens(tokens);\n        organizedTokens.forEach(({ hash }, index) => hashToIndex[hash] = index + offset);\n        return organizedTokens.map(token => {\n            var _a, _b;\n            return (Object.assign({ type: token.type, value: (_b = (_a = token.reference) === null || _a === void 0 ? void 0 : _a.map(hash => hashToIndex[hash])) !== null && _b !== void 0 ? _b : token.value }, this.debug ? { debug: token.value } : {}));\n        });\n    }\n    /**\n     *  Traverse object to produce a set of tokens used to produce a complex object\n     * @param token Root token\n     * @param hashToIndex Hash to index mapping\n     * @param result Resulting set of tokens\n     */\n    createComplexObject(token, hashToIndex, registry, result) {\n        var _a;\n        if (hashToIndex[token.hash] >= 0) {\n            result.push({ type: \"reference\", value: hashToIndex[token.hash] });\n        }\n        else if (token.type === \"leaf\") {\n            if (token.count > 1) {\n                const index = result.length;\n                hashToIndex[token.hash] = index;\n            }\n            result.push({ type: token.type, value: token.value });\n        }\n        else if (token.type === \"split\" || token.type === \"object\" || token.type === \"array\") {\n            if (token.count > 1) {\n                const index = result.length;\n                hashToIndex[token.hash] = index;\n            }\n            result.push({ type: token.type, value: undefined });\n            const subTokens = (_a = token.reference) === null || _a === void 0 ? void 0 : _a.map((hash) => registry[hash]);\n            subTokens === null || subTokens === void 0 ? void 0 : subTokens.forEach(token => {\n                this.createComplexObject(token, hashToIndex, registry, result);\n            });\n        }\n        else {\n            throw new Error(\"Invalid token type\");\n        }\n    }\n}\n","// DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n// https://tools.ietf.org/html/rfc1951\n// You may also wish to take a look at the guide I made about this program:\n// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad\n// Some of the following code is similar to that of UZIP.js:\n// https://github.com/photopea/UZIP.js\n// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.\n// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint\n// is better for memory in most engines (I *think*).\nvar ch2 = {};\nvar wk = (function (c, id, msg, transfer, cb) {\n    var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([\n        c + ';addEventListener(\"error\",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'\n    ], { type: 'text/javascript' }))));\n    w.onmessage = function (e) {\n        var d = e.data, ed = d.$e$;\n        if (ed) {\n            var err = new Error(ed[0]);\n            err['code'] = ed[1];\n            err.stack = ed[2];\n            cb(err, null);\n        }\n        else\n            cb(null, d);\n    };\n    w.postMessage(msg, transfer);\n    return w;\n});\n\n// aliases for shorter compressed code (most minifers don't do this)\nvar u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;\n// fixed length extra bits\nvar fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);\n// fixed distance extra bits\n// see fleb note\nvar fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);\n// code length index map\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n// get base, reverse index map from extra bits\nvar freb = function (eb, start) {\n    var b = new u16(31);\n    for (var i = 0; i < 31; ++i) {\n        b[i] = start += 1 << eb[i - 1];\n    }\n    // numbers here are at max 18 bits\n    var r = new u32(b[30]);\n    for (var i = 1; i < 30; ++i) {\n        for (var j = b[i]; j < b[i + 1]; ++j) {\n            r[j] = ((j - b[i]) << 5) | i;\n        }\n    }\n    return [b, r];\n};\nvar _a = freb(fleb, 2), fl = _a[0], revfl = _a[1];\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = _b[0], revfd = _b[1];\n// map of value to reverse (assuming 16 bits)\nvar rev = new u16(32768);\nfor (var i = 0; i < 32768; ++i) {\n    // reverse table algorithm from SO\n    var x = ((i & 0xAAAA) >>> 1) | ((i & 0x5555) << 1);\n    x = ((x & 0xCCCC) >>> 2) | ((x & 0x3333) << 2);\n    x = ((x & 0xF0F0) >>> 4) | ((x & 0x0F0F) << 4);\n    rev[i] = (((x & 0xFF00) >>> 8) | ((x & 0x00FF) << 8)) >>> 1;\n}\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nvar hMap = (function (cd, mb, r) {\n    var s = cd.length;\n    // index\n    var i = 0;\n    // u16 \"map\": index -> # of codes with bit length = index\n    var l = new u16(mb);\n    // length of cd must be 288 (total # of codes)\n    for (; i < s; ++i) {\n        if (cd[i])\n            ++l[cd[i] - 1];\n    }\n    // u16 \"map\": index -> minimum code for bit length = index\n    var le = new u16(mb);\n    for (i = 0; i < mb; ++i) {\n        le[i] = (le[i - 1] + l[i - 1]) << 1;\n    }\n    var co;\n    if (r) {\n        // u16 \"map\": index -> number of actual bits, symbol for code\n        co = new u16(1 << mb);\n        // bits to remove for reverser\n        var rvb = 15 - mb;\n        for (i = 0; i < s; ++i) {\n            // ignore 0 lengths\n            if (cd[i]) {\n                // num encoding both symbol and bits read\n                var sv = (i << 4) | cd[i];\n                // free bits\n                var r_1 = mb - cd[i];\n                // start value\n                var v = le[cd[i] - 1]++ << r_1;\n                // m is end value\n                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {\n                    // every 16 bit value starting with the code yields the same result\n                    co[rev[v] >>> rvb] = sv;\n                }\n            }\n        }\n    }\n    else {\n        co = new u16(s);\n        for (i = 0; i < s; ++i) {\n            if (cd[i]) {\n                co[i] = rev[le[cd[i] - 1]++] >>> (15 - cd[i]);\n            }\n        }\n    }\n    return co;\n});\n// fixed length tree\nvar flt = new u8(288);\nfor (var i = 0; i < 144; ++i)\n    flt[i] = 8;\nfor (var i = 144; i < 256; ++i)\n    flt[i] = 9;\nfor (var i = 256; i < 280; ++i)\n    flt[i] = 7;\nfor (var i = 280; i < 288; ++i)\n    flt[i] = 8;\n// fixed distance tree\nvar fdt = new u8(32);\nfor (var i = 0; i < 32; ++i)\n    fdt[i] = 5;\n// fixed length map\nvar flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);\n// fixed distance map\nvar fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);\n// find max of array\nvar max = function (a) {\n    var m = a[0];\n    for (var i = 1; i < a.length; ++i) {\n        if (a[i] > m)\n            m = a[i];\n    }\n    return m;\n};\n// read d, starting at bit p and mask with m\nvar bits = function (d, p, m) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;\n};\n// read d, starting at bit p continuing for at least 16 bits\nvar bits16 = function (d, p) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));\n};\n// get end of byte\nvar shft = function (p) { return ((p + 7) / 8) | 0; };\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nvar slc = function (v, s, e) {\n    if (s == null || s < 0)\n        s = 0;\n    if (e == null || e > v.length)\n        e = v.length;\n    // can't use .constructor in case user-supplied\n    var n = new (v.BYTES_PER_ELEMENT == 2 ? u16 : v.BYTES_PER_ELEMENT == 4 ? u32 : u8)(e - s);\n    n.set(v.subarray(s, e));\n    return n;\n};\n/**\n * Codes for errors generated within this library\n */\nexport var FlateErrorCode = {\n    UnexpectedEOF: 0,\n    InvalidBlockType: 1,\n    InvalidLengthLiteral: 2,\n    InvalidDistance: 3,\n    StreamFinished: 4,\n    NoStreamHandler: 5,\n    InvalidHeader: 6,\n    NoCallback: 7,\n    InvalidUTF8: 8,\n    ExtraFieldTooLong: 9,\n    InvalidDate: 10,\n    FilenameTooLong: 11,\n    StreamFinishing: 12,\n    InvalidZipData: 13,\n    UnknownCompressionMethod: 14\n};\n// error codes\nvar ec = [\n    'unexpected EOF',\n    'invalid block type',\n    'invalid length/literal',\n    'invalid distance',\n    'stream finished',\n    'no stream handler',\n    ,\n    'no callback',\n    'invalid UTF-8 data',\n    'extra field too long',\n    'date not in range 1980-2099',\n    'filename too long',\n    'stream finishing',\n    'invalid zip data'\n    // determined by unknown compression method\n];\n;\nvar err = function (ind, msg, nt) {\n    var e = new Error(msg || ec[ind]);\n    e.code = ind;\n    if (Error.captureStackTrace)\n        Error.captureStackTrace(e, err);\n    if (!nt)\n        throw e;\n    return e;\n};\n// expands raw DEFLATE data\nvar inflt = function (dat, buf, st) {\n    // source length\n    var sl = dat.length;\n    if (!sl || (st && st.f && !st.l))\n        return buf || new u8(0);\n    // have to estimate size\n    var noBuf = !buf || st;\n    // no state\n    var noSt = !st || st.i;\n    if (!st)\n        st = {};\n    // Assumes roughly 33% compression ratio average\n    if (!buf)\n        buf = new u8(sl * 3);\n    // ensure buffer can fit at least l elements\n    var cbuf = function (l) {\n        var bl = buf.length;\n        // need to increase size to fit\n        if (l > bl) {\n            // Double or set to necessary, whichever is greater\n            var nbuf = new u8(Math.max(bl * 2, l));\n            nbuf.set(buf);\n            buf = nbuf;\n        }\n    };\n    //  last chunk         bitpos           bytes\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    // total bits\n    var tbts = sl * 8;\n    do {\n        if (!lm) {\n            // BFINAL - this is only 1 when last chunk is next\n            final = bits(dat, pos, 1);\n            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n            var type = bits(dat, pos + 1, 3);\n            pos += 3;\n            if (!type) {\n                // go to end of byte boundary\n                var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;\n                if (t > sl) {\n                    if (noSt)\n                        err(0);\n                    break;\n                }\n                // ensure size\n                if (noBuf)\n                    cbuf(bt + l);\n                // Copy over uncompressed data\n                buf.set(dat.subarray(s, t), bt);\n                // Get new bitpos, update byte count\n                st.b = bt += l, st.p = pos = t * 8, st.f = final;\n                continue;\n            }\n            else if (type == 1)\n                lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n            else if (type == 2) {\n                //  literal                            lengths\n                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n                var tl = hLit + bits(dat, pos + 5, 31) + 1;\n                pos += 14;\n                // length+distance tree\n                var ldt = new u8(tl);\n                // code length tree\n                var clt = new u8(19);\n                for (var i = 0; i < hcLen; ++i) {\n                    // use index map to get real code\n                    clt[clim[i]] = bits(dat, pos + i * 3, 7);\n                }\n                pos += hcLen * 3;\n                // code lengths bits\n                var clb = max(clt), clbmsk = (1 << clb) - 1;\n                // code lengths map\n                var clm = hMap(clt, clb, 1);\n                for (var i = 0; i < tl;) {\n                    var r = clm[bits(dat, pos, clbmsk)];\n                    // bits read\n                    pos += r & 15;\n                    // symbol\n                    var s = r >>> 4;\n                    // code length to copy\n                    if (s < 16) {\n                        ldt[i++] = s;\n                    }\n                    else {\n                        //  copy   count\n                        var c = 0, n = 0;\n                        if (s == 16)\n                            n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n                        else if (s == 17)\n                            n = 3 + bits(dat, pos, 7), pos += 3;\n                        else if (s == 18)\n                            n = 11 + bits(dat, pos, 127), pos += 7;\n                        while (n--)\n                            ldt[i++] = c;\n                    }\n                }\n                //    length tree                 distance tree\n                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n                // max length bits\n                lbt = max(lt);\n                // max dist bits\n                dbt = max(dt);\n                lm = hMap(lt, lbt, 1);\n                dm = hMap(dt, dbt, 1);\n            }\n            else\n                err(1);\n            if (pos > tbts) {\n                if (noSt)\n                    err(0);\n                break;\n            }\n        }\n        // Make sure the buffer can hold this + the largest possible addition\n        // Maximum chunk size (practically, theoretically infinite) is 2^17;\n        if (noBuf)\n            cbuf(bt + 131072);\n        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n        var lpos = pos;\n        for (;; lpos = pos) {\n            // bits read, code\n            var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;\n            pos += c & 15;\n            if (pos > tbts) {\n                if (noSt)\n                    err(0);\n                break;\n            }\n            if (!c)\n                err(2);\n            if (sym < 256)\n                buf[bt++] = sym;\n            else if (sym == 256) {\n                lpos = pos, lm = null;\n                break;\n            }\n            else {\n                var add = sym - 254;\n                // no extra bits needed if less\n                if (sym > 264) {\n                    // index\n                    var i = sym - 257, b = fleb[i];\n                    add = bits(dat, pos, (1 << b) - 1) + fl[i];\n                    pos += b;\n                }\n                // dist\n                var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;\n                if (!d)\n                    err(3);\n                pos += d & 15;\n                var dt = fd[dsym];\n                if (dsym > 3) {\n                    var b = fdeb[dsym];\n                    dt += bits16(dat, pos) & ((1 << b) - 1), pos += b;\n                }\n                if (pos > tbts) {\n                    if (noSt)\n                        err(0);\n                    break;\n                }\n                if (noBuf)\n                    cbuf(bt + 131072);\n                var end = bt + add;\n                for (; bt < end; bt += 4) {\n                    buf[bt] = buf[bt - dt];\n                    buf[bt + 1] = buf[bt + 1 - dt];\n                    buf[bt + 2] = buf[bt + 2 - dt];\n                    buf[bt + 3] = buf[bt + 3 - dt];\n                }\n                bt = end;\n            }\n        }\n        st.l = lm, st.p = lpos, st.b = bt, st.f = final;\n        if (lm)\n            final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    } while (!final);\n    return bt == buf.length ? buf : slc(buf, 0, bt);\n};\n// starting at p, write the minimum number of bits that can hold v to d\nvar wbits = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n};\n// starting at p, write the minimum number of bits (>8) that can hold v to d\nvar wbits16 = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n    d[o + 2] |= v >>> 16;\n};\n// creates code lengths from a frequency table\nvar hTree = function (d, mb) {\n    // Need extra info to make a tree\n    var t = [];\n    for (var i = 0; i < d.length; ++i) {\n        if (d[i])\n            t.push({ s: i, f: d[i] });\n    }\n    var s = t.length;\n    var t2 = t.slice();\n    if (!s)\n        return [et, 0];\n    if (s == 1) {\n        var v = new u8(t[0].s + 1);\n        v[t[0].s] = 1;\n        return [v, 1];\n    }\n    t.sort(function (a, b) { return a.f - b.f; });\n    // after i2 reaches last ind, will be stopped\n    // freq must be greater than largest possible number of symbols\n    t.push({ s: -1, f: 25001 });\n    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;\n    t[0] = { s: -1, f: l.f + r.f, l: l, r: r };\n    // efficient algorithm from UZIP.js\n    // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n    // symbols that combined have high freq, will start processing i2 (high-freq,\n    // non-composite) symbols instead\n    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n    while (i1 != s - 1) {\n        l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n        t[i1++] = { s: -1, f: l.f + r.f, l: l, r: r };\n    }\n    var maxSym = t2[0].s;\n    for (var i = 1; i < s; ++i) {\n        if (t2[i].s > maxSym)\n            maxSym = t2[i].s;\n    }\n    // code lengths\n    var tr = new u16(maxSym + 1);\n    // max bits in tree\n    var mbt = ln(t[i1 - 1], tr, 0);\n    if (mbt > mb) {\n        // more algorithms from UZIP.js\n        // TODO: find out how this code works (debt)\n        //  ind    debt\n        var i = 0, dt = 0;\n        //    left            cost\n        var lft = mbt - mb, cst = 1 << lft;\n        t2.sort(function (a, b) { return tr[b.s] - tr[a.s] || a.f - b.f; });\n        for (; i < s; ++i) {\n            var i2_1 = t2[i].s;\n            if (tr[i2_1] > mb) {\n                dt += cst - (1 << (mbt - tr[i2_1]));\n                tr[i2_1] = mb;\n            }\n            else\n                break;\n        }\n        dt >>>= lft;\n        while (dt > 0) {\n            var i2_2 = t2[i].s;\n            if (tr[i2_2] < mb)\n                dt -= 1 << (mb - tr[i2_2]++ - 1);\n            else\n                ++i;\n        }\n        for (; i >= 0 && dt; --i) {\n            var i2_3 = t2[i].s;\n            if (tr[i2_3] == mb) {\n                --tr[i2_3];\n                ++dt;\n            }\n        }\n        mbt = mb;\n    }\n    return [new u8(tr), mbt];\n};\n// get the max length and assign length codes\nvar ln = function (n, l, d) {\n    return n.s == -1\n        ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))\n        : (l[n.s] = d);\n};\n// length codes generation\nvar lc = function (c) {\n    var s = c.length;\n    // Note that the semicolon was intentional\n    while (s && !c[--s])\n        ;\n    var cl = new u16(++s);\n    //  ind      num         streak\n    var cli = 0, cln = c[0], cls = 1;\n    var w = function (v) { cl[cli++] = v; };\n    for (var i = 1; i <= s; ++i) {\n        if (c[i] == cln && i != s)\n            ++cls;\n        else {\n            if (!cln && cls > 2) {\n                for (; cls > 138; cls -= 138)\n                    w(32754);\n                if (cls > 2) {\n                    w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305);\n                    cls = 0;\n                }\n            }\n            else if (cls > 3) {\n                w(cln), --cls;\n                for (; cls > 6; cls -= 6)\n                    w(8304);\n                if (cls > 2)\n                    w(((cls - 3) << 5) | 8208), cls = 0;\n            }\n            while (cls--)\n                w(cln);\n            cls = 1;\n            cln = c[i];\n        }\n    }\n    return [cl.subarray(0, cli), s];\n};\n// calculate the length of output from tree, code lengths\nvar clen = function (cf, cl) {\n    var l = 0;\n    for (var i = 0; i < cl.length; ++i)\n        l += cf[i] * cl[i];\n    return l;\n};\n// writes a fixed block\n// returns the new bit pos\nvar wfblk = function (out, pos, dat) {\n    // no need to write 00 as type: TypedArray defaults to 0\n    var s = dat.length;\n    var o = shft(pos + 2);\n    out[o] = s & 255;\n    out[o + 1] = s >>> 8;\n    out[o + 2] = out[o] ^ 255;\n    out[o + 3] = out[o + 1] ^ 255;\n    for (var i = 0; i < s; ++i)\n        out[o + i + 4] = dat[i];\n    return (o + 4 + s) * 8;\n};\n// writes a block\nvar wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\n    wbits(out, p++, final);\n    ++lf[256];\n    var _a = hTree(lf, 15), dlt = _a[0], mlb = _a[1];\n    var _b = hTree(df, 15), ddt = _b[0], mdb = _b[1];\n    var _c = lc(dlt), lclt = _c[0], nlc = _c[1];\n    var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];\n    var lcfreq = new u16(19);\n    for (var i = 0; i < lclt.length; ++i)\n        lcfreq[lclt[i] & 31]++;\n    for (var i = 0; i < lcdt.length; ++i)\n        lcfreq[lcdt[i] & 31]++;\n    var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];\n    var nlcc = 19;\n    for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)\n        ;\n    var flen = (bl + 5) << 3;\n    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);\n    if (flen <= ftlen && flen <= dtlen)\n        return wfblk(out, p, dat.subarray(bs, bs + bl));\n    var lm, ll, dm, dl;\n    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;\n    if (dtlen < ftlen) {\n        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n        var llm = hMap(lct, mlcb, 0);\n        wbits(out, p, nlc - 257);\n        wbits(out, p + 5, ndc - 1);\n        wbits(out, p + 10, nlcc - 4);\n        p += 14;\n        for (var i = 0; i < nlcc; ++i)\n            wbits(out, p + 3 * i, lct[clim[i]]);\n        p += 3 * nlcc;\n        var lcts = [lclt, lcdt];\n        for (var it = 0; it < 2; ++it) {\n            var clct = lcts[it];\n            for (var i = 0; i < clct.length; ++i) {\n                var len = clct[i] & 31;\n                wbits(out, p, llm[len]), p += lct[len];\n                if (len > 15)\n                    wbits(out, p, (clct[i] >>> 5) & 127), p += clct[i] >>> 12;\n            }\n        }\n    }\n    else {\n        lm = flm, ll = flt, dm = fdm, dl = fdt;\n    }\n    for (var i = 0; i < li; ++i) {\n        if (syms[i] > 255) {\n            var len = (syms[i] >>> 18) & 31;\n            wbits16(out, p, lm[len + 257]), p += ll[len + 257];\n            if (len > 7)\n                wbits(out, p, (syms[i] >>> 23) & 31), p += fleb[len];\n            var dst = syms[i] & 31;\n            wbits16(out, p, dm[dst]), p += dl[dst];\n            if (dst > 3)\n                wbits16(out, p, (syms[i] >>> 5) & 8191), p += fdeb[dst];\n        }\n        else {\n            wbits16(out, p, lm[syms[i]]), p += ll[syms[i]];\n        }\n    }\n    wbits16(out, p, lm[256]);\n    return p + ll[256];\n};\n// deflate options (nice << 13) | chain\nvar deo = /*#__PURE__*/ new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);\n// empty\nvar et = /*#__PURE__*/ new u8(0);\n// compresses data into a raw DEFLATE buffer\nvar dflt = function (dat, lvl, plvl, pre, post, lst) {\n    var s = dat.length;\n    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);\n    // writing to this writes to the output buffer\n    var w = o.subarray(pre, o.length - post);\n    var pos = 0;\n    if (!lvl || s < 8) {\n        for (var i = 0; i <= s; i += 65535) {\n            // end\n            var e = i + 65535;\n            if (e >= s) {\n                // write final block\n                w[pos >> 3] = lst;\n            }\n            pos = wfblk(w, pos + 1, dat.subarray(i, e));\n        }\n    }\n    else {\n        var opt = deo[lvl - 1];\n        var n = opt >>> 13, c = opt & 8191;\n        var msk_1 = (1 << plvl) - 1;\n        //    prev 2-byte val map    curr 2-byte val map\n        var prev = new u16(32768), head = new u16(msk_1 + 1);\n        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;\n        var hsh = function (i) { return (dat[i] ^ (dat[i + 1] << bs1_1) ^ (dat[i + 2] << bs2_1)) & msk_1; };\n        // 24576 is an arbitrary number of maximum symbols per block\n        // 424 buffer for last block\n        var syms = new u32(25000);\n        // length/literal freq   distance freq\n        var lf = new u16(288), df = new u16(32);\n        //  l/lcnt  exbits  index  l/lind  waitdx  bitpos\n        var lc_1 = 0, eb = 0, i = 0, li = 0, wi = 0, bs = 0;\n        for (; i < s; ++i) {\n            // hash value\n            // deopt when i > s - 3 - at end, deopt acceptable\n            var hv = hsh(i);\n            // index mod 32768    previous index mod\n            var imod = i & 32767, pimod = head[hv];\n            prev[imod] = pimod;\n            head[hv] = imod;\n            // We always should modify head and prev, but only add symbols if\n            // this data is not yet processed (\"wait\" for wait index)\n            if (wi <= i) {\n                // bytes remaining\n                var rem = s - i;\n                if ((lc_1 > 7000 || li > 24576) && rem > 423) {\n                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n                    li = lc_1 = eb = 0, bs = i;\n                    for (var j = 0; j < 286; ++j)\n                        lf[j] = 0;\n                    for (var j = 0; j < 30; ++j)\n                        df[j] = 0;\n                }\n                //  len    dist   chain\n                var l = 2, d = 0, ch_1 = c, dif = (imod - pimod) & 32767;\n                if (rem > 2 && hv == hsh(i - dif)) {\n                    var maxn = Math.min(n, rem) - 1;\n                    var maxd = Math.min(32767, i);\n                    // max possible length\n                    // not capped at dif because decompressors implement \"rolling\" index population\n                    var ml = Math.min(258, rem);\n                    while (dif <= maxd && --ch_1 && imod != pimod) {\n                        if (dat[i + l] == dat[i + l - dif]) {\n                            var nl = 0;\n                            for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)\n                                ;\n                            if (nl > l) {\n                                l = nl, d = dif;\n                                // break out early when we reach \"nice\" (we are satisfied enough)\n                                if (nl > maxn)\n                                    break;\n                                // now, find the rarest 2-byte sequence within this\n                                // length of literals and search for that instead.\n                                // Much faster than just using the start\n                                var mmd = Math.min(dif, nl - 2);\n                                var md = 0;\n                                for (var j = 0; j < mmd; ++j) {\n                                    var ti = (i - dif + j + 32768) & 32767;\n                                    var pti = prev[ti];\n                                    var cd = (ti - pti + 32768) & 32767;\n                                    if (cd > md)\n                                        md = cd, pimod = ti;\n                                }\n                            }\n                        }\n                        // check the previous match\n                        imod = pimod, pimod = prev[imod];\n                        dif += (imod - pimod + 32768) & 32767;\n                    }\n                }\n                // d will be nonzero only when a match was found\n                if (d) {\n                    // store both dist and len data in one Uint32\n                    // Make sure this is recognized as a len/dist with 28th bit (2^28)\n                    syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d];\n                    var lin = revfl[l] & 31, din = revfd[d] & 31;\n                    eb += fleb[lin] + fdeb[din];\n                    ++lf[257 + lin];\n                    ++df[din];\n                    wi = i + l;\n                    ++lc_1;\n                }\n                else {\n                    syms[li++] = dat[i];\n                    ++lf[dat[i]];\n                }\n            }\n        }\n        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);\n        // this is the easiest way to avoid needing to maintain state\n        if (!lst && pos & 7)\n            pos = wfblk(w, pos + 1, et);\n    }\n    return slc(o, 0, pre + shft(pos) + post);\n};\n// CRC32 table\nvar crct = /*#__PURE__*/ (function () {\n    var t = new Int32Array(256);\n    for (var i = 0; i < 256; ++i) {\n        var c = i, k = 9;\n        while (--k)\n            c = ((c & 1) && -306674912) ^ (c >>> 1);\n        t[i] = c;\n    }\n    return t;\n})();\n// CRC32\nvar crc = function () {\n    var c = -1;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var cr = c;\n            for (var i = 0; i < d.length; ++i)\n                cr = crct[(cr & 255) ^ d[i]] ^ (cr >>> 8);\n            c = cr;\n        },\n        d: function () { return ~c; }\n    };\n};\n// Alder32\nvar adler = function () {\n    var a = 1, b = 0;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var n = a, m = b;\n            var l = d.length | 0;\n            for (var i = 0; i != l;) {\n                var e = Math.min(i + 2655, l);\n                for (; i < e; ++i)\n                    m += n += d[i];\n                n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);\n            }\n            a = n, b = m;\n        },\n        d: function () {\n            a %= 65521, b %= 65521;\n            return (a & 255) << 24 | (a >>> 8) << 16 | (b & 255) << 8 | (b >>> 8);\n        }\n    };\n};\n;\n// deflate with opts\nvar dopt = function (dat, opt, pre, post, st) {\n    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : (12 + opt.mem), pre, post, !st);\n};\n// Walmart object spread\nvar mrg = function (a, b) {\n    var o = {};\n    for (var k in a)\n        o[k] = a[k];\n    for (var k in b)\n        o[k] = b[k];\n    return o;\n};\n// worker clone\n// This is possibly the craziest part of the entire codebase, despite how simple it may seem.\n// The only parameter to this function is a closure that returns an array of variables outside of the function scope.\n// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.\n// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).\n// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.\n// This took me three weeks to figure out how to do.\nvar wcln = function (fn, fnStr, td) {\n    var dt = fn();\n    var st = fn.toString();\n    var ks = st.slice(st.indexOf('[') + 1, st.lastIndexOf(']')).replace(/\\s+/g, '').split(',');\n    for (var i = 0; i < dt.length; ++i) {\n        var v = dt[i], k = ks[i];\n        if (typeof v == 'function') {\n            fnStr += ';' + k + '=';\n            var st_1 = v.toString();\n            if (v.prototype) {\n                // for global objects\n                if (st_1.indexOf('[native code]') != -1) {\n                    var spInd = st_1.indexOf(' ', 8) + 1;\n                    fnStr += st_1.slice(spInd, st_1.indexOf('(', spInd));\n                }\n                else {\n                    fnStr += st_1;\n                    for (var t in v.prototype)\n                        fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[t].toString();\n                }\n            }\n            else\n                fnStr += st_1;\n        }\n        else\n            td[k] = v;\n    }\n    return [fnStr, td];\n};\nvar ch = [];\n// clone bufs\nvar cbfs = function (v) {\n    var tl = [];\n    for (var k in v) {\n        if (v[k].buffer) {\n            tl.push((v[k] = new v[k].constructor(v[k])).buffer);\n        }\n    }\n    return tl;\n};\n// use a worker to execute code\nvar wrkr = function (fns, init, id, cb) {\n    var _a;\n    if (!ch[id]) {\n        var fnStr = '', td_1 = {}, m = fns.length - 1;\n        for (var i = 0; i < m; ++i)\n            _a = wcln(fns[i], fnStr, td_1), fnStr = _a[0], td_1 = _a[1];\n        ch[id] = wcln(fns[m], fnStr, td_1);\n    }\n    var td = mrg({}, ch[id][1]);\n    return wk(ch[id][0] + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + init.toString() + '}', id, td, cbfs(td), cb);\n};\n// base async inflate fn\nvar bInflt = function () { return [u8, u16, u32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gu8]; };\nvar bDflt = function () { return [u8, u16, u32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf]; };\n// gzip extra\nvar gze = function () { return [gzh, gzhl, wbytes, crc, crct]; };\n// gunzip extra\nvar guze = function () { return [gzs, gzl]; };\n// zlib extra\nvar zle = function () { return [zlh, wbytes, adler]; };\n// unzlib extra\nvar zule = function () { return [zlv]; };\n// post buf\nvar pbf = function (msg) { return postMessage(msg, [msg.buffer]); };\n// get u8\nvar gu8 = function (o) { return o && o.size && new u8(o.size); };\n// async helper\nvar cbify = function (dat, opts, fns, init, id, cb) {\n    var w = wrkr(fns, init, id, function (err, dat) {\n        w.terminate();\n        cb(err, dat);\n    });\n    w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);\n    return function () { w.terminate(); };\n};\n// auto stream\nvar astrm = function (strm) {\n    strm.ondata = function (dat, final) { return postMessage([dat, final], [dat.buffer]); };\n    return function (ev) { return strm.push(ev.data[0], ev.data[1]); };\n};\n// async stream attach\nvar astrmify = function (fns, strm, opts, init, id) {\n    var t;\n    var w = wrkr(fns, init, id, function (err, dat) {\n        if (err)\n            w.terminate(), strm.ondata.call(strm, err);\n        else {\n            if (dat[1])\n                w.terminate();\n            strm.ondata.call(strm, err, dat[0], dat[1]);\n        }\n    });\n    w.postMessage(opts);\n    strm.push = function (d, f) {\n        if (!strm.ondata)\n            err(5);\n        if (t)\n            strm.ondata(err(4, 0, 1), null, !!f);\n        w.postMessage([d, t = f], [d.buffer]);\n    };\n    strm.terminate = function () { w.terminate(); };\n};\n// read 2 bytes\nvar b2 = function (d, b) { return d[b] | (d[b + 1] << 8); };\n// read 4 bytes\nvar b4 = function (d, b) { return (d[b] | (d[b + 1] << 8) | (d[b + 2] << 16) | (d[b + 3] << 24)) >>> 0; };\nvar b8 = function (d, b) { return b4(d, b) + (b4(d, b + 4) * 4294967296); };\n// write bytes\nvar wbytes = function (d, b, v) {\n    for (; v; ++b)\n        d[b] = v, v >>>= 8;\n};\n// gzip header\nvar gzh = function (c, o) {\n    var fn = o.filename;\n    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix\n    if (o.mtime != 0)\n        wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));\n    if (fn) {\n        c[3] = 8;\n        for (var i = 0; i <= fn.length; ++i)\n            c[i + 10] = fn.charCodeAt(i);\n    }\n};\n// gzip footer: -8 to -4 = CRC, -4 to -0 is length\n// gzip start\nvar gzs = function (d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n        err(6, 'invalid gzip data');\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4)\n        st += d[10] | (d[11] << 8) + 2;\n    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\n        ;\n    return st + (flg & 2);\n};\n// gzip length\nvar gzl = function (d) {\n    var l = d.length;\n    return ((d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16) | (d[l - 1] << 24)) >>> 0;\n};\n// gzip header length\nvar gzhl = function (o) { return 10 + ((o.filename && (o.filename.length + 1)) || 0); };\n// zlib header\nvar zlh = function (c, o) {\n    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\n    c[0] = 120, c[1] = (fl << 6) | (fl ? (32 - 2 * fl) : 1);\n};\n// zlib valid\nvar zlv = function (d) {\n    if ((d[0] & 15) != 8 || (d[0] >>> 4) > 7 || ((d[0] << 8 | d[1]) % 31))\n        err(6, 'invalid zlib data');\n    if (d[1] & 32)\n        err(6, 'invalid zlib data: preset dictionaries not supported');\n};\nfunction AsyncCmpStrm(opts, cb) {\n    if (!cb && typeof opts == 'function')\n        cb = opts, opts = {};\n    this.ondata = cb;\n    return opts;\n}\n// zlib footer: -4 to -0 is Adler32\n/**\n * Streaming DEFLATE compression\n */\nvar Deflate = /*#__PURE__*/ (function () {\n    function Deflate(opts, cb) {\n        if (!cb && typeof opts == 'function')\n            cb = opts, opts = {};\n        this.ondata = cb;\n        this.o = opts || {};\n    }\n    Deflate.prototype.p = function (c, f) {\n        this.ondata(dopt(c, this.o, 0, 0, !f), f);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Deflate.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        this.d = final;\n        this.p(chunk, final || false);\n    };\n    return Deflate;\n}());\nexport { Deflate };\n/**\n * Asynchronous streaming DEFLATE compression\n */\nvar AsyncDeflate = /*#__PURE__*/ (function () {\n    function AsyncDeflate(opts, cb) {\n        astrmify([\n            bDflt,\n            function () { return [astrm, Deflate]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Deflate(ev.data);\n            onmessage = astrm(strm);\n        }, 6);\n    }\n    return AsyncDeflate;\n}());\nexport { AsyncDeflate };\nexport function deflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n    ], function (ev) { return pbf(deflateSync(ev.data[0], ev.data[1])); }, 0, cb);\n}\n/**\n * Compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param opts The compression options\n * @returns The deflated version of the data\n */\nexport function deflateSync(data, opts) {\n    return dopt(data, opts || {}, 0, 0);\n}\n/**\n * Streaming DEFLATE decompression\n */\nvar Inflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an inflation stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Inflate(cb) {\n        this.s = {};\n        this.p = new u8(0);\n        this.ondata = cb;\n    }\n    Inflate.prototype.e = function (c) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        var l = this.p.length;\n        var n = new u8(l + c.length);\n        n.set(this.p), n.set(c, l), this.p = n;\n    };\n    Inflate.prototype.c = function (final) {\n        this.d = this.s.i = final || false;\n        var bts = this.s.b;\n        var dt = inflt(this.p, this.o, this.s);\n        this.ondata(slc(dt, bts, this.s.b), this.d);\n        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n        this.p = slc(this.p, (this.s.p / 8) | 0), this.s.p &= 7;\n    };\n    /**\n     * Pushes a chunk to be inflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the final chunk\n     */\n    Inflate.prototype.push = function (chunk, final) {\n        this.e(chunk), this.c(final);\n    };\n    return Inflate;\n}());\nexport { Inflate };\n/**\n * Asynchronous streaming DEFLATE decompression\n */\nvar AsyncInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous inflation stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncInflate(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            function () { return [astrm, Inflate]; }\n        ], this, 0, function () {\n            var strm = new Inflate();\n            onmessage = astrm(strm);\n        }, 7);\n    }\n    return AsyncInflate;\n}());\nexport { AsyncInflate };\nexport function inflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt\n    ], function (ev) { return pbf(inflateSync(ev.data[0], gu8(ev.data[1]))); }, 1, cb);\n}\n/**\n * Expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function inflateSync(data, out) {\n    return inflt(data, out);\n}\n// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.\n/**\n * Streaming GZIP compression\n */\nvar Gzip = /*#__PURE__*/ (function () {\n    function Gzip(opts, cb) {\n        this.c = crc();\n        this.l = 0;\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gzip.prototype.push = function (chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Gzip.prototype.p = function (c, f) {\n        this.c.p(c);\n        this.l += c.length;\n        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, !f);\n        if (this.v)\n            gzh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);\n        this.ondata(raw, f);\n    };\n    return Gzip;\n}());\nexport { Gzip };\n/**\n * Asynchronous streaming GZIP compression\n */\nvar AsyncGzip = /*#__PURE__*/ (function () {\n    function AsyncGzip(opts, cb) {\n        astrmify([\n            bDflt,\n            gze,\n            function () { return [astrm, Deflate, Gzip]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Gzip(ev.data);\n            onmessage = astrm(strm);\n        }, 8);\n    }\n    return AsyncGzip;\n}());\nexport { AsyncGzip };\nexport function gzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n        gze,\n        function () { return [gzipSync]; }\n    ], function (ev) { return pbf(gzipSync(ev.data[0], ev.data[1])); }, 2, cb);\n}\n/**\n * Compresses data with GZIP\n * @param data The data to compress\n * @param opts The compression options\n * @returns The gzipped version of the data\n */\nexport function gzipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var c = crc(), l = data.length;\n    c.p(data);\n    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;\n    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;\n}\n/**\n * Streaming GZIP decompression\n */\nvar Gunzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a GUNZIP stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Gunzip(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be GUNZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gunzip.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            var s = this.p.length > 3 ? gzs(this.p) : 4;\n            if (s >= this.p.length && !final)\n                return;\n            this.p = this.p.subarray(s), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 8)\n                err(6, 'invalid gzip data');\n            this.p = this.p.subarray(0, -8);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Gunzip;\n}());\nexport { Gunzip };\n/**\n * Asynchronous streaming GZIP decompression\n */\nvar AsyncGunzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous GUNZIP stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncGunzip(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            guze,\n            function () { return [astrm, Inflate, Gunzip]; }\n        ], this, 0, function () {\n            var strm = new Gunzip();\n            onmessage = astrm(strm);\n        }, 9);\n    }\n    return AsyncGunzip;\n}());\nexport { AsyncGunzip };\nexport function gunzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt,\n        guze,\n        function () { return [gunzipSync]; }\n    ], function (ev) { return pbf(gunzipSync(ev.data[0])); }, 3, cb);\n}\n/**\n * Expands GZIP data\n * @param data The data to decompress\n * @param out Where to write the data. GZIP already encodes the output size, so providing this doesn't save memory.\n * @returns The decompressed version of the data\n */\nexport function gunzipSync(data, out) {\n    return inflt(data.subarray(gzs(data), -8), out || new u8(gzl(data)));\n}\n/**\n * Streaming Zlib compression\n */\nvar Zlib = /*#__PURE__*/ (function () {\n    function Zlib(opts, cb) {\n        this.c = adler();\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be zlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Zlib.prototype.push = function (chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Zlib.prototype.p = function (c, f) {\n        this.c.p(c);\n        var raw = dopt(c, this.o, this.v && 2, f && 4, !f);\n        if (this.v)\n            zlh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 4, this.c.d());\n        this.ondata(raw, f);\n    };\n    return Zlib;\n}());\nexport { Zlib };\n/**\n * Asynchronous streaming Zlib compression\n */\nvar AsyncZlib = /*#__PURE__*/ (function () {\n    function AsyncZlib(opts, cb) {\n        astrmify([\n            bDflt,\n            zle,\n            function () { return [astrm, Deflate, Zlib]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Zlib(ev.data);\n            onmessage = astrm(strm);\n        }, 10);\n    }\n    return AsyncZlib;\n}());\nexport { AsyncZlib };\nexport function zlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n        zle,\n        function () { return [zlibSync]; }\n    ], function (ev) { return pbf(zlibSync(ev.data[0], ev.data[1])); }, 4, cb);\n}\n/**\n * Compress data with Zlib\n * @param data The data to compress\n * @param opts The compression options\n * @returns The zlib-compressed version of the data\n */\nexport function zlibSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var a = adler();\n    a.p(data);\n    var d = dopt(data, opts, 2, 4);\n    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;\n}\n/**\n * Streaming Zlib decompression\n */\nvar Unzlib = /*#__PURE__*/ (function () {\n    /**\n     * Creates a Zlib decompression stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Unzlib(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be unzlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzlib.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            if (this.p.length < 2 && !final)\n                return;\n            this.p = this.p.subarray(2), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 4)\n                err(6, 'invalid zlib data');\n            this.p = this.p.subarray(0, -4);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Unzlib;\n}());\nexport { Unzlib };\n/**\n * Asynchronous streaming Zlib decompression\n */\nvar AsyncUnzlib = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous Zlib decompression stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncUnzlib(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            zule,\n            function () { return [astrm, Inflate, Unzlib]; }\n        ], this, 0, function () {\n            var strm = new Unzlib();\n            onmessage = astrm(strm);\n        }, 11);\n    }\n    return AsyncUnzlib;\n}());\nexport { AsyncUnzlib };\nexport function unzlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt,\n        zule,\n        function () { return [unzlibSync]; }\n    ], function (ev) { return pbf(unzlibSync(ev.data[0], gu8(ev.data[1]))); }, 5, cb);\n}\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function unzlibSync(data, out) {\n    return inflt((zlv(data), data.subarray(2, -4)), out);\n}\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzip as compress, AsyncGzip as AsyncCompress };\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzipSync as compressSync, Gzip as Compress };\n/**\n * Streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar Decompress = /*#__PURE__*/ (function () {\n    /**\n     * Creates a decompression stream\n     * @param cb The callback to call whenever data is decompressed\n     */\n    function Decompress(cb) {\n        this.G = Gunzip;\n        this.I = Inflate;\n        this.Z = Unzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Decompress.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (!this.s) {\n            if (this.p && this.p.length) {\n                var n = new u8(this.p.length + chunk.length);\n                n.set(this.p), n.set(chunk, this.p.length);\n            }\n            else\n                this.p = chunk;\n            if (this.p.length > 2) {\n                var _this_1 = this;\n                var cb = function () { _this_1.ondata.apply(_this_1, arguments); };\n                this.s = (this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8)\n                    ? new this.G(cb)\n                    : ((this.p[0] & 15) != 8 || (this.p[0] >> 4) > 7 || ((this.p[0] << 8 | this.p[1]) % 31))\n                        ? new this.I(cb)\n                        : new this.Z(cb);\n                this.s.push(this.p, final);\n                this.p = null;\n            }\n        }\n        else\n            this.s.push(chunk, final);\n    };\n    return Decompress;\n}());\nexport { Decompress };\n/**\n * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar AsyncDecompress = /*#__PURE__*/ (function () {\n    /**\n   * Creates an asynchronous decompression stream\n   * @param cb The callback to call whenever data is decompressed\n   */\n    function AsyncDecompress(cb) {\n        this.G = AsyncGunzip;\n        this.I = AsyncInflate;\n        this.Z = AsyncUnzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncDecompress.prototype.push = function (chunk, final) {\n        Decompress.prototype.push.call(this, chunk, final);\n    };\n    return AsyncDecompress;\n}());\nexport { AsyncDecompress };\nexport function decompress(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzip(data, opts, cb)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflate(data, opts, cb)\n            : unzlib(data, opts, cb);\n}\n/**\n * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function decompressSync(data, out) {\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzipSync(data, out)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflateSync(data, out)\n            : unzlibSync(data, out);\n}\n// flatten a directory structure\nvar fltn = function (d, p, t, o) {\n    for (var k in d) {\n        var val = d[k], n = p + k, op = o;\n        if (Array.isArray(val))\n            op = mrg(o, val[1]), val = val[0];\n        if (val instanceof u8)\n            t[n] = [val, op];\n        else {\n            t[n += '/'] = [new u8(0), op];\n            fltn(val, n, t, o);\n        }\n    }\n};\n// text encoder\nvar te = typeof TextEncoder != 'undefined' && /*#__PURE__*/ new TextEncoder();\n// text decoder\nvar td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();\n// text decoder stream\nvar tds = 0;\ntry {\n    td.decode(et, { stream: true });\n    tds = 1;\n}\ncatch (e) { }\n// decode UTF8\nvar dutf8 = function (d) {\n    for (var r = '', i = 0;;) {\n        var c = d[i++];\n        var eb = (c > 127) + (c > 223) + (c > 239);\n        if (i + eb > d.length)\n            return [r, slc(d, i - 1)];\n        if (!eb)\n            r += String.fromCharCode(c);\n        else if (eb == 3) {\n            c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63)) - 65536,\n                r += String.fromCharCode(55296 | (c >> 10), 56320 | (c & 1023));\n        }\n        else if (eb & 1)\n            r += String.fromCharCode((c & 31) << 6 | (d[i++] & 63));\n        else\n            r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63));\n    }\n};\n/**\n * Streaming UTF-8 decoding\n */\nvar DecodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is decoded\n     */\n    function DecodeUTF8(cb) {\n        this.ondata = cb;\n        if (tds)\n            this.t = new TextDecoder();\n        else\n            this.p = et;\n    }\n    /**\n     * Pushes a chunk to be decoded from UTF-8 binary\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    DecodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        final = !!final;\n        if (this.t) {\n            this.ondata(this.t.decode(chunk, { stream: true }), final);\n            if (final) {\n                if (this.t.decode().length)\n                    err(8);\n                this.t = null;\n            }\n            return;\n        }\n        if (!this.p)\n            err(4);\n        var dat = new u8(this.p.length + chunk.length);\n        dat.set(this.p);\n        dat.set(chunk, this.p.length);\n        var _a = dutf8(dat), ch = _a[0], np = _a[1];\n        if (final) {\n            if (np.length)\n                err(8);\n            this.p = null;\n        }\n        else\n            this.p = np;\n        this.ondata(ch, final);\n    };\n    return DecodeUTF8;\n}());\nexport { DecodeUTF8 };\n/**\n * Streaming UTF-8 encoding\n */\nvar EncodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is encoded\n     */\n    function EncodeUTF8(cb) {\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be encoded to UTF-8\n     * @param chunk The string data to push\n     * @param final Whether this is the last chunk\n     */\n    EncodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        this.ondata(strToU8(chunk), this.d = final || false);\n    };\n    return EncodeUTF8;\n}());\nexport { EncodeUTF8 };\n/**\n * Converts a string into a Uint8Array for use with compression/decompression methods\n * @param str The string to encode\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless decoding a binary string.\n * @returns The string encoded in UTF-8/Latin-1 binary\n */\nexport function strToU8(str, latin1) {\n    if (latin1) {\n        var ar_1 = new u8(str.length);\n        for (var i = 0; i < str.length; ++i)\n            ar_1[i] = str.charCodeAt(i);\n        return ar_1;\n    }\n    if (te)\n        return te.encode(str);\n    var l = str.length;\n    var ar = new u8(str.length + (str.length >> 1));\n    var ai = 0;\n    var w = function (v) { ar[ai++] = v; };\n    for (var i = 0; i < l; ++i) {\n        if (ai + 5 > ar.length) {\n            var n = new u8(ai + 8 + ((l - i) << 1));\n            n.set(ar);\n            ar = n;\n        }\n        var c = str.charCodeAt(i);\n        if (c < 128 || latin1)\n            w(c);\n        else if (c < 2048)\n            w(192 | (c >> 6)), w(128 | (c & 63));\n        else if (c > 55295 && c < 57344)\n            c = 65536 + (c & 1023 << 10) | (str.charCodeAt(++i) & 1023),\n                w(240 | (c >> 18)), w(128 | ((c >> 12) & 63)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n        else\n            w(224 | (c >> 12)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n    }\n    return slc(ar, 0, ai);\n}\n/**\n * Converts a Uint8Array to a string\n * @param dat The data to decode to string\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless encoding to binary string.\n * @returns The original UTF-8/Latin-1 string\n */\nexport function strFromU8(dat, latin1) {\n    if (latin1) {\n        var r = '';\n        for (var i = 0; i < dat.length; i += 16384)\n            r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));\n        return r;\n    }\n    else if (td)\n        return td.decode(dat);\n    else {\n        var _a = dutf8(dat), out = _a[0], ext = _a[1];\n        if (ext.length)\n            err(8);\n        return out;\n    }\n}\n;\n// deflate bit flag\nvar dbf = function (l) { return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0; };\n// skip local zip header\nvar slzh = function (d, b) { return b + 30 + b2(d, b + 26) + b2(d, b + 28); };\n// read zip header\nvar zh = function (d, b, z) {\n    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\n    var _a = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a[0], su = _a[1], off = _a[2];\n    return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];\n};\n// read zip64 extra field\nvar z64e = function (d, b) {\n    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))\n        ;\n    return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];\n};\n// extra field length\nvar exfl = function (ex) {\n    var le = 0;\n    if (ex) {\n        for (var k in ex) {\n            var l = ex[k].length;\n            if (l > 65535)\n                err(9);\n            le += l + 4;\n        }\n    }\n    return le;\n};\n// write zip header\nvar wzh = function (d, b, f, fn, u, c, ce, co) {\n    var fl = fn.length, ex = f.extra, col = co && co.length;\n    var exl = exfl(ex);\n    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;\n    if (ce != null)\n        d[b++] = 20, d[b++] = f.os;\n    d[b] = 20, b += 2; // spec compliance? what's that?\n    d[b++] = (f.flag << 1) | (c < 0 && 8), d[b++] = u && 8;\n    d[b++] = f.compression & 255, d[b++] = f.compression >> 8;\n    var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;\n    if (y < 0 || y > 119)\n        err(10);\n    wbytes(d, b, (y << 25) | ((dt.getMonth() + 1) << 21) | (dt.getDate() << 16) | (dt.getHours() << 11) | (dt.getMinutes() << 5) | (dt.getSeconds() >>> 1)), b += 4;\n    if (c != -1) {\n        wbytes(d, b, f.crc);\n        wbytes(d, b + 4, c < 0 ? -c - 2 : c);\n        wbytes(d, b + 8, f.size);\n    }\n    wbytes(d, b + 12, fl);\n    wbytes(d, b + 14, exl), b += 16;\n    if (ce != null) {\n        wbytes(d, b, col);\n        wbytes(d, b + 6, f.attrs);\n        wbytes(d, b + 10, ce), b += 14;\n    }\n    d.set(fn, b);\n    b += fl;\n    if (exl) {\n        for (var k in ex) {\n            var exf = ex[k], l = exf.length;\n            wbytes(d, b, +k);\n            wbytes(d, b + 2, l);\n            d.set(exf, b + 4), b += 4 + l;\n        }\n    }\n    if (col)\n        d.set(co, b), b += col;\n    return b;\n};\n// write zip footer (end of central directory)\nvar wzf = function (o, b, c, d, e) {\n    wbytes(o, b, 0x6054B50); // skip disk\n    wbytes(o, b + 8, c);\n    wbytes(o, b + 10, c);\n    wbytes(o, b + 12, d);\n    wbytes(o, b + 16, e);\n};\n/**\n * A pass-through stream to keep data uncompressed in a ZIP archive.\n */\nvar ZipPassThrough = /*#__PURE__*/ (function () {\n    /**\n     * Creates a pass-through stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     */\n    function ZipPassThrough(filename) {\n        this.filename = filename;\n        this.c = crc();\n        this.size = 0;\n        this.compression = 0;\n    }\n    /**\n     * Processes a chunk and pushes to the output stream. You can override this\n     * method in a subclass for custom behavior, but by default this passes\n     * the data through. You must call this.ondata(err, chunk, final) at some\n     * point in this method.\n     * @param chunk The chunk to process\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.process = function (chunk, final) {\n        this.ondata(null, chunk, final);\n    };\n    /**\n     * Pushes a chunk to be added. If you are subclassing this with a custom\n     * compression algorithm, note that you must push data from the source\n     * file only, pre-compression.\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        this.c.p(chunk);\n        this.size += chunk.length;\n        if (final)\n            this.crc = this.c.d();\n        this.process(chunk, final || false);\n    };\n    return ZipPassThrough;\n}());\nexport { ZipPassThrough };\n// I don't extend because TypeScript extension adds 1kB of runtime bloat\n/**\n * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate\n * for better performance\n */\nvar ZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function ZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new Deflate(opts, function (dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n    }\n    ZipDeflate.prototype.process = function (chunk, final) {\n        try {\n            this.d.push(chunk, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return ZipDeflate;\n}());\nexport { ZipDeflate };\n/**\n * Asynchronous streaming DEFLATE compression for ZIP archives\n */\nvar AsyncZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function AsyncZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new AsyncDeflate(opts, function (err, dat, final) {\n            _this_1.ondata(err, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n        this.terminate = this.d.terminate;\n    }\n    AsyncZipDeflate.prototype.process = function (chunk, final) {\n        this.d.push(chunk, final);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return AsyncZipDeflate;\n}());\nexport { AsyncZipDeflate };\n// TODO: Better tree shaking\n/**\n * A zippable archive to which files can incrementally be added\n */\nvar Zip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an empty ZIP archive to which files can be added\n     * @param cb The callback to call whenever data for the generated ZIP archive\n     *           is available\n     */\n    function Zip(cb) {\n        this.ondata = cb;\n        this.u = [];\n        this.d = 1;\n    }\n    /**\n     * Adds a file to the ZIP archive\n     * @param file The file stream to add\n     */\n    Zip.prototype.add = function (file) {\n        var _this_1 = this;\n        if (!this.ondata)\n            err(5);\n        // finishing or finished\n        if (this.d & 2)\n            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, false);\n        else {\n            var f = strToU8(file.filename), fl_1 = f.length;\n            var com = file.comment, o = com && strToU8(com);\n            var u = fl_1 != file.filename.length || (o && (com.length != o.length));\n            var hl_1 = fl_1 + exfl(file.extra) + 30;\n            if (fl_1 > 65535)\n                this.ondata(err(11, 0, 1), null, false);\n            var header = new u8(hl_1);\n            wzh(header, 0, file, f, u, -1);\n            var chks_1 = [header];\n            var pAll_1 = function () {\n                for (var _i = 0, chks_2 = chks_1; _i < chks_2.length; _i++) {\n                    var chk = chks_2[_i];\n                    _this_1.ondata(null, chk, false);\n                }\n                chks_1 = [];\n            };\n            var tr_1 = this.d;\n            this.d = 0;\n            var ind_1 = this.u.length;\n            var uf_1 = mrg(file, {\n                f: f,\n                u: u,\n                o: o,\n                t: function () {\n                    if (file.terminate)\n                        file.terminate();\n                },\n                r: function () {\n                    pAll_1();\n                    if (tr_1) {\n                        var nxt = _this_1.u[ind_1 + 1];\n                        if (nxt)\n                            nxt.r();\n                        else\n                            _this_1.d = 1;\n                    }\n                    tr_1 = 1;\n                }\n            });\n            var cl_1 = 0;\n            file.ondata = function (err, dat, final) {\n                if (err) {\n                    _this_1.ondata(err, dat, final);\n                    _this_1.terminate();\n                }\n                else {\n                    cl_1 += dat.length;\n                    chks_1.push(dat);\n                    if (final) {\n                        var dd = new u8(16);\n                        wbytes(dd, 0, 0x8074B50);\n                        wbytes(dd, 4, file.crc);\n                        wbytes(dd, 8, cl_1);\n                        wbytes(dd, 12, file.size);\n                        chks_1.push(dd);\n                        uf_1.c = cl_1, uf_1.b = hl_1 + cl_1 + 16, uf_1.crc = file.crc, uf_1.size = file.size;\n                        if (tr_1)\n                            uf_1.r();\n                        tr_1 = 1;\n                    }\n                    else if (tr_1)\n                        pAll_1();\n                }\n            };\n            this.u.push(uf_1);\n        }\n    };\n    /**\n     * Ends the process of adding files and prepares to emit the final chunks.\n     * This *must* be called after adding all desired files for the resulting\n     * ZIP file to work properly.\n     */\n    Zip.prototype.end = function () {\n        var _this_1 = this;\n        if (this.d & 2) {\n            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, true);\n            return;\n        }\n        if (this.d)\n            this.e();\n        else\n            this.u.push({\n                r: function () {\n                    if (!(_this_1.d & 1))\n                        return;\n                    _this_1.u.splice(-1, 1);\n                    _this_1.e();\n                },\n                t: function () { }\n            });\n        this.d = 3;\n    };\n    Zip.prototype.e = function () {\n        var bt = 0, l = 0, tl = 0;\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);\n        }\n        var out = new u8(tl + 22);\n        for (var _b = 0, _c = this.u; _b < _c.length; _b++) {\n            var f = _c[_b];\n            wzh(out, bt, f, f.f, f.u, -f.c - 2, l, f.o);\n            bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;\n        }\n        wzf(out, bt, this.u.length, tl, l);\n        this.ondata(null, out, true);\n        this.d = 2;\n    };\n    /**\n     * A method to terminate any internal workers used by the stream. Subsequent\n     * calls to add() will fail.\n     */\n    Zip.prototype.terminate = function () {\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            f.t();\n        }\n        this.d = 2;\n    };\n    return Zip;\n}());\nexport { Zip };\nexport function zip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    var r = {};\n    fltn(data, '', r, opts);\n    var k = Object.keys(r);\n    var lft = k.length, o = 0, tot = 0;\n    var slft = lft, files = new Array(lft);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var cbd = function (a, b) {\n        mt(function () { cb(a, b); });\n    };\n    mt(function () { cbd = cb; });\n    var cbf = function () {\n        var out = new u8(tot + 22), oe = o, cdl = tot - o;\n        tot = 0;\n        for (var i = 0; i < slft; ++i) {\n            var f = files[i];\n            try {\n                var l = f.c.length;\n                wzh(out, tot, f, f.f, f.u, l);\n                var badd = 30 + f.f.length + exfl(f.extra);\n                var loc = tot + badd;\n                out.set(f.c, loc);\n                wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;\n            }\n            catch (e) {\n                return cbd(e, null);\n            }\n        }\n        wzf(out, o, files.length, cdl, oe);\n        cbd(null, out);\n    };\n    if (!lft)\n        cbf();\n    var _loop_1 = function (i) {\n        var fn = k[i];\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var c = crc(), size = file.length;\n        c.p(file);\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        var compression = p.level == 0 ? 0 : 8;\n        var cbl = function (e, d) {\n            if (e) {\n                tAll();\n                cbd(e, null);\n            }\n            else {\n                var l = d.length;\n                files[i] = mrg(p, {\n                    size: size,\n                    crc: c.d(),\n                    c: d,\n                    f: f,\n                    m: m,\n                    u: s != fn.length || (m && (com.length != ms)),\n                    compression: compression\n                });\n                o += 30 + s + exl + l;\n                tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n                if (!--lft)\n                    cbf();\n            }\n        };\n        if (s > 65535)\n            cbl(err(11, 0, 1), null);\n        if (!compression)\n            cbl(null, file);\n        else if (size < 160000) {\n            try {\n                cbl(null, deflateSync(file, p));\n            }\n            catch (e) {\n                cbl(e, null);\n            }\n        }\n        else\n            term.push(deflate(file, p, cbl));\n    };\n    // Cannot use lft because it can decrease\n    for (var i = 0; i < slft; ++i) {\n        _loop_1(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously creates a ZIP file. Prefer using `zip` for better performance\n * with more than one file.\n * @param data The directory structure for the ZIP archive\n * @param opts The main options, merged with per-file options\n * @returns The generated ZIP archive\n */\nexport function zipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var r = {};\n    var files = [];\n    fltn(data, '', r, opts);\n    var o = 0;\n    var tot = 0;\n    for (var fn in r) {\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var compression = p.level == 0 ? 0 : 8;\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        if (s > 65535)\n            err(11);\n        var d = compression ? deflateSync(file, p) : file, l = d.length;\n        var c = crc();\n        c.p(file);\n        files.push(mrg(p, {\n            size: file.length,\n            crc: c.d(),\n            c: d,\n            f: f,\n            m: m,\n            u: s != fn.length || (m && (com.length != ms)),\n            o: o,\n            compression: compression\n        }));\n        o += 30 + s + exl + l;\n        tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n    }\n    var out = new u8(tot + 22), oe = o, cdl = tot - o;\n    for (var i = 0; i < files.length; ++i) {\n        var f = files[i];\n        wzh(out, f.o, f, f.f, f.u, f.c.length);\n        var badd = 30 + f.f.length + exfl(f.extra);\n        out.set(f.c, f.o + badd);\n        wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);\n    }\n    wzf(out, o, files.length, cdl, oe);\n    return out;\n}\n/**\n * Streaming pass-through decompression for ZIP archives\n */\nvar UnzipPassThrough = /*#__PURE__*/ (function () {\n    function UnzipPassThrough() {\n    }\n    UnzipPassThrough.prototype.push = function (data, final) {\n        this.ondata(null, data, final);\n    };\n    UnzipPassThrough.compression = 0;\n    return UnzipPassThrough;\n}());\nexport { UnzipPassThrough };\n/**\n * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for\n * better performance.\n */\nvar UnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function UnzipInflate() {\n        var _this_1 = this;\n        this.i = new Inflate(function (dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n    }\n    UnzipInflate.prototype.push = function (data, final) {\n        try {\n            this.i.push(data, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    UnzipInflate.compression = 8;\n    return UnzipInflate;\n}());\nexport { UnzipInflate };\n/**\n * Asynchronous streaming DEFLATE decompression for ZIP archives\n */\nvar AsyncUnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function AsyncUnzipInflate(_, sz) {\n        var _this_1 = this;\n        if (sz < 320000) {\n            this.i = new Inflate(function (dat, final) {\n                _this_1.ondata(null, dat, final);\n            });\n        }\n        else {\n            this.i = new AsyncInflate(function (err, dat, final) {\n                _this_1.ondata(err, dat, final);\n            });\n            this.terminate = this.i.terminate;\n        }\n    }\n    AsyncUnzipInflate.prototype.push = function (data, final) {\n        if (this.i.terminate)\n            data = slc(data, 0);\n        this.i.push(data, final);\n    };\n    AsyncUnzipInflate.compression = 8;\n    return AsyncUnzipInflate;\n}());\nexport { AsyncUnzipInflate };\n/**\n * A ZIP archive decompression stream that emits files as they are discovered\n */\nvar Unzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a ZIP decompression stream\n     * @param cb The callback to call whenever a file in the ZIP archive is found\n     */\n    function Unzip(cb) {\n        this.onfile = cb;\n        this.k = [];\n        this.o = {\n            0: UnzipPassThrough\n        };\n        this.p = et;\n    }\n    /**\n     * Pushes a chunk to be unzipped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzip.prototype.push = function (chunk, final) {\n        var _this_1 = this;\n        if (!this.onfile)\n            err(5);\n        if (!this.p)\n            err(4);\n        if (this.c > 0) {\n            var len = Math.min(this.c, chunk.length);\n            var toAdd = chunk.subarray(0, len);\n            this.c -= len;\n            if (this.d)\n                this.d.push(toAdd, !this.c);\n            else\n                this.k[0].push(toAdd);\n            chunk = chunk.subarray(len);\n            if (chunk.length)\n                return this.push(chunk, final);\n        }\n        else {\n            var f = 0, i = 0, is = void 0, buf = void 0;\n            if (!this.p.length)\n                buf = chunk;\n            else if (!chunk.length)\n                buf = this.p;\n            else {\n                buf = new u8(this.p.length + chunk.length);\n                buf.set(this.p), buf.set(chunk, this.p.length);\n            }\n            var l = buf.length, oc = this.c, add = oc && this.d;\n            var _loop_2 = function () {\n                var _a;\n                var sig = b4(buf, i);\n                if (sig == 0x4034B50) {\n                    f = 1, is = i;\n                    this_1.d = null;\n                    this_1.c = 0;\n                    var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);\n                    if (l > i + 30 + fnl + es) {\n                        var chks_3 = [];\n                        this_1.k.unshift(chks_3);\n                        f = 2;\n                        var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);\n                        var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);\n                        if (sc_1 == 4294967295) {\n                            _a = dd ? [-2] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];\n                        }\n                        else if (dd)\n                            sc_1 = -1;\n                        i += es;\n                        this_1.c = sc_1;\n                        var d_1;\n                        var file_1 = {\n                            name: fn_1,\n                            compression: cmp_1,\n                            start: function () {\n                                if (!file_1.ondata)\n                                    err(5);\n                                if (!sc_1)\n                                    file_1.ondata(null, et, true);\n                                else {\n                                    var ctr = _this_1.o[cmp_1];\n                                    if (!ctr)\n                                        file_1.ondata(err(14, 'unknown compression type ' + cmp_1, 1), null, false);\n                                    d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);\n                                    d_1.ondata = function (err, dat, final) { file_1.ondata(err, dat, final); };\n                                    for (var _i = 0, chks_4 = chks_3; _i < chks_4.length; _i++) {\n                                        var dat = chks_4[_i];\n                                        d_1.push(dat, false);\n                                    }\n                                    if (_this_1.k[0] == chks_3 && _this_1.c)\n                                        _this_1.d = d_1;\n                                    else\n                                        d_1.push(et, true);\n                                }\n                            },\n                            terminate: function () {\n                                if (d_1 && d_1.terminate)\n                                    d_1.terminate();\n                            }\n                        };\n                        if (sc_1 >= 0)\n                            file_1.size = sc_1, file_1.originalSize = su_1;\n                        this_1.onfile(file_1);\n                    }\n                    return \"break\";\n                }\n                else if (oc) {\n                    if (sig == 0x8074B50) {\n                        is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                    else if (sig == 0x2014B50) {\n                        is = i -= 4, f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                }\n            };\n            var this_1 = this;\n            for (; i < l - 4; ++i) {\n                var state_1 = _loop_2();\n                if (state_1 === \"break\")\n                    break;\n            }\n            this.p = et;\n            if (oc < 0) {\n                var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);\n                if (add)\n                    add.push(dat, !!f);\n                else\n                    this.k[+(f == 2)].push(dat);\n            }\n            if (f & 2)\n                return this.push(buf.subarray(i), final);\n            this.p = buf.subarray(i);\n        }\n        if (final) {\n            if (this.c)\n                err(13);\n            this.p = null;\n        }\n    };\n    /**\n     * Registers a decoder with the stream, allowing for files compressed with\n     * the compression type provided to be expanded correctly\n     * @param decoder The decoder constructor\n     */\n    Unzip.prototype.register = function (decoder) {\n        this.o[decoder.compression] = decoder;\n    };\n    return Unzip;\n}());\nexport { Unzip };\nvar mt = typeof queueMicrotask == 'function' ? queueMicrotask : typeof setTimeout == 'function' ? setTimeout : function (fn) { fn(); };\nexport function unzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var files = {};\n    var cbd = function (a, b) {\n        mt(function () { cb(a, b); });\n    };\n    mt(function () { cbd = cb; });\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558) {\n            cbd(err(13, 0, 1), null);\n            return tAll;\n        }\n    }\n    ;\n    var lft = b2(data, e + 8);\n    if (lft) {\n        var c = lft;\n        var o = b4(data, e + 16);\n        var z = o == 4294967295 || c == 65535;\n        if (z) {\n            var ze = b4(data, e - 12);\n            z = b4(data, ze) == 0x6064B50;\n            if (z) {\n                c = lft = b4(data, ze + 32);\n                o = b4(data, ze + 48);\n            }\n        }\n        var fltr = opts && opts.filter;\n        var _loop_3 = function (i) {\n            var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n            o = no;\n            var cbl = function (e, d) {\n                if (e) {\n                    tAll();\n                    cbd(e, null);\n                }\n                else {\n                    if (d)\n                        files[fn] = d;\n                    if (!--lft)\n                        cbd(null, files);\n                }\n            };\n            if (!fltr || fltr({\n                name: fn,\n                size: sc,\n                originalSize: su,\n                compression: c_1\n            })) {\n                if (!c_1)\n                    cbl(null, slc(data, b, b + sc));\n                else if (c_1 == 8) {\n                    var infl = data.subarray(b, b + sc);\n                    if (sc < 320000) {\n                        try {\n                            cbl(null, inflateSync(infl, new u8(su)));\n                        }\n                        catch (e) {\n                            cbl(e, null);\n                        }\n                    }\n                    else\n                        term.push(inflate(infl, { size: su }, cbl));\n                }\n                else\n                    cbl(err(14, 'unknown compression type ' + c_1, 1), null);\n            }\n            else\n                cbl(null, null);\n        };\n        for (var i = 0; i < c; ++i) {\n            _loop_3(i);\n        }\n    }\n    else\n        cbd(null, {});\n    return tAll;\n}\n/**\n * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better\n * performance with more than one file.\n * @param data The raw compressed ZIP file\n * @param opts The ZIP extraction options\n * @returns The decompressed files\n */\nexport function unzipSync(data, opts) {\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558)\n            err(13);\n    }\n    ;\n    var c = b2(data, e + 8);\n    if (!c)\n        return {};\n    var o = b4(data, e + 16);\n    var z = o == 4294967295 || c == 65535;\n    if (z) {\n        var ze = b4(data, e - 12);\n        z = b4(data, ze) == 0x6064B50;\n        if (z) {\n            c = b4(data, ze + 32);\n            o = b4(data, ze + 48);\n        }\n    }\n    var fltr = opts && opts.filter;\n    for (var i = 0; i < c; ++i) {\n        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        if (!fltr || fltr({\n            name: fn,\n            size: sc,\n            originalSize: su,\n            compression: c_2\n        })) {\n            if (!c_2)\n                files[fn] = slc(data, b, b + sc);\n            else if (c_2 == 8)\n                files[fn] = inflateSync(data.subarray(b, b + sc), new u8(su));\n            else\n                err(14, 'unknown compression type ' + c_2);\n        }\n    }\n    return files;\n}\n","import * as fflate from 'fflate';\nexport default class FFlateEncoder {\n    encode(arrayBuffer) {\n        return fflate.gzipSync(new Uint8Array(arrayBuffer)).buffer;\n    }\n    decode(arrayBuffer) {\n        return fflate.gunzipSync(new Uint8Array(arrayBuffer)).buffer;\n    }\n}\n","export const SPLIT_REGEX = /\\W+/g;\nexport const TEST_REGEX = /(\\w\\W+|\\W+\\w)/;\n/**\n * detect the type of a value\n *\n * @param value Value to analyze\n * @returns type of the value\n */\nexport function getType(value) {\n    if (Array.isArray(value)) {\n        return \"array\";\n    }\n    else if (typeof value === \"object\" && value) {\n        return \"object\";\n    }\n    else if (typeof value === \"string\" && TEST_REGEX.test(value)) {\n        return \"split\";\n    }\n    else {\n        return \"leaf\";\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport Loader from \"../io/Loader\";\nimport { getType, SPLIT_REGEX } from \"./Token\";\nimport md5 from \"blueimp-md5\";\n/**\n * Class for spitting objects into tokens.\n */\nexport default class Tokenizer {\n    constructor() {\n        this.loader = new Loader();\n    }\n    /**\n     * Load json or text files and turn them into tokens.\n     *\n     * @param files files to load and reduce.\n     */\n    load(...files) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (files.some(file => typeof file !== \"string\")) {\n                throw new Error(\"Each argument passed to load must be a string.\");\n            }\n            const sortedFiles = files.sort();\n            const allData = yield Promise.all(sortedFiles.map(this.loader.load));\n            const header = this.tokenize(Object.fromEntries(allData.map((data, index) => [sortedFiles[index], data])));\n            const textEncoder = new TextEncoder();\n            header.originalDataSize = textEncoder.encode(JSON.stringify(allData)).byteLength;\n            return header;\n        });\n    }\n    /**\n     * Takes a mapping of filename and their corresponding data, and turn them into tokens.\n     *\n     * @param items Mapping from filename to data.\n     * @returns All data stored as tokens.\n     */\n    tokenize(items) {\n        const header = {\n            registry: {},\n            files: {},\n        };\n        const counter = { next: 0 };\n        Object.entries(items).forEach(([file, value]) => {\n            header.files[file] = {\n                nameToken: this.tokenizeHelper(file, header.registry, counter, \"header\"),\n                token: this.tokenizeHelper(value, header.registry, counter, file),\n            };\n        });\n        return header;\n    }\n    registerToken(hash, value, registry, counter, file, reference) {\n        var _a;\n        const entry = (_a = registry[hash]) !== null && _a !== void 0 ? _a : (registry[hash] = {\n            type: getType(value),\n            hash,\n            value,\n            reference,\n            order: counter.next++,\n            count: 0,\n            files: new Set(),\n        });\n        entry.files.add(file);\n        entry.count++;\n        return entry;\n    }\n    tokenizeHelper(item, registry, counter, file) {\n        const type = getType(item);\n        if (type === \"array\") {\n            if (!Array.isArray(item)) {\n                throw new Error(\"item should be an array\");\n            }\n            const hashes = item.map(item => this.tokenizeHelper(item, registry, counter, file)).map(({ hash }) => hash);\n            const hash = md5(hashes.join(\",\"));\n            return this.registerToken(hash, item, registry, counter, file, hashes);\n        }\n        else if (type === \"object\") {\n            const entries = Object.entries(item);\n            const keysToken = this.tokenizeHelper(entries.map(([key]) => key), registry, counter, file);\n            const valuesToken = this.tokenizeHelper(entries.map(([, value]) => value), registry, counter, file);\n            const hash = md5(`${keysToken.hash}|${valuesToken.hash}`);\n            return this.registerToken(hash, item, registry, counter, file, [keysToken.hash, valuesToken.hash]);\n        }\n        else if (type === \"split\") {\n            const chunks = item.split(SPLIT_REGEX);\n            const separators = item.match(SPLIT_REGEX);\n            const chunksToken = this.tokenizeHelper(chunks, registry, counter, file);\n            const separatorsToken = this.tokenizeHelper(separators, registry, counter, file);\n            const hash = md5(`${chunksToken.hash}-${separatorsToken.hash}`);\n            return this.registerToken(hash, item, registry, counter, file, [chunksToken.hash, separatorsToken.hash]);\n        }\n        else {\n            const m = md5(JSON.stringify(item));\n            return this.registerToken(m, item, registry, counter, file);\n        }\n    }\n}\n","const DEFAULT_CONFIG = {\n    cacheable: true,\n    allowReferences: false,\n};\n/**\n * Class storing all data that can be extracted.\n */\nexport default class ExtractableData {\n    constructor(dataStore, config) {\n        this.extractor = new Extractor();\n        this.dataStore = dataStore;\n        this.config = Object.assign(Object.assign({}, DEFAULT_CONFIG), config);\n        this.fileNames = this.extractor.extractFileNames(dataStore.files, dataStore.headerTokens, this.config);\n        this.fileToSlot = Object.fromEntries(this.fileNames.map((file, index) => [file, index]));\n        this.version = dataStore.version;\n        this.originalDataSize = dataStore.originalDataSize;\n        this.compressedSize = dataStore.compressedSize;\n    }\n    /**\n     * Extract data form a stored file.\n     *\n     * @param filename filename to be extracted.\n     * @param allowReferences If true, within the extracted object, multiple nodes can reference the same object.\n     *  This helps performance and memory, but can lead to weird side effects if the extracted object\n     *  gets modified.\n     * @returns extracted data.\n     */\n    extract(filename, allowReferences) {\n        const slot = this.fileToSlot[filename];\n        const dataTokens = this.dataStore.getDataTokens(slot);\n        if (dataTokens) {\n            return this.extractor.extract(this.dataStore.headerTokens, dataTokens, Object.assign(Object.assign({}, this.config), { allowReferences: allowReferences !== null && allowReferences !== void 0 ? allowReferences : this.config.allowReferences }));\n        }\n    }\n    getHeaderTokens() {\n        return this.dataStore.headerTokens;\n    }\n}\nclass Extractor {\n    constructor() {\n        this.valueFetcher = {\n            \"array\": this.getArray.bind(this),\n            \"leaf\": undefined,\n            \"object\": this.getObject.bind(this),\n            \"split\": this.getSplit.bind(this),\n            \"reference\": this.getReference.bind(this),\n        };\n    }\n    extractFileNames(files, headerTokens, config) {\n        return files.map(index => this.extractToken(index, headerTokens, undefined, config));\n    }\n    extract(headerTokens, dataTokens, config) {\n        return this.extractToken(headerTokens.length + dataTokens.length - 1, headerTokens, dataTokens, config);\n    }\n    extractToken(index, headerTokens, dataTokens, config, forceAllowUseCache) {\n        const token = index < headerTokens.length ? headerTokens[index] : dataTokens === null || dataTokens === void 0 ? void 0 : dataTokens[index - headerTokens.length];\n        if (!token) {\n            throw new Error(\"Invalid token at index: \" + index);\n        }\n        if (token.type === \"leaf\") {\n            return token.value;\n        }\n        return this.extractValueOrCache(token, headerTokens, dataTokens, config, forceAllowUseCache || config.allowReferences, this.valueFetcher[token.type]);\n    }\n    getReference(token, headerTokens, dataTokens, config) {\n        const index = token.value;\n        return this.extractToken(index, headerTokens, dataTokens, config);\n    }\n    getArray(token, headerTokens, dataTokens, config) {\n        if (!Array.isArray(token.value)) {\n            throw new Error(\"Invalid array token\");\n        }\n        return token.value.map(index => this.extractToken(index, headerTokens, dataTokens, config));\n    }\n    getObject(token, headerTokens, dataTokens, config) {\n        const [keyIndex, valueIndex] = token.value;\n        const keys = this.extractToken(keyIndex, headerTokens, dataTokens, config, true);\n        const values = this.extractToken(valueIndex, headerTokens, dataTokens, config);\n        return Object.fromEntries(keys.map((key, index) => [key, values[index]]));\n    }\n    getSplit(token, headerTokens, dataTokens, config) {\n        const [chunksIndex, separatorsIndex] = token.value;\n        const chunks = this.extractToken(chunksIndex, headerTokens, dataTokens, config, true);\n        const separators = this.extractToken(separatorsIndex, headerTokens, dataTokens, config, true);\n        return chunks.map((chunk, index) => { var _a; return `${chunk}${(_a = separators[index]) !== null && _a !== void 0 ? _a : \"\"}`; }).join(\"\");\n    }\n    extractValueOrCache(token, headerTokens, dataTokens, config, allowUseCache, getValue) {\n        if (token.cache !== undefined && allowUseCache) {\n            return token.cache;\n        }\n        if (!getValue) {\n            throw new Error(\"getValue not provided.\");\n        }\n        const value = getValue(token, headerTokens, dataTokens, config);\n        if (config.cacheable) {\n            token.cache = value;\n        }\n        return value;\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport Reducer from \"../reducer/Reducer\";\nimport { StreamDataView } from \"stream-data-view\";\nimport TokenEncoder from \"./TokenEncoder\";\nimport FFlateEncoder from \"./FFlateEncoder\";\nimport { version } from '../../package.json';\nimport Tokenizer from \"../tokenizer/Tokenizer\";\nimport ExtractableData from \"../expander/Extractor\";\nvar EncoderEnum;\n(function (EncoderEnum) {\n    EncoderEnum[EncoderEnum[\"NONE\"] = 0] = \"NONE\";\n    EncoderEnum[EncoderEnum[\"FFLATE\"] = 1] = \"FFLATE\";\n})(EncoderEnum || (EncoderEnum = {}));\n;\nconst ENCODERS = [\n    () => undefined,\n    () => new FFlateEncoder(),\n];\nconst DEFAULT = [EncoderEnum.FFLATE];\nexport default class Compressor {\n    applyEncoders(buffer, encoders) {\n        let resultBuffer = buffer;\n        encoders.forEach(encoder => {\n            resultBuffer = encoder.encode(resultBuffer);\n        });\n        return resultBuffer;\n    }\n    applyDecoders(buffer, decoders) {\n        let resultBuffer = buffer;\n        decoders.forEach(decoder => {\n            resultBuffer = decoder.decode(resultBuffer);\n        });\n        return resultBuffer;\n    }\n    /**\n     * Load json or text files and compress them into one big blob.\n     * This uses the default encoders.\n     *\n     * @param files files to load.\n     */\n    loadAndCompress(files) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const tokenizer = new Tokenizer();\n            const header = yield tokenizer.load(...files);\n            const reducer = new Reducer();\n            const dataStore = reducer.reduce(header);\n            return this.compressDataStore(dataStore);\n        });\n    }\n    /**\n     * Compress data into one big blob.\n     * This uses the default encoders.\n     *\n     * @param files files to load.\n     */\n    compress(data) {\n        const tokenizer = new Tokenizer();\n        const header = tokenizer.tokenize(data);\n        const reducer = new Reducer();\n        const dataStore = reducer.reduce(header);\n        return this.compressDataStore(dataStore);\n    }\n    loadAndExpand(file) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield fetch(file);\n            const arrayBuffer = yield response.arrayBuffer();\n            return this.expand(arrayBuffer);\n        });\n    }\n    expand(arrayBuffer, config) {\n        return new ExtractableData(this.expandDataStore(arrayBuffer), config);\n    }\n    compressDataStore(dataStore, encoderEnums = DEFAULT) {\n        var _a;\n        const streamDataView = new StreamDataView();\n        const tokenEncoder = new TokenEncoder(streamDataView);\n        //  Write header tokens\n        tokenEncoder.encodeTokens(dataStore.headerTokens);\n        //  Write fileNames\n        tokenEncoder.encodeNumberArray(dataStore.files);\n        const finalStream = new StreamDataView();\n        //  Write version\n        finalStream.setNextUint8(version.length);\n        finalStream.setNextString(version);\n        //  Write encoders\n        encoderEnums.forEach(encoderEnum => finalStream.setNextUint8(encoderEnum));\n        finalStream.setNextUint8(0);\n        const encoders = encoderEnums\n            .map(encoderEnum => ENCODERS[encoderEnum]())\n            .filter((encoder) => !!encoder);\n        //  Write header\n        const headerBuffer = this.applyEncoders(streamDataView.getBuffer(), encoders);\n        finalStream.setNextUint32(headerBuffer.byteLength);\n        finalStream.setNextBytes(headerBuffer);\n        console.log(\"HEADER length\", headerBuffer.byteLength);\n        //  Write each file's data tokens.\n        for (let index = 0; index < dataStore.files.length; index++) {\n            const subStream = new StreamDataView();\n            const subEncoder = new TokenEncoder(subStream);\n            subEncoder.encodeTokens(dataStore.getDataTokens(index));\n            //  save and compress buffer\n            const subBuffer = this.applyEncoders(subStream.getBuffer(), encoders);\n            finalStream.setNextUint32(subBuffer.byteLength);\n            console.log(\"SUBBUFFER length\", index, subBuffer.byteLength);\n            finalStream.setNextBytes(subBuffer);\n        }\n        finalStream.setNextUint32(0);\n        //  Write original data size\n        finalStream.setNextUint32((_a = dataStore.originalDataSize) !== null && _a !== void 0 ? _a : 0);\n        return finalStream.getBuffer();\n    }\n    expandDataStore(arrayBuffer) {\n        const compressedSize = arrayBuffer.byteLength;\n        let input = arrayBuffer;\n        const globalStream = new StreamDataView(input);\n        const version = globalStream.getNextString(globalStream.getNextUint8());\n        const decoders = [];\n        do {\n            const encoderEnum = globalStream.getNextUint8();\n            if (encoderEnum === EncoderEnum.NONE) {\n                break;\n            }\n            const decoder = ENCODERS[encoderEnum]();\n            if (decoder) {\n                decoders.push(decoder);\n            }\n        } while (globalStream.getOffset() < globalStream.getLength());\n        const headerByteLength = globalStream.getNextUint32();\n        const headerBuffer = this.applyDecoders(globalStream.getNextBytes(headerByteLength).buffer, decoders);\n        const headerTokenEncoder = new TokenEncoder(new StreamDataView(headerBuffer));\n        const headerTokens = headerTokenEncoder.decodeTokens();\n        const files = headerTokenEncoder.decodeNumberArray();\n        const subBuffers = [];\n        do {\n            const byteLength = globalStream.getNextUint32();\n            if (!byteLength) {\n                break;\n            }\n            subBuffers.push(globalStream.getNextBytes(byteLength).buffer);\n        } while (globalStream.getOffset() < globalStream.getLength());\n        const getDataTokens = (index) => {\n            const subBuffer = this.applyDecoders(subBuffers[index], decoders);\n            const streamDataView = new StreamDataView(subBuffer);\n            const tokenDecoder = new TokenEncoder(streamDataView);\n            return tokenDecoder.decodeTokens();\n        };\n        //  The remaining from streamDataView is extra. Some compressed data don't have it.\n        let originalDataSize;\n        try {\n            originalDataSize = globalStream.getNextUint32() || undefined;\n        }\n        catch (e) {\n        }\n        return {\n            version,\n            originalDataSize,\n            compressedSize,\n            headerTokens,\n            files,\n            getDataTokens,\n        };\n    }\n}\n","import Loader from \"./io/Loader\";\nimport TokenEncoder from \"./compression/TokenEncoder\";\nimport Compressor from \"./compression/Compressor\";\nconst exportedClasses = {\n    Loader,\n    Compressor,\n    TokenEncoder,\n};\nexport default exportedClasses;\nglobalThis.exports = exportedClasses;\n"],"names":["$","safeAdd","x","y","lsw","md5cmn","q","a","b","s","t","num","cnt","md5ff","c","d","md5gg","md5hh","md5ii","binlMD5","len","i","olda","oldb","oldc","oldd","length","binl2rstr","input","output","length32","String","fromCharCode","rstr2binl","undefined","length8","charCodeAt","rstr2hex","hexTab","charAt","str2rstrUTF8","unescape","encodeURIComponent","rawMD5","rstrMD5","rawHMACMD5","k","key","data","hash","bkey","ipad","opad","concat","rstrHMACMD5","md5","string","raw","module","exports","e","n","o","Object","defineProperty","enumerable","get","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","StreamDataView","this","encoding","decode","apply","Array","from","decodeURIComponent","escape","encode","Uint8Array","split","map","offset","autoResize","ArrayBuffer","view","DataView","littleEndian","fromByteString","fromTextString","setNextString","resize","TypeError","byteLength","slice","set","buffer","getBuffer","crop","getOffset","skip","resetOffset","setOffset","getInt8","getUint8","getNextInt8","getNextUint8","getInt16","getUint16","getNextInt16","getNextUint16","getInt32","getUint32","getNextInt32","getNextUint32","getFloat32","getFloat64","getNextFloat32","getNextFloat64","setInt8","handleAutoResize","setUint8","setNextInt8","setNextUint8","setInt16","setUint16","setNextInt16","setNextUint16","setInt32","setUint32","setNextInt32","setNextUint32","setFloat32","setFloat64","setNextFloat32","setNextFloat64","getBytes","getNextBytes","setBytes","isArray","setNextBytes","getString","indexOf","getNextString","setString","toByteString","toString","join","toUpperCase","toTextString","parseInt","getLength","clear","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","getter","__esModule","definition","obj","prop","Loader","load","file","thisArg","_arguments","generator","response","fetch","pop","extension","json","text","P","Promise","resolve","reject","fulfilled","step","next","rejected","result","done","then","DataType","NUMBER_DATA_TYPES","UINT8","INT8","UINT16","INT16","UINT32","INT32","FLOAT32","FLOAT64","DataTypeUtils","numberSatisfyDataType","dataType","Math","fround","getBestType","array","some","number","every","min","max","getNumberDataType","type","UNDEFINED","getStringDataType","l","code","STRING","UNICODE","getFullTokenDataType","token","ARRAY_8","OBJECT_8","SPLIT_8","getDataType","indices","console","assert","EMPTY_ARRAY","bestType","OBJECT_16","OBJECT_32","SPLIT_16","SPLIT_32","OFFSET_ARRAY_8","OFFSET_ARRAY_16","OFFSET_ARRAY_32","ARRAY_16","ARRAY_32","NULL","BOOLEAN_TRUE","BOOLEAN_FALSE","REFERENCE_8","REFERENCE_16","REFERENCE_32","Error","dataTypeToType","TokenEncoder","constructor","streamDataView","dataTypeUtils","encodeTokens","tokens","pos","count","encodeMulti","decodeTokens","decodeMulti","encodeToken","multiInfo","usedDataType","encodeDataType","encodeSingleNumber","encodeString","encodeObjectToken","encodeSplitToken","encodeArrayToken","encodeReferenceToken","decodeToken","decodeDataType","decodeSingleNumber","decodeString","decodeObjectToken","decodeSplitToken","decodeArrayToken","isOffsetDataType","arrayToken","numberType","encodeNumberArray","decodeNumberArray","objectToken","keysIndex","valuesIndex","splitToken","chunksIndex","separatorsIndex","index","decodeReferenceToken","firstType","multiCount","maxCount","push","size","numbers","letterCodes","lastStringLength","forEach","charCodes","static","tokenEncoder","tokenDecoder","reset","testAction","header","fill","_","tester","info","check","JSON","stringify","decoded","Reducer","debug","reduce","hashToIndex","headerTokens","createReducedTokens","values","registry","filter","files","has","fileEntries","entries","sort","name1","name2","localeCompare","nameToken","dataTokens","root","subHashToIndex","assign","originalDataSize","getDataTokens","sortTokens","t1","t2","organizeTokens","buckets","bucket","resultTokens","organizedTokens","_a","_b","reference","createComplexObject","subTokens","u8","u16","Uint16Array","u32","Uint32Array","fleb","fdeb","clim","freb","eb","start","j","fl","revfl","fd","revfd","rev","hMap","cd","mb","co","le","rvb","sv","r_1","v","m","flt","fdt","flm","flrm","fdm","fdrm","bits","p","bits16","shft","slc","BYTES_PER_ELEMENT","subarray","ec","err","ind","msg","nt","captureStackTrace","wbits","wbits16","hTree","f","et","i0","i1","i2","maxSym","tr","mbt","ln","dt","lft","cst","i2_1","i2_2","i2_3","lc","cl","cli","cln","cls","w","clen","cf","wfblk","out","dat","wblk","final","syms","lf","df","li","bs","bl","dlt","mlb","ddt","mdb","_c","lclt","nlc","_d","lcdt","ndc","lcfreq","_e","lct","mlcb","nlcc","lm","ll","dm","dl","flen","ftlen","dtlen","llm","lcts","it","clct","dst","deo","crct","Int32Array","dopt","opt","pre","post","st","lvl","plvl","lst","ceil","msk_1","prev","head","bs1_1","bs2_1","hsh","lc_1","wi","hv","imod","pimod","rem","ch_1","dif","maxn","maxd","ml","nl","mmd","md","ti","lin","din","dflt","level","mem","log","wbytes","gzipSync","opts","cr","crc","filename","fn","mtime","floor","Date","now","gzh","gunzipSync","buf","sl","noBuf","noSt","cbuf","nbuf","bt","lbt","dbt","tbts","hLit","hcLen","tl","ldt","clt","clb","clbmsk","clm","lt","lms","dms","lpos","sym","add","dsym","end","inflt","flg","zs","gzs","td","TextDecoder","stream","queueMicrotask","setTimeout","FFlateEncoder","arrayBuffer","SPLIT_REGEX","TEST_REGEX","getType","test","Tokenizer","loader","sortedFiles","allData","all","tokenize","fromEntries","textEncoder","TextEncoder","items","counter","tokenizeHelper","registerToken","entry","order","Set","item","hashes","keysToken","valuesToken","chunks","separators","match","chunksToken","separatorsToken","DEFAULT_CONFIG","cacheable","allowReferences","ExtractableData","dataStore","config","extractor","Extractor","fileNames","extractFileNames","fileToSlot","version","compressedSize","extract","slot","getHeaderTokens","valueFetcher","getArray","bind","getObject","getSplit","getReference","extractToken","forceAllowUseCache","extractValueOrCache","keyIndex","valueIndex","keys","chunk","allowUseCache","getValue","cache","EncoderEnum","ENCODERS","DEFAULT","FFLATE","exportedClasses","Compressor","applyEncoders","encoders","resultBuffer","encoder","applyDecoders","decoders","decoder","loadAndCompress","tokenizer","compressDataStore","compress","loadAndExpand","expand","expandDataStore","encoderEnums","finalStream","encoderEnum","headerBuffer","subStream","subBuffer","globalStream","NONE","headerByteLength","headerTokenEncoder","subBuffers","globalThis"],"sourceRoot":""}