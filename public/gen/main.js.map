{"version":3,"file":"main.js","mappings":"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","sources":["webpack://@dobuki/compression/./node_modules/blueimp-md5/js/md5.js","webpack://@dobuki/compression/./node_modules/stream-data-view/dist/index.js","webpack://@dobuki/compression/webpack/bootstrap","webpack://@dobuki/compression/webpack/runtime/compat get default export","webpack://@dobuki/compression/webpack/runtime/define property getters","webpack://@dobuki/compression/webpack/runtime/hasOwnProperty shorthand","webpack://@dobuki/compression/./src/io/Loader.ts","webpack://@dobuki/compression/./src/compression/DataType.ts","webpack://@dobuki/compression/./src/compression/TokenEncoder.ts","webpack://@dobuki/compression/./src/reducer/Reducer.ts","webpack://@dobuki/compression/./node_modules/fflate/esm/browser.js","webpack://@dobuki/compression/./src/compression/FFlateEncoder.ts","webpack://@dobuki/compression/./src/tokenizer/Token.ts","webpack://@dobuki/compression/./src/tokenizer/Tokenizer.ts","webpack://@dobuki/compression/./src/expander/Extractor.ts","webpack://@dobuki/compression/./src/compression/Compressor.ts","webpack://@dobuki/compression/./src/index.ts"],"sourcesContent":["/*\n * JavaScript MD5\n * https://github.com/blueimp/JavaScript-MD5\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n *\n * Based on\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n * Digest Algorithm, as defined in RFC 1321.\n * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for more info.\n */\n\n/* global define */\n\n/* eslint-disable strict */\n\n;(function ($) {\n  'use strict'\n\n  /**\n   * Add integers, wrapping at 2^32.\n   * This uses 16-bit operations internally to work around bugs in interpreters.\n   *\n   * @param {number} x First integer\n   * @param {number} y Second integer\n   * @returns {number} Sum\n   */\n  function safeAdd(x, y) {\n    var lsw = (x & 0xffff) + (y & 0xffff)\n    var msw = (x >> 16) + (y >> 16) + (lsw >> 16)\n    return (msw << 16) | (lsw & 0xffff)\n  }\n\n  /**\n   * Bitwise rotate a 32-bit number to the left.\n   *\n   * @param {number} num 32-bit number\n   * @param {number} cnt Rotation count\n   * @returns {number} Rotated number\n   */\n  function bitRotateLeft(num, cnt) {\n    return (num << cnt) | (num >>> (32 - cnt))\n  }\n\n  /**\n   * Basic operation the algorithm uses.\n   *\n   * @param {number} q q\n   * @param {number} a a\n   * @param {number} b b\n   * @param {number} x x\n   * @param {number} s s\n   * @param {number} t t\n   * @returns {number} Result\n   */\n  function md5cmn(q, a, b, x, s, t) {\n    return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b)\n  }\n  /**\n   * Basic operation the algorithm uses.\n   *\n   * @param {number} a a\n   * @param {number} b b\n   * @param {number} c c\n   * @param {number} d d\n   * @param {number} x x\n   * @param {number} s s\n   * @param {number} t t\n   * @returns {number} Result\n   */\n  function md5ff(a, b, c, d, x, s, t) {\n    return md5cmn((b & c) | (~b & d), a, b, x, s, t)\n  }\n  /**\n   * Basic operation the algorithm uses.\n   *\n   * @param {number} a a\n   * @param {number} b b\n   * @param {number} c c\n   * @param {number} d d\n   * @param {number} x x\n   * @param {number} s s\n   * @param {number} t t\n   * @returns {number} Result\n   */\n  function md5gg(a, b, c, d, x, s, t) {\n    return md5cmn((b & d) | (c & ~d), a, b, x, s, t)\n  }\n  /**\n   * Basic operation the algorithm uses.\n   *\n   * @param {number} a a\n   * @param {number} b b\n   * @param {number} c c\n   * @param {number} d d\n   * @param {number} x x\n   * @param {number} s s\n   * @param {number} t t\n   * @returns {number} Result\n   */\n  function md5hh(a, b, c, d, x, s, t) {\n    return md5cmn(b ^ c ^ d, a, b, x, s, t)\n  }\n  /**\n   * Basic operation the algorithm uses.\n   *\n   * @param {number} a a\n   * @param {number} b b\n   * @param {number} c c\n   * @param {number} d d\n   * @param {number} x x\n   * @param {number} s s\n   * @param {number} t t\n   * @returns {number} Result\n   */\n  function md5ii(a, b, c, d, x, s, t) {\n    return md5cmn(c ^ (b | ~d), a, b, x, s, t)\n  }\n\n  /**\n   * Calculate the MD5 of an array of little-endian words, and a bit length.\n   *\n   * @param {Array} x Array of little-endian words\n   * @param {number} len Bit length\n   * @returns {Array<number>} MD5 Array\n   */\n  function binlMD5(x, len) {\n    /* append padding */\n    x[len >> 5] |= 0x80 << len % 32\n    x[(((len + 64) >>> 9) << 4) + 14] = len\n\n    var i\n    var olda\n    var oldb\n    var oldc\n    var oldd\n    var a = 1732584193\n    var b = -271733879\n    var c = -1732584194\n    var d = 271733878\n\n    for (i = 0; i < x.length; i += 16) {\n      olda = a\n      oldb = b\n      oldc = c\n      oldd = d\n\n      a = md5ff(a, b, c, d, x[i], 7, -680876936)\n      d = md5ff(d, a, b, c, x[i + 1], 12, -389564586)\n      c = md5ff(c, d, a, b, x[i + 2], 17, 606105819)\n      b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330)\n      a = md5ff(a, b, c, d, x[i + 4], 7, -176418897)\n      d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426)\n      c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341)\n      b = md5ff(b, c, d, a, x[i + 7], 22, -45705983)\n      a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416)\n      d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417)\n      c = md5ff(c, d, a, b, x[i + 10], 17, -42063)\n      b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162)\n      a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682)\n      d = md5ff(d, a, b, c, x[i + 13], 12, -40341101)\n      c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290)\n      b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329)\n\n      a = md5gg(a, b, c, d, x[i + 1], 5, -165796510)\n      d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632)\n      c = md5gg(c, d, a, b, x[i + 11], 14, 643717713)\n      b = md5gg(b, c, d, a, x[i], 20, -373897302)\n      a = md5gg(a, b, c, d, x[i + 5], 5, -701558691)\n      d = md5gg(d, a, b, c, x[i + 10], 9, 38016083)\n      c = md5gg(c, d, a, b, x[i + 15], 14, -660478335)\n      b = md5gg(b, c, d, a, x[i + 4], 20, -405537848)\n      a = md5gg(a, b, c, d, x[i + 9], 5, 568446438)\n      d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690)\n      c = md5gg(c, d, a, b, x[i + 3], 14, -187363961)\n      b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501)\n      a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467)\n      d = md5gg(d, a, b, c, x[i + 2], 9, -51403784)\n      c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473)\n      b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734)\n\n      a = md5hh(a, b, c, d, x[i + 5], 4, -378558)\n      d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463)\n      c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562)\n      b = md5hh(b, c, d, a, x[i + 14], 23, -35309556)\n      a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060)\n      d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353)\n      c = md5hh(c, d, a, b, x[i + 7], 16, -155497632)\n      b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640)\n      a = md5hh(a, b, c, d, x[i + 13], 4, 681279174)\n      d = md5hh(d, a, b, c, x[i], 11, -358537222)\n      c = md5hh(c, d, a, b, x[i + 3], 16, -722521979)\n      b = md5hh(b, c, d, a, x[i + 6], 23, 76029189)\n      a = md5hh(a, b, c, d, x[i + 9], 4, -640364487)\n      d = md5hh(d, a, b, c, x[i + 12], 11, -421815835)\n      c = md5hh(c, d, a, b, x[i + 15], 16, 530742520)\n      b = md5hh(b, c, d, a, x[i + 2], 23, -995338651)\n\n      a = md5ii(a, b, c, d, x[i], 6, -198630844)\n      d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415)\n      c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905)\n      b = md5ii(b, c, d, a, x[i + 5], 21, -57434055)\n      a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571)\n      d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606)\n      c = md5ii(c, d, a, b, x[i + 10], 15, -1051523)\n      b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799)\n      a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359)\n      d = md5ii(d, a, b, c, x[i + 15], 10, -30611744)\n      c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380)\n      b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649)\n      a = md5ii(a, b, c, d, x[i + 4], 6, -145523070)\n      d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379)\n      c = md5ii(c, d, a, b, x[i + 2], 15, 718787259)\n      b = md5ii(b, c, d, a, x[i + 9], 21, -343485551)\n\n      a = safeAdd(a, olda)\n      b = safeAdd(b, oldb)\n      c = safeAdd(c, oldc)\n      d = safeAdd(d, oldd)\n    }\n    return [a, b, c, d]\n  }\n\n  /**\n   * Convert an array of little-endian words to a string\n   *\n   * @param {Array<number>} input MD5 Array\n   * @returns {string} MD5 string\n   */\n  function binl2rstr(input) {\n    var i\n    var output = ''\n    var length32 = input.length * 32\n    for (i = 0; i < length32; i += 8) {\n      output += String.fromCharCode((input[i >> 5] >>> i % 32) & 0xff)\n    }\n    return output\n  }\n\n  /**\n   * Convert a raw string to an array of little-endian words\n   * Characters >255 have their high-byte silently ignored.\n   *\n   * @param {string} input Raw input string\n   * @returns {Array<number>} Array of little-endian words\n   */\n  function rstr2binl(input) {\n    var i\n    var output = []\n    output[(input.length >> 2) - 1] = undefined\n    for (i = 0; i < output.length; i += 1) {\n      output[i] = 0\n    }\n    var length8 = input.length * 8\n    for (i = 0; i < length8; i += 8) {\n      output[i >> 5] |= (input.charCodeAt(i / 8) & 0xff) << i % 32\n    }\n    return output\n  }\n\n  /**\n   * Calculate the MD5 of a raw string\n   *\n   * @param {string} s Input string\n   * @returns {string} Raw MD5 string\n   */\n  function rstrMD5(s) {\n    return binl2rstr(binlMD5(rstr2binl(s), s.length * 8))\n  }\n\n  /**\n   * Calculates the HMAC-MD5 of a key and some data (raw strings)\n   *\n   * @param {string} key HMAC key\n   * @param {string} data Raw input string\n   * @returns {string} Raw MD5 string\n   */\n  function rstrHMACMD5(key, data) {\n    var i\n    var bkey = rstr2binl(key)\n    var ipad = []\n    var opad = []\n    var hash\n    ipad[15] = opad[15] = undefined\n    if (bkey.length > 16) {\n      bkey = binlMD5(bkey, key.length * 8)\n    }\n    for (i = 0; i < 16; i += 1) {\n      ipad[i] = bkey[i] ^ 0x36363636\n      opad[i] = bkey[i] ^ 0x5c5c5c5c\n    }\n    hash = binlMD5(ipad.concat(rstr2binl(data)), 512 + data.length * 8)\n    return binl2rstr(binlMD5(opad.concat(hash), 512 + 128))\n  }\n\n  /**\n   * Convert a raw string to a hex string\n   *\n   * @param {string} input Raw input string\n   * @returns {string} Hex encoded string\n   */\n  function rstr2hex(input) {\n    var hexTab = '0123456789abcdef'\n    var output = ''\n    var x\n    var i\n    for (i = 0; i < input.length; i += 1) {\n      x = input.charCodeAt(i)\n      output += hexTab.charAt((x >>> 4) & 0x0f) + hexTab.charAt(x & 0x0f)\n    }\n    return output\n  }\n\n  /**\n   * Encode a string as UTF-8\n   *\n   * @param {string} input Input string\n   * @returns {string} UTF8 string\n   */\n  function str2rstrUTF8(input) {\n    return unescape(encodeURIComponent(input))\n  }\n\n  /**\n   * Encodes input string as raw MD5 string\n   *\n   * @param {string} s Input string\n   * @returns {string} Raw MD5 string\n   */\n  function rawMD5(s) {\n    return rstrMD5(str2rstrUTF8(s))\n  }\n  /**\n   * Encodes input string as Hex encoded string\n   *\n   * @param {string} s Input string\n   * @returns {string} Hex encoded string\n   */\n  function hexMD5(s) {\n    return rstr2hex(rawMD5(s))\n  }\n  /**\n   * Calculates the raw HMAC-MD5 for the given key and data\n   *\n   * @param {string} k HMAC key\n   * @param {string} d Input string\n   * @returns {string} Raw MD5 string\n   */\n  function rawHMACMD5(k, d) {\n    return rstrHMACMD5(str2rstrUTF8(k), str2rstrUTF8(d))\n  }\n  /**\n   * Calculates the Hex encoded HMAC-MD5 for the given key and data\n   *\n   * @param {string} k HMAC key\n   * @param {string} d Input string\n   * @returns {string} Raw MD5 string\n   */\n  function hexHMACMD5(k, d) {\n    return rstr2hex(rawHMACMD5(k, d))\n  }\n\n  /**\n   * Calculates MD5 value for a given string.\n   * If a key is provided, calculates the HMAC-MD5 value.\n   * Returns a Hex encoded string unless the raw argument is given.\n   *\n   * @param {string} string Input string\n   * @param {string} [key] HMAC key\n   * @param {boolean} [raw] Raw output switch\n   * @returns {string} MD5 output\n   */\n  function md5(string, key, raw) {\n    if (!key) {\n      if (!raw) {\n        return hexMD5(string)\n      }\n      return rawMD5(string)\n    }\n    if (!raw) {\n      return hexHMACMD5(key, string)\n    }\n    return rawHMACMD5(key, string)\n  }\n\n  if (typeof define === 'function' && define.amd) {\n    define(function () {\n      return md5\n    })\n  } else if (typeof module === 'object' && module.exports) {\n    module.exports = md5\n  } else {\n    $.md5 = md5\n  }\n})(this)\n","!function(t,e){if(\"object\"==typeof exports&&\"object\"==typeof module)module.exports=e();else if(\"function\"==typeof define&&define.amd)define([],e);else{var n=e();for(var i in n)(\"object\"==typeof exports?exports:t)[i]=n[i]}}(this,(function(){return(()=>{\"use strict\";var t={d:(e,n)=>{for(var i in n)t.o(n,i)&&!t.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:n[i]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(t,\"__esModule\",{value:!0})}},e={};t.r(e),t.d(e,{StreamDataView:()=>o});var n=function(){function t(t){this.encoding=t||\"utf-8\"}return t.prototype.decode=function(t){var e=String.fromCharCode.apply(null,Array.from(t));return\"utf-8\"===this.encoding?decodeURIComponent(escape(e)):e},t}(),i=function(){function t(t){this.encoding=t||\"utf-8\"}return t.prototype.encode=function(t){return\"utf-8\"===this.encoding&&(t=unescape(encodeURIComponent(t))),new Uint8Array(t.split(\"\").map((function(t){return t.charCodeAt(0)})))},t}(),o=function(){function t(t,e){this.offset=0,this.autoResize=!1,void 0===t&&(t=0,this.autoResize=!0),\"number\"==typeof t&&(t=new ArrayBuffer(t)),this.view=new DataView(t),this.littleEndian=!e}return t.fromByteString=function(e){var n=new t(e.split(\" \").length);return n.fromByteString(e),n},t.fromTextString=function(e,n){var o,s=new t((o=n?new i(\"utf-8\").encode(e):new i(\"ascii\").encode(e)).length);return s.setNextString(e,n,o.length),s},t.prototype.resize=function(t){var e=function(t,e){if(!(t instanceof ArrayBuffer))throw new TypeError(\"Source must be an instance of ArrayBuffer\");if(e<=t.byteLength)return t.slice(0,e);var n=new Uint8Array(t),i=new Uint8Array(new ArrayBuffer(e));return i.set(n),i.buffer}(this.getBuffer(),t);this.view=new DataView(e)},t.prototype.crop=function(){this.resize(this.getOffset())},t.prototype.getBuffer=function(){return this.view.buffer},t.prototype.skip=function(t){this.offset+=t},t.prototype.resetOffset=function(){this.offset=0},t.prototype.getOffset=function(){return this.offset},t.prototype.setOffset=function(t){this.offset=t},t.prototype.getInt8=function(t){return this.view.getInt8(t)},t.prototype.getUint8=function(t){return this.view.getUint8(t)},t.prototype.getNextInt8=function(){var t=this.getInt8(this.offset);return this.offset+=1,t},t.prototype.getNextUint8=function(){var t=this.getUint8(this.offset);return this.offset+=1,t},t.prototype.getInt16=function(t){return this.view.getInt16(t,this.littleEndian)},t.prototype.getUint16=function(t){return this.view.getUint16(t,this.littleEndian)},t.prototype.getNextInt16=function(){var t=this.getInt16(this.offset);return this.offset+=2,t},t.prototype.getNextUint16=function(){var t=this.getUint16(this.offset);return this.offset+=2,t},t.prototype.getInt32=function(t){return this.view.getInt32(t,this.littleEndian)},t.prototype.getUint32=function(t){return this.view.getUint32(t,this.littleEndian)},t.prototype.getNextInt32=function(){var t=this.getInt32(this.offset);return this.offset+=4,t},t.prototype.getNextUint32=function(){var t=this.getUint32(this.offset);return this.offset+=4,t},t.prototype.getFloat32=function(t){return this.view.getFloat32(t,this.littleEndian)},t.prototype.getFloat64=function(t){return this.view.getFloat64(t,this.littleEndian)},t.prototype.getNextFloat32=function(){var t=this.getFloat32(this.offset);return this.offset+=4,t},t.prototype.getNextFloat64=function(){var t=this.getFloat64(this.offset);return this.offset+=8,t},t.prototype.setInt8=function(t,e){this.handleAutoResize(t,1),this.view.setInt8(t,e)},t.prototype.setUint8=function(t,e){this.handleAutoResize(t,1),this.view.setUint8(t,e)},t.prototype.setNextInt8=function(t){this.setInt8(this.offset,t),this.offset+=1},t.prototype.setNextUint8=function(t){this.setUint8(this.offset,t),this.offset+=1},t.prototype.setInt16=function(t,e){this.handleAutoResize(t,2),this.view.setInt16(t,e,this.littleEndian)},t.prototype.setUint16=function(t,e){this.handleAutoResize(t,2),this.view.setUint16(t,e,this.littleEndian)},t.prototype.setNextInt16=function(t){this.setInt16(this.offset,t),this.offset+=2},t.prototype.setNextUint16=function(t){this.setUint16(this.offset,t),this.offset+=2},t.prototype.setInt32=function(t,e){this.handleAutoResize(t,4),this.view.setInt32(t,e,this.littleEndian)},t.prototype.setUint32=function(t,e){this.handleAutoResize(t,4),this.view.setUint32(t,e,this.littleEndian)},t.prototype.setNextInt32=function(t){this.setInt32(this.offset,t),this.offset+=4},t.prototype.setNextUint32=function(t){this.setUint32(this.offset,t),this.offset+=4},t.prototype.setFloat32=function(t,e){this.handleAutoResize(t,8),this.view.setFloat32(t,e,this.littleEndian)},t.prototype.setFloat64=function(t,e){this.handleAutoResize(t,8),this.view.setFloat64(t,e,this.littleEndian)},t.prototype.setNextFloat32=function(t){this.setFloat32(this.offset,t),this.offset+=4},t.prototype.setNextFloat64=function(t){this.setFloat64(this.offset,t),this.offset+=8},t.prototype.getBytes=function(t,e){void 0===t&&(t=0),e=e||this.view.buffer.byteLength-t;var n=this.getBuffer().slice(t,t+e);return new Uint8Array(n)},t.prototype.getNextBytes=function(t){var e=this.getBytes(this.offset,t);return this.offset+=t||0,e},t.prototype.setBytes=function(t,e){(e instanceof ArrayBuffer||Array.isArray(e))&&(e=new Uint8Array(e));var n=e;this.handleAutoResize(t,n.byteLength);for(var i=0;i<n.byteLength;i++)this.setUint8(t+i,n[i])},t.prototype.setNextBytes=function(t){Array.isArray(t)&&(t=new Uint8Array(t)),this.setBytes(this.offset,t),this.offset+=t.byteLength},t.prototype.getString=function(t,e,i,o){var s=this.getBytes(t,e);if(o){var r=s.indexOf(0);r>=0&&(s=s.slice(0,r))}return i?new n(\"utf-8\").decode(s):new n(\"ascii\").decode(s)},t.prototype.getNextString=function(t,e,n){var i=this.getString(this.offset,t,e,n);return this.offset+=t,i},t.prototype.setString=function(t,e,n,o){var s;s=n?new i(\"utf-8\").encode(e):new i(\"ascii\").encode(e),o=\"number\"==typeof o?o:s.byteLength,this.handleAutoResize(t,o);for(var r=0;r<o;r++)this.view.setUint8(t+r,s[r]||0);return o},t.prototype.setNextString=function(t,e,n){this.offset+=this.setString(this.offset,t,e,n)},t.prototype.toByteString=function(){return Array.from(new Uint8Array(this.getBuffer())).map((function(t){return(\"00\"+t.toString(16)).slice(-2)})).join(\" \").toUpperCase()},t.prototype.toTextString=function(t){return this.getString(0,this.view.byteLength,t)},t.prototype.fromByteString=function(t){var e=t.split(\" \"),n=new ArrayBuffer(e.length);this.view=new DataView(n),this.setNextBytes(new Uint8Array(e.map((function(t){return parseInt(t,16)})))),this.resetOffset()},t.prototype.getLength=function(){return this.view.byteLength},t.prototype.clear=function(){this.view=new DataView(new ArrayBuffer(this.view.byteLength)),this.offset=0},t.prototype.handleAutoResize=function(t,e){this.autoResize&&this.getBuffer().byteLength<t+e&&this.resize(t+e)},t}();return e})()}));","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nfunction extension(file) {\n    return file.split(\".\").pop();\n}\nexport default class Loader {\n    load(file) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield fetch(file);\n            return extension(file) === \"json\" ? yield response.json() : yield response.text();\n        });\n    }\n}\n","export var StructureType;\n(function (StructureType) {\n    StructureType[StructureType[\"LEAF\"] = 0] = \"LEAF\";\n    StructureType[StructureType[\"ARRAY\"] = 1] = \"ARRAY\";\n    StructureType[StructureType[\"OBJECT\"] = 2] = \"OBJECT\";\n    StructureType[StructureType[\"SPLIT\"] = 3] = \"SPLIT\";\n})(StructureType || (StructureType = {}));\n;\nexport var DataType;\n(function (DataType) {\n    DataType[DataType[\"UNDEFINED\"] = 0] = \"UNDEFINED\";\n    DataType[DataType[\"NULL\"] = 1] = \"NULL\";\n    DataType[DataType[\"BOOLEAN_FALSE\"] = 2] = \"BOOLEAN_FALSE\";\n    DataType[DataType[\"BOOLEAN_TRUE\"] = 3] = \"BOOLEAN_TRUE\";\n    DataType[DataType[\"INT8\"] = 4] = \"INT8\";\n    DataType[DataType[\"UINT8\"] = 5] = \"UINT8\";\n    DataType[DataType[\"INT16\"] = 6] = \"INT16\";\n    DataType[DataType[\"UINT16\"] = 7] = \"UINT16\";\n    DataType[DataType[\"INT32\"] = 8] = \"INT32\";\n    DataType[DataType[\"UINT32\"] = 9] = \"UINT32\";\n    DataType[DataType[\"FLOAT32\"] = 10] = \"FLOAT32\";\n    DataType[DataType[\"FLOAT64\"] = 11] = \"FLOAT64\";\n    DataType[DataType[\"STRING\"] = 12] = \"STRING\";\n    DataType[DataType[\"UNICODE\"] = 13] = \"UNICODE\";\n    DataType[DataType[\"OBJECT_8\"] = 17] = \"OBJECT_8\";\n    DataType[DataType[\"OBJECT_16\"] = 18] = \"OBJECT_16\";\n    DataType[DataType[\"OBJECT_32\"] = 19] = \"OBJECT_32\";\n    DataType[DataType[\"SPLIT_8\"] = 20] = \"SPLIT_8\";\n    DataType[DataType[\"SPLIT_16\"] = 21] = \"SPLIT_16\";\n    DataType[DataType[\"SPLIT_32\"] = 22] = \"SPLIT_32\";\n    DataType[DataType[\"ARRAY_8\"] = 23] = \"ARRAY_8\";\n    DataType[DataType[\"ARRAY_16\"] = 24] = \"ARRAY_16\";\n    DataType[DataType[\"ARRAY_32\"] = 25] = \"ARRAY_32\";\n    DataType[DataType[\"OFFSET_ARRAY_8\"] = 26] = \"OFFSET_ARRAY_8\";\n    DataType[DataType[\"OFFSET_ARRAY_16\"] = 27] = \"OFFSET_ARRAY_16\";\n    DataType[DataType[\"OFFSET_ARRAY_32\"] = 28] = \"OFFSET_ARRAY_32\";\n    DataType[DataType[\"EMPTY_ARRAY\"] = 29] = \"EMPTY_ARRAY\";\n    DataType[DataType[\"REFERENCE_8\"] = 30] = \"REFERENCE_8\";\n    DataType[DataType[\"REFERENCE_16\"] = 31] = \"REFERENCE_16\";\n    DataType[DataType[\"REFERENCE_32\"] = 32] = \"REFERENCE_32\";\n    DataType[DataType[\"COMPLEX_OBJECT\"] = 33] = \"COMPLEX_OBJECT\";\n    DataType[DataType[\"UINT2\"] = 34] = \"UINT2\";\n    DataType[DataType[\"UINT4\"] = 35] = \"UINT4\";\n})(DataType || (DataType = {}));\nexport const NUMBER_DATA_TYPES = [\n    DataType.UINT8,\n    DataType.INT8,\n    DataType.UINT16,\n    DataType.INT16,\n    DataType.UINT32,\n    DataType.INT32,\n    DataType.FLOAT32,\n    DataType.FLOAT64,\n];\nexport class DataTypeUtils {\n    numberSatisfyDataType(value, dataType) {\n        const hasDecimal = value % 1 !== 0;\n        if (hasDecimal) {\n            switch (dataType) {\n                case DataType.FLOAT32:\n                    return Math.fround(value) === value;\n                case DataType.FLOAT64:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n        switch (dataType) {\n            case DataType.UINT8:\n                return value >= 0 && value <= 255;\n            case DataType.INT8:\n                return value >= -128 && value <= 127;\n            case DataType.UINT16:\n                return value >= 0 && value <= 65535;\n            case DataType.INT16:\n                return value >= -32768 && value <= 32767;\n            case DataType.UINT32:\n                return value >= 0;\n            case DataType.INT32:\n                return true;\n        }\n        return false;\n    }\n    getBestType(array) {\n        if (array.some(number => number % 1 !== 0)) {\n            //  decimal\n            if (array.every(number => this.numberSatisfyDataType(number, DataType.FLOAT32))) {\n                return DataType.FLOAT32;\n            }\n            return DataType.FLOAT64;\n        }\n        const min = Math.min(...array);\n        const max = Math.max(...array);\n        for (let dataType of NUMBER_DATA_TYPES) {\n            if (this.numberSatisfyDataType(min, dataType) && this.numberSatisfyDataType(max, dataType)) {\n                return dataType;\n            }\n        }\n        return DataType.FLOAT64;\n    }\n    getNumberDataType(value) {\n        for (let type of NUMBER_DATA_TYPES) {\n            if (this.numberSatisfyDataType(value, type)) {\n                return type;\n            }\n        }\n        return DataType.UNDEFINED;\n    }\n    getStringDataType(value, noSet = false) {\n        const letterCodes = value.split(\"\").map(l => l.charCodeAt(0));\n        if (letterCodes.every(code => code <= 255)) {\n            return DataType.STRING;\n        }\n        else {\n            return DataType.UNICODE;\n        }\n    }\n    getFullTokenDataType(token) {\n        switch (token.type) {\n            case \"array\":\n                return DataType.ARRAY_8;\n            case \"object\":\n                return DataType.OBJECT_8;\n            case \"split\":\n                return DataType.SPLIT_8;\n            default:\n                return this.getDataType(token);\n        }\n    }\n    getDataType(token) {\n        switch (token.type) {\n            case \"complex\":\n                return DataType.COMPLEX_OBJECT;\n            case \"array\":\n            case \"object\":\n            case \"split\":\n                let indices = token.value;\n                if (!indices.length) {\n                    console.assert(token.type === \"array\");\n                    return DataType.EMPTY_ARRAY;\n                }\n                let offset = 0;\n                if (token.type === \"array\" && indices.length > 3) {\n                    const min = Math.min(...indices);\n                    const max = Math.max(...indices);\n                    if (this.getNumberDataType(max - min) !== this.getNumberDataType(max)) {\n                        offset = min;\n                    }\n                    indices = indices.map(value => value - offset);\n                }\n                const bestType = this.getBestType(indices);\n                switch (token.type) {\n                    case \"object\":\n                        return bestType === DataType.UINT8\n                            ? DataType.OBJECT_8\n                            : bestType === DataType.UINT16\n                                ? DataType.OBJECT_16\n                                : DataType.OBJECT_32;\n                    case \"split\":\n                        return bestType === DataType.UINT8\n                            ? DataType.SPLIT_8\n                            : bestType === DataType.UINT16\n                                ? DataType.SPLIT_16\n                                : DataType.SPLIT_32;\n                    case \"array\":\n                        if (offset) {\n                            return bestType === DataType.UINT8\n                                ? DataType.OFFSET_ARRAY_8\n                                : bestType === DataType.UINT16\n                                    ? DataType.OFFSET_ARRAY_16\n                                    : DataType.OFFSET_ARRAY_32;\n                        }\n                        else {\n                            return bestType === DataType.UINT8\n                                ? DataType.ARRAY_8\n                                : bestType === DataType.UINT16\n                                    ? DataType.ARRAY_16\n                                    : DataType.ARRAY_32;\n                        }\n                }\n            case \"leaf\":\n                if (token.value === undefined) {\n                    return DataType.UNDEFINED;\n                }\n                else if (token.value === null) {\n                    return DataType.NULL;\n                }\n                else {\n                    switch (typeof token.value) {\n                        case \"boolean\":\n                            return token.value ? DataType.BOOLEAN_TRUE : DataType.BOOLEAN_FALSE;\n                        case \"string\":\n                            return this.getStringDataType(token.value);\n                        case \"number\":\n                            return this.getNumberDataType(token.value);\n                    }\n                }\n                break;\n            case \"reference\":\n                switch (this.getNumberDataType(token.value)) {\n                    case DataType.UINT8:\n                        return DataType.REFERENCE_8;\n                    case DataType.UINT16:\n                        return DataType.REFERENCE_16;\n                    case DataType.UINT32:\n                        return DataType.REFERENCE_32;\n                }\n                throw new Error(\"Invalid reference value: \" + token.value);\n        }\n        throw new Error(`Unrecognized type for ${token.type} value: ${token.value}`);\n    }\n    dataTypeToType(dataType) {\n        switch (dataType) {\n            case DataType.COMPLEX_OBJECT:\n                return \"complex\";\n            case DataType.EMPTY_ARRAY:\n            case DataType.ARRAY_8:\n            case DataType.ARRAY_16:\n            case DataType.ARRAY_32:\n                return \"array\";\n            case DataType.OBJECT_8:\n            case DataType.OBJECT_16:\n            case DataType.OBJECT_32:\n                return \"object\";\n            case DataType.SPLIT_8:\n            case DataType.SPLIT_16:\n            case DataType.SPLIT_32:\n                return \"split\";\n            case DataType.REFERENCE_8:\n            case DataType.REFERENCE_16:\n            case DataType.REFERENCE_32:\n                return \"reference\";\n            default:\n                return \"leaf\";\n        }\n    }\n    typeToStructureType(type) {\n        switch (type) {\n            case \"leaf\":\n                return StructureType.LEAF;\n            case \"array\":\n                return StructureType.ARRAY;\n            case \"object\":\n                return StructureType.OBJECT;\n            case \"split\":\n                return StructureType.SPLIT;\n        }\n        throw new Error(\"Cannot translate to structure type: \" + type);\n    }\n}\n","//13093\nimport { StreamDataView } from \"stream-data-view\";\nimport { DataType, DataTypeUtils } from \"./DataType\";\nconst MAX_ARRAY_SIZE = 255;\nexport default class TokenEncoder {\n    constructor(streamDataView) {\n        this.streamDataView = streamDataView;\n        this.dataTypeUtils = new DataTypeUtils();\n    }\n    encodeTokens(tokens, organized) {\n        let pos = 0;\n        while (pos < tokens.length) {\n            const count = this.encodeMulti(tokens, pos, organized);\n            if (count) {\n                pos += count;\n            }\n        }\n        this.encodeMulti([], pos, organized);\n    }\n    decodeTokens(organized) {\n        const tokens = [];\n        while (this.streamDataView.getOffset() < this.streamDataView.getLength()) {\n            if (!this.decodeMulti(tokens, organized)) {\n                break;\n            }\n        }\n        return tokens;\n    }\n    encodeToken(token, dataType, multiInfo) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.encodeDataType(this.dataTypeUtils.getDataType(token));\n        switch (usedDataType) {\n            case DataType.UNDEFINED:\n            case DataType.NULL:\n            case DataType.BOOLEAN_TRUE:\n            case DataType.BOOLEAN_FALSE:\n            case DataType.EMPTY_ARRAY:\n                break;\n            case DataType.INT8:\n            case DataType.UINT8:\n            case DataType.INT16:\n            case DataType.UINT16:\n            case DataType.INT32:\n            case DataType.UINT32:\n            case DataType.FLOAT32:\n            case DataType.FLOAT64:\n                this.encodeSingleNumber(token.value, usedDataType);\n                break;\n            case DataType.STRING:\n            case DataType.UNICODE:\n                this.encodeString(token.value, usedDataType, multiInfo);\n                break;\n            case DataType.OBJECT_8:\n            case DataType.OBJECT_16:\n            case DataType.OBJECT_32:\n                this.encodeObjectToken(token, usedDataType);\n                break;\n            case DataType.SPLIT_8:\n            case DataType.SPLIT_16:\n            case DataType.SPLIT_32:\n                this.encodeSplitToken(token, usedDataType);\n                break;\n            case DataType.ARRAY_8:\n            case DataType.ARRAY_16:\n            case DataType.ARRAY_32:\n            case DataType.OFFSET_ARRAY_8:\n            case DataType.OFFSET_ARRAY_16:\n            case DataType.OFFSET_ARRAY_32:\n                this.encodeArrayToken(token, usedDataType);\n                break;\n            case DataType.REFERENCE_8:\n            case DataType.REFERENCE_16:\n            case DataType.REFERENCE_32:\n                this.encodeReferenceToken(token, usedDataType);\n                break;\n            case DataType.COMPLEX_OBJECT:\n                this.encodeComplexToken(token, usedDataType);\n                break;\n            default:\n                throw new Error(\"Invalid dataType: \" + usedDataType);\n        }\n    }\n    decodeToken(dataType, multiInfo) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.decodeDataType();\n        switch (usedDataType) {\n            case DataType.UNDEFINED:\n                return { type: \"leaf\", value: undefined };\n            case DataType.NULL:\n                return { type: \"leaf\", value: null };\n            case DataType.BOOLEAN_TRUE:\n                return { type: \"leaf\", value: true };\n            case DataType.BOOLEAN_FALSE:\n                return { type: \"leaf\", value: false };\n            case DataType.EMPTY_ARRAY:\n                return { type: \"array\", value: [] };\n            case DataType.UINT2:\n            case DataType.UINT4:\n                throw new Error(\"Use decode number array.\");\n            case DataType.INT8:\n            case DataType.UINT8:\n            case DataType.INT16:\n            case DataType.UINT16:\n            case DataType.INT32:\n            case DataType.UINT32:\n            case DataType.FLOAT32:\n            case DataType.FLOAT64:\n                return { type: \"leaf\", value: this.decodeSingleNumber(usedDataType) };\n            case DataType.STRING:\n            case DataType.UNICODE:\n                return { type: \"leaf\", value: this.decodeString(usedDataType, multiInfo) };\n            case DataType.OBJECT_8:\n            case DataType.OBJECT_16:\n            case DataType.OBJECT_32:\n                return this.decodeObjectToken(usedDataType);\n            case DataType.SPLIT_8:\n            case DataType.SPLIT_16:\n            case DataType.SPLIT_32:\n                return this.decodeSplitToken(usedDataType);\n            case DataType.ARRAY_8:\n            case DataType.ARRAY_16:\n            case DataType.ARRAY_32:\n            case DataType.OFFSET_ARRAY_8:\n            case DataType.OFFSET_ARRAY_16:\n            case DataType.OFFSET_ARRAY_32:\n                return this.decodeArrayToken(usedDataType);\n            case DataType.REFERENCE_8:\n            case DataType.REFERENCE_16:\n            case DataType.REFERENCE_32:\n                return this.decodeReferenceToken(usedDataType);\n            case DataType.COMPLEX_OBJECT:\n                return this.decodeComplexToken(usedDataType);\n            default:\n                throw new Error(\"Invalid dataType: \" + usedDataType);\n        }\n    }\n    isOffsetDataType(dataType) {\n        return dataType === DataType.OFFSET_ARRAY_8 || dataType === DataType.OFFSET_ARRAY_16 || dataType === DataType.OFFSET_ARRAY_32;\n    }\n    encodeArrayToken(arrayToken, dataType) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.encodeDataType(this.dataTypeUtils.getDataType(arrayToken));\n        const numberType = usedDataType === DataType.ARRAY_8 || usedDataType === DataType.OFFSET_ARRAY_8\n            ? DataType.UINT8\n            : usedDataType === DataType.ARRAY_16 || usedDataType === DataType.OFFSET_ARRAY_16\n                ? DataType.UINT16 : DataType.UINT32;\n        let indices = arrayToken.value;\n        if (this.isOffsetDataType(usedDataType)) {\n            const offset = Math.min(...indices);\n            indices = indices.map((value) => value - offset);\n            this.encodeSingleNumber(offset);\n        }\n        this.encodeNumberArray(indices, numberType);\n    }\n    decodeArrayToken(dataType) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.decodeDataType();\n        let offset = 0;\n        if (this.isOffsetDataType(usedDataType)) {\n            offset = this.decodeSingleNumber();\n        }\n        const numberType = usedDataType === DataType.ARRAY_8 || usedDataType === DataType.OFFSET_ARRAY_8\n            ? DataType.UINT8\n            : usedDataType === DataType.ARRAY_16 || usedDataType === DataType.OFFSET_ARRAY_16\n                ? DataType.UINT16 : DataType.UINT32;\n        const indices = this.decodeNumberArray(numberType)\n            .map(value => value + offset);\n        return {\n            type: \"array\",\n            value: indices,\n        };\n    }\n    encodeObjectToken(objectToken, dataType) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.encodeDataType(this.dataTypeUtils.getDataType(objectToken));\n        const numberType = usedDataType === DataType.OBJECT_8 ? DataType.UINT8 : usedDataType === DataType.OBJECT_16 ? DataType.UINT16 : DataType.UINT32;\n        const [keysIndex, valuesIndex] = objectToken.value;\n        this.encodeSingleNumber(keysIndex, numberType);\n        this.encodeSingleNumber(valuesIndex, numberType);\n    }\n    decodeObjectToken(dataType) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.decodeDataType();\n        const numberType = usedDataType === DataType.OBJECT_8 ? DataType.UINT8 : usedDataType === DataType.OBJECT_16 ? DataType.UINT16 : DataType.UINT32;\n        return {\n            type: \"object\",\n            value: [this.decodeSingleNumber(numberType), this.decodeSingleNumber(numberType)],\n        };\n    }\n    encodeSplitToken(splitToken, dataType) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.encodeDataType(this.dataTypeUtils.getDataType(splitToken));\n        const numberType = usedDataType === DataType.SPLIT_8 ? DataType.UINT8 : usedDataType === DataType.SPLIT_16 ? DataType.UINT16 : DataType.UINT32;\n        const [chunksIndex, separatorsIndex] = splitToken.value;\n        this.encodeSingleNumber(chunksIndex, numberType);\n        this.encodeSingleNumber(separatorsIndex, numberType);\n    }\n    decodeSplitToken(dataType) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.decodeDataType();\n        const numberType = usedDataType === DataType.SPLIT_8 ? DataType.UINT8 : usedDataType === DataType.SPLIT_16 ? DataType.UINT16 : DataType.UINT32;\n        return {\n            type: \"split\",\n            value: [this.decodeSingleNumber(numberType), this.decodeSingleNumber(numberType)],\n        };\n    }\n    encodeReferenceToken(token, dataType) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.encodeDataType(this.dataTypeUtils.getDataType(token));\n        const numberType = usedDataType === DataType.REFERENCE_8 ? DataType.UINT8 : usedDataType === DataType.REFERENCE_16 ? DataType.UINT16 : DataType.UINT32;\n        const index = token.value;\n        this.encodeSingleNumber(index, numberType);\n    }\n    decodeReferenceToken(dataType) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.decodeDataType();\n        const numberType = usedDataType === DataType.REFERENCE_8 ? DataType.UINT8 : usedDataType === DataType.REFERENCE_16 ? DataType.UINT16 : DataType.UINT32;\n        return {\n            type: \"reference\",\n            value: this.decodeSingleNumber(numberType),\n        };\n    }\n    encodeComplexToken(token, dataType) {\n        if (dataType === undefined) {\n            this.encodeDataType(this.dataTypeUtils.getDataType(token));\n        }\n        const structure = token.value;\n        this.encodeNumberArray(structure, DataType.UINT2);\n    }\n    decodeComplexToken(dataType) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.decodeDataType();\n        const structure = this.decodeNumberArray(DataType.UINT2);\n        return {\n            type: this.dataTypeUtils.dataTypeToType(usedDataType),\n            value: structure,\n        };\n    }\n    encodeDataType(dataType) {\n        this.streamDataView.setNextUint8(dataType);\n        return dataType;\n    }\n    decodeDataType() {\n        const dataType = this.streamDataView.getNextUint8();\n        return dataType;\n    }\n    encodeMulti(tokens, pos, organized) {\n        if (pos >= tokens.length) {\n            this.encodeSingleNumber(0, DataType.UINT8);\n            return 0;\n        }\n        const firstType = this.dataTypeUtils.getDataType(tokens[pos]);\n        let multiCount;\n        const maxCount = Math.min(tokens.length - pos, 255);\n        for (multiCount = 1; multiCount < maxCount; multiCount++) {\n            if (this.dataTypeUtils.getDataType(tokens[pos + multiCount]) !== firstType) {\n                break;\n            }\n        }\n        //  encode a multi, meaning that the same type is going to get repeated multiple times\n        this.encodeSingleNumber(multiCount, DataType.UINT8);\n        this.encodeDataType(firstType);\n        const multiInfo = { organized };\n        for (let i = 0; i < multiCount; i++) {\n            this.encodeToken(tokens[pos + i], firstType, multiInfo);\n        }\n        return multiCount;\n    }\n    decodeMulti(tokens, organized) {\n        const count = this.streamDataView.getNextUint8();\n        if (!count) {\n            return 0;\n        }\n        const dataType = this.decodeDataType();\n        const multiInfo = { organized };\n        for (let i = 0; i < count; i++) {\n            const token = this.decodeToken(dataType, multiInfo);\n            tokens.push(token);\n        }\n        return count;\n    }\n    encodeSingleNumber(value, dataType) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.encodeDataType(this.dataTypeUtils.getNumberDataType(value));\n        switch (usedDataType) {\n            case DataType.UINT2:\n            case DataType.UINT4:\n                throw new Error(\"Use encode number array.\");\n            case DataType.UINT8:\n                this.streamDataView.setNextUint8(value);\n                break;\n            case DataType.INT8:\n                this.streamDataView.setNextInt8(value);\n                break;\n            case DataType.UINT16:\n                this.streamDataView.setNextUint16(value);\n                break;\n            case DataType.INT16:\n                this.streamDataView.setNextInt16(value);\n                break;\n            case DataType.UINT32:\n                this.streamDataView.setNextUint32(value);\n                break;\n            case DataType.INT32:\n                this.streamDataView.setNextInt32(value);\n                break;\n            case DataType.FLOAT32:\n                this.streamDataView.setNextFloat32(value);\n                break;\n            case DataType.FLOAT64:\n                this.streamDataView.setNextFloat64(value);\n                break;\n            default:\n                throw new Error(\"Invalid dataType for number: \" + usedDataType);\n        }\n    }\n    decodeSingleNumber(dataType) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.decodeDataType();\n        switch (usedDataType) {\n            case DataType.UINT2:\n            case DataType.UINT4:\n                throw new Error(\"Use decode number array.\");\n            case DataType.UINT8:\n                return this.streamDataView.getNextUint8();\n            case DataType.INT8:\n                return this.streamDataView.getNextInt8();\n            case DataType.UINT16:\n                return this.streamDataView.getNextUint16();\n            case DataType.INT16:\n                return this.streamDataView.getNextInt16();\n            case DataType.UINT32:\n                return this.streamDataView.getNextUint32();\n            case DataType.INT32:\n                return this.streamDataView.getNextInt32();\n            case DataType.FLOAT32:\n                return this.streamDataView.getNextFloat32();\n            case DataType.FLOAT64:\n                return this.streamDataView.getNextFloat64();\n            default:\n                throw new Error(\"Invalid dataType for number: \" + usedDataType);\n        }\n    }\n    bit2ToNum([a, b, c, d]) {\n        return ((a !== null && a !== void 0 ? a : 0) << 0) | ((b !== null && b !== void 0 ? b : 0) << 2) | ((c !== null && c !== void 0 ? c : 0) << 4) | ((d !== null && d !== void 0 ? d : 0) << 6);\n    }\n    numToBit2(n, size = 4) {\n        return [(n >> 0) & 3, (n >> 2) & 3, (n >> 4) & 3, (n >> 6) & 3].slice(0, size);\n    }\n    bit4ToNum([a, b]) {\n        return ((a !== null && a !== void 0 ? a : 0) << 0) | ((b !== null && b !== void 0 ? b : 0) << 4);\n    }\n    numToBit4(n, size = 2) {\n        return [(n >> 0) & 15, (n >> 4) & 15].slice(0, size);\n    }\n    encodeNumberArray(array, dataType) {\n        if (dataType === DataType.UINT2 || dataType === DataType.UINT4) {\n            const stride = dataType === DataType.UINT2 ? 4 : 2;\n            const transform = dataType === DataType.UINT2 ? this.bit2ToNum : this.bit4ToNum;\n            const bytes = [];\n            for (let i = 0; i < array.length; i += stride) {\n                bytes.push(transform(array.slice(i, i + stride)));\n            }\n            this.encodeNumberArray(bytes, DataType.UINT8);\n            this.encodeSingleNumber(array.length - bytes.length * stride, DataType.INT8);\n            return;\n        }\n        let pos;\n        for (pos = 0; pos < array.length;) {\n            const size = Math.min(MAX_ARRAY_SIZE, array.length - pos);\n            this.encodeSingleNumber(size, DataType.UINT8);\n            if (!size) {\n                break;\n            }\n            const bestType = dataType !== null && dataType !== void 0 ? dataType : this.encodeDataType(this.dataTypeUtils.getBestType(array));\n            for (let i = 0; i < size; i++) {\n                this.encodeSingleNumber(array[pos + i], bestType);\n            }\n            pos += size;\n        }\n        if (pos === MAX_ARRAY_SIZE) {\n            //  Reached the max size, but the next one is 0.\n            this.encodeSingleNumber(0, DataType.UINT8);\n        }\n    }\n    decodeNumberArray(dataType) {\n        if (dataType === DataType.UINT2 || dataType === DataType.UINT4) {\n            const transform = dataType === DataType.UINT2 ? this.numToBit2 : this.numToBit4;\n            const structure = [];\n            const bytes = this.decodeNumberArray(DataType.UINT8);\n            for (let byte of bytes) {\n                structure.push(...transform(byte));\n            }\n            const sizeDiff = this.decodeSingleNumber(DataType.INT8);\n            structure.length += sizeDiff;\n            return structure;\n        }\n        let size;\n        const numbers = [];\n        do {\n            size = this.decodeSingleNumber(DataType.UINT8);\n            if (!size) {\n                break;\n            }\n            const type = dataType !== null && dataType !== void 0 ? dataType : this.decodeDataType();\n            for (let i = 0; i < size; i++) {\n                numbers.push(this.decodeSingleNumber(type));\n            }\n        } while (size >= MAX_ARRAY_SIZE);\n        return numbers;\n    }\n    encodeString(value, dataType, multiInfo, noSet = false) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.encodeDataType(this.dataTypeUtils.getStringDataType(value, noSet));\n        const letterCodes = value.split(\"\").map(l => l.charCodeAt(0));\n        if (!(multiInfo === null || multiInfo === void 0 ? void 0 : multiInfo.organized) || multiInfo.lastStringLength !== value.length) {\n            letterCodes.push(0);\n        }\n        // console.log(letterCodes, value, (letterCodes).map((value) => !value ? 0 : value - min + 1));\n        const numberType = usedDataType === DataType.STRING ? DataType.UINT8 : DataType.UINT16;\n        letterCodes.forEach(code => this.encodeSingleNumber(code, numberType));\n        if (multiInfo) {\n            multiInfo.lastStringLength = value.length;\n        }\n    }\n    decodeString(dataType, multiInfo) {\n        const usedDataType = dataType !== null && dataType !== void 0 ? dataType : this.decodeDataType();\n        const charCodes = [];\n        const numberType = usedDataType === DataType.STRING ? DataType.UINT8 : DataType.UINT16;\n        do {\n            const code = this.decodeSingleNumber(numberType);\n            if (!code) {\n                break;\n            }\n            charCodes.push(code);\n            if ((multiInfo === null || multiInfo === void 0 ? void 0 : multiInfo.organized) && (multiInfo === null || multiInfo === void 0 ? void 0 : multiInfo.lastStringLength) && charCodes.length >= (multiInfo === null || multiInfo === void 0 ? void 0 : multiInfo.lastStringLength)) {\n                break;\n            }\n        } while (true);\n        const string = charCodes.map(code => String.fromCharCode(code)).join(\"\");\n        if (multiInfo) {\n            multiInfo.lastStringLength = string.length;\n        }\n        return string;\n    }\n    static selfTest() {\n        const testers = [\n            //  0\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction(DataType.STRING, dataType => tokenEncoder.encodeDataType(dataType), reset, () => tokenDecoder.decodeDataType());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction(DataType.UNDEFINED, dataType => tokenEncoder.encodeDataType(dataType), reset, () => tokenDecoder.decodeDataType());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction(33, number => tokenEncoder.encodeSingleNumber(number, DataType.INT8), reset, () => tokenDecoder.decodeSingleNumber(DataType.INT8));\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction([\n                    { type: \"leaf\", value: 123 },\n                    { type: \"leaf\", value: 45 },\n                    { type: \"leaf\", value: 67 },\n                    { type: \"leaf\", value: 89 },\n                ], header => tokenEncoder.encodeMulti(header, 0, false), reset, () => {\n                    const result = [];\n                    tokenDecoder.decodeMulti(result, false);\n                    return result;\n                });\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction([\n                    { type: \"leaf\", value: 1000001 },\n                    { type: \"leaf\", value: 1002000 },\n                    { type: \"leaf\", value: 1003001 },\n                ], header => tokenEncoder.encodeMulti(header, 0, false), reset, () => {\n                    const result = [];\n                    tokenDecoder.decodeMulti(result, false);\n                    return result;\n                });\n            },\n            //  5\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction([1, 2, 3, 4, 10, 20, 200], array => tokenEncoder.encodeNumberArray(array), reset, () => tokenDecoder.decodeNumberArray());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction(new Array(2000).fill(null).map((_, index) => index), array => tokenEncoder.encodeNumberArray(array), reset, () => tokenDecoder.decodeNumberArray());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction([10000, -202, 3, 4, 10, 20, 3200], array => tokenEncoder.encodeNumberArray(array), reset, () => tokenDecoder.decodeNumberArray());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction(\"teststring\", string => tokenEncoder.encodeString(string), reset, () => tokenDecoder.decodeString());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction(\"teststring\", string => tokenEncoder.encodeString(string, DataType.STRING), reset, () => tokenDecoder.decodeString(DataType.STRING));\n            },\n            //  10\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction(\"test\", string => tokenEncoder.encodeString(string), reset, () => tokenDecoder.decodeString());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"object\", value: [200, 201] }, o => tokenEncoder.encodeObjectToken(o), reset, () => tokenDecoder.decodeObjectToken());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"object\", value: [2000, 2001] }, o => tokenEncoder.encodeObjectToken(o), reset, () => tokenDecoder.decodeObjectToken());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"object\", value: [2000, 2001] }, o => tokenEncoder.encodeObjectToken(o, DataType.OBJECT_32), reset, () => tokenDecoder.decodeObjectToken(DataType.OBJECT_32));\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"split\", value: [200, 201] }, o => tokenEncoder.encodeSplitToken(o), reset, () => tokenDecoder.decodeSplitToken());\n            },\n            //  15\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"split\", value: [2000, 2001] }, o => tokenEncoder.encodeSplitToken(o), reset, () => tokenDecoder.decodeSplitToken());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"split\", value: [2000, 2001] }, o => tokenEncoder.encodeSplitToken(o, DataType.SPLIT_32), reset, () => tokenDecoder.decodeSplitToken(DataType.SPLIT_32));\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"leaf\", value: \"tokenstring\" }, o => tokenEncoder.encodeToken(o), reset, () => tokenDecoder.decodeToken());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"leaf\", value: 123.5 }, o => tokenEncoder.encodeToken(o), reset, () => tokenDecoder.decodeToken());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"leaf\", value: \"\" }, o => tokenEncoder.encodeToken(o), reset, () => tokenDecoder.decodeToken());\n            },\n            //  20\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"array\", value: [1, 10, 20, 30, 200] }, o => tokenEncoder.encodeToken(o), reset, () => tokenDecoder.decodeToken());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"array\", value: [1001, 1010, 1020, 1030, 1200] }, o => tokenEncoder.encodeToken(o), reset, () => tokenDecoder.decodeToken());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"array\", value: [10010, 10100, 10300, 20000] }, o => tokenEncoder.encodeToken(o), reset, () => tokenDecoder.decodeToken());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"array\", value: [10010, 10100, 10000] }, o => tokenEncoder.encodeToken(o), reset, () => tokenDecoder.decodeToken());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"array\", value: new Array(260).fill(null).map((_, index) => index) }, o => tokenEncoder.encodeToken(o), reset, () => tokenDecoder.decodeToken());\n            },\n            //  25\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction(new Array(100).fill(null).map((_, index) => {\n                    const token = {\n                        type: \"array\",\n                        value: new Array(index).fill(null).map((_, index) => index),\n                    };\n                    return token;\n                }), o => tokenEncoder.encodeTokens(o, false), reset, () => tokenDecoder.decodeTokens(false));\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction(new Array(260).fill(null).map((_, index) => {\n                    const token = {\n                        type: \"array\",\n                        value: new Array(index).fill(null).map((_, index) => index),\n                    };\n                    return token;\n                }), o => tokenEncoder.encodeTokens(o, false), reset, () => tokenDecoder.decodeTokens(false));\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction(new Array(260).fill(null).map((_, index) => {\n                    const token = {\n                        type: \"array\",\n                        value: [1],\n                    };\n                    return token;\n                }), o => tokenEncoder.encodeTokens(o, false), reset, () => tokenDecoder.decodeTokens(false));\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"complex\", value: [1, 2, 3, 2, 1, 2, 1, 0] }, o => tokenEncoder.encodeToken(o), reset, () => tokenDecoder.decodeToken());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction({ type: \"complex\", value: \"120100310000000310000000031000003100003100000031000000031000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000031000000000010000000120103100020103100020103100031000000000002010031000000031000000003100000310000310000003100000003100000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000310000000000100000001201031000201031000201031000310000000000020100310000000310000000031000003100003100000031000000031000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000003100000000001000000012010310002010310002010310003100000000000201003100000003100000000310000031000031000000310000000031000000000000000000000000000100000000000000000000000000310000000000100000001201031000201031000201031000310000000000020100310000000310000000031000003100003100000031000000031000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000003100000000001000000012010310002010310002010310003100000000000\".split(\"\").map(a => parseInt(a)) }, o => tokenEncoder.encodeToken(o), reset, () => tokenDecoder.decodeToken());\n            },\n            //  30\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction([1, 2, 3, 2, 1, 2, 1, 0], o => tokenEncoder.encodeNumberArray(o, DataType.UINT2), reset, () => tokenDecoder.decodeNumberArray(DataType.UINT2));\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction([1, 15, 12, 12, 1, 9, 1, 0], o => tokenEncoder.encodeNumberArray(o, DataType.UINT4), reset, () => tokenDecoder.decodeNumberArray(DataType.UINT4));\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction(\"xyzxyzyzxxxyyyzzz\", o => tokenEncoder.encodeString(o), reset, () => tokenDecoder.decodeString());\n            },\n            (tokenEncoder, tokenDecoder, reset) => {\n                this.testAction(\"abcdeabcabcadbdddba\", o => tokenEncoder.encodeString(o), reset, () => tokenDecoder.decodeString());\n            },\n        ];\n        testers.forEach((tester, index) => {\n            const streamDataView = new StreamDataView();\n            const encoder = new TokenEncoder(streamDataView);\n            const decoder = new TokenEncoder(streamDataView);\n            const reset = () => streamDataView.resetOffset();\n            tester(encoder, decoder, reset);\n            console.info(` Passed test ${index}.`);\n        });\n    }\n    static testAction(value, encode, reset, decode, check = (result, value) => console.assert(JSON.stringify(result) === JSON.stringify(value), `Not equal: \\n%s\\n!==\\n%s (expected)`, JSON.stringify(result), JSON.stringify(value))) {\n        encode(value);\n        reset();\n        const decoded = decode();\n        reset();\n        check(decoded, value);\n    }\n}\n","import { DataType, DataTypeUtils, StructureType } from \"../compression/DataType\";\n/**\n * Reduce header from using large tokens to reduce tokens.\n */\nexport default class Reducer {\n    constructor() {\n        this.dataTypeUtils = new DataTypeUtils();\n    }\n    /**\n     * Reduce header with smaller tokens for storage\n     *\n     * @param header Represents all data that we have.\n     * @returns DataStorage object that's the minimum we can store.\n     */\n    reduce(header) {\n        const hashToIndex = {};\n        //  start with header tokens\n        const headerTokens = this.createReducedHeaderTokens(this.filterSplit(Object.values(header.registry)\n            .filter(token => token.files.size > 1 || token.files.has(\"header\")), header.registry), hashToIndex);\n        //  save files\n        const fileEntries = Object.entries(header.files).sort(([name1], [name2]) => name1.localeCompare(name2));\n        const files = fileEntries.map(([, token]) => hashToIndex[token.nameToken.hash]);\n        //  save all files separately as complex objects.\n        const dataTokens = fileEntries.map(([, { token: root }]) => {\n            const subHashToIndex = Object.assign({}, hashToIndex);\n            const structure = [];\n            const result = [{\n                    type: \"complex\",\n                    value: structure,\n                }];\n            this.createComplexObject(root, subHashToIndex, header.registry, headerTokens, structure, result);\n            return result;\n        });\n        return {\n            originalDataSize: header.originalDataSize,\n            headerTokens,\n            files,\n            getDataTokens: (index) => dataTokens[index],\n        };\n    }\n    /**\n     * Sort tokens by frequency.\n     */\n    sortTokens(tokens) {\n        tokens.sort((t1, t2) => t2.count - t1.count);\n    }\n    /**\n     * Organize tokens in groups of 255\n     * @param tokens\n     */\n    organizeTokens(tokens) {\n        if (!tokens.length) {\n            return tokens;\n        }\n        const buckets = [];\n        tokens.forEach(token => {\n            const dataType = this.dataTypeUtils.getFullTokenDataType(token);\n            let bucket = undefined;\n            for (let b of buckets) {\n                if (b.length < 255 && this.dataTypeUtils.getFullTokenDataType(b[0]) === dataType) {\n                    bucket = b;\n                    break;\n                }\n            }\n            if (!bucket) {\n                bucket = [];\n                buckets.push(bucket);\n            }\n            bucket.push(token);\n        });\n        buckets.forEach(bucket => {\n            const dataType = this.dataTypeUtils.getFullTokenDataType(bucket[0]);\n            switch (dataType) {\n                case DataType.UINT8:\n                case DataType.UINT16:\n                case DataType.UINT32:\n                case DataType.INT8:\n                case DataType.INT16:\n                case DataType.INT32:\n                case DataType.FLOAT32:\n                case DataType.FLOAT64:\n                    bucket.sort((a, b) => b.value - a.value);\n                    break;\n                case DataType.STRING:\n                case DataType.UNICODE:\n                    bucket.sort((a, b) => b.value.length - a.value.length);\n                    break;\n                case DataType.ARRAY_8:\n                case DataType.ARRAY_16:\n                case DataType.ARRAY_32:\n                    bucket.sort((a, b) => b.value.length - a.value.length);\n                    break;\n            }\n        });\n        const resultTokens = [];\n        buckets.forEach(bucket => bucket.forEach(token => resultTokens.push(token)));\n        return resultTokens;\n    }\n    filterSplit(tokens, registry) {\n        for (let token of tokens) {\n            if (token.type === \"split\") {\n                const [chunskHash, separatorsHash] = token.reference;\n                const chunksToken = registry[chunskHash];\n                const separatorsToken = registry[separatorsHash];\n                if (chunksToken.count <= token.count && separatorsToken.count <= token.count) {\n                    chunksToken.deleted = true;\n                    separatorsToken.deleted = true;\n                    token.type = \"leaf\";\n                    delete token.reference;\n                }\n            }\n        }\n        return tokens.filter(({ deleted }) => !deleted);\n    }\n    createReducedHeaderTokens(tokens, hashToIndex, offset = 0) {\n        this.sortTokens(tokens);\n        const organizedTokens = this.organizeTokens(tokens);\n        organizedTokens.forEach(({ hash }, index) => hashToIndex[hash] = index + offset);\n        return organizedTokens.map(token => {\n            var _a, _b;\n            return ({\n                type: token.type,\n                value: (_b = (_a = token.reference) === null || _a === void 0 ? void 0 : _a.map(hash => hashToIndex[hash])) !== null && _b !== void 0 ? _b : token.value,\n            });\n        });\n    }\n    /**\n     *  Traverse object to produce a set of tokens used to produce a complex object\n     * @param token Root token\n     * @param hashToIndex Hash to index mapping\n     * @param result Resulting set of tokens\n     */\n    createComplexObject(token, hashToIndex, registry, headerTokens, structure, resultDataTokens) {\n        var _a, _b;\n        if (hashToIndex[token.hash] >= 0) {\n            structure.push(StructureType.LEAF);\n            resultDataTokens.push({ type: \"reference\", value: hashToIndex[token.hash] });\n        }\n        else if (token.type === \"leaf\") {\n            structure.push(this.dataTypeUtils.typeToStructureType(token.type));\n            hashToIndex[token.hash] = headerTokens.length + resultDataTokens.length;\n            resultDataTokens.push({ type: token.type, value: token.value });\n        }\n        else if (token.type === \"split\" || token.type === \"object\" || token.type === \"array\") {\n            structure.push(this.dataTypeUtils.typeToStructureType(token.type));\n            if (token.type === \"array\") {\n                resultDataTokens.push({ type: \"leaf\", value: (_a = token.reference) === null || _a === void 0 ? void 0 : _a.length });\n            }\n            const subTokens = (_b = token.reference) === null || _b === void 0 ? void 0 : _b.map((hash) => registry[hash]);\n            subTokens === null || subTokens === void 0 ? void 0 : subTokens.forEach(token => {\n                this.createComplexObject(token, hashToIndex, registry, headerTokens, structure, resultDataTokens);\n            });\n        }\n        else {\n            throw new Error(\"Invalid token type\");\n        }\n    }\n}\n","// DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n// https://tools.ietf.org/html/rfc1951\n// You may also wish to take a look at the guide I made about this program:\n// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad\n// Some of the following code is similar to that of UZIP.js:\n// https://github.com/photopea/UZIP.js\n// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.\n// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint\n// is better for memory in most engines (I *think*).\nvar ch2 = {};\nvar wk = (function (c, id, msg, transfer, cb) {\n    var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([\n        c + ';addEventListener(\"error\",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'\n    ], { type: 'text/javascript' }))));\n    w.onmessage = function (e) {\n        var d = e.data, ed = d.$e$;\n        if (ed) {\n            var err = new Error(ed[0]);\n            err['code'] = ed[1];\n            err.stack = ed[2];\n            cb(err, null);\n        }\n        else\n            cb(null, d);\n    };\n    w.postMessage(msg, transfer);\n    return w;\n});\n\n// aliases for shorter compressed code (most minifers don't do this)\nvar u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;\n// fixed length extra bits\nvar fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);\n// fixed distance extra bits\n// see fleb note\nvar fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);\n// code length index map\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n// get base, reverse index map from extra bits\nvar freb = function (eb, start) {\n    var b = new u16(31);\n    for (var i = 0; i < 31; ++i) {\n        b[i] = start += 1 << eb[i - 1];\n    }\n    // numbers here are at max 18 bits\n    var r = new u32(b[30]);\n    for (var i = 1; i < 30; ++i) {\n        for (var j = b[i]; j < b[i + 1]; ++j) {\n            r[j] = ((j - b[i]) << 5) | i;\n        }\n    }\n    return [b, r];\n};\nvar _a = freb(fleb, 2), fl = _a[0], revfl = _a[1];\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = _b[0], revfd = _b[1];\n// map of value to reverse (assuming 16 bits)\nvar rev = new u16(32768);\nfor (var i = 0; i < 32768; ++i) {\n    // reverse table algorithm from SO\n    var x = ((i & 0xAAAA) >>> 1) | ((i & 0x5555) << 1);\n    x = ((x & 0xCCCC) >>> 2) | ((x & 0x3333) << 2);\n    x = ((x & 0xF0F0) >>> 4) | ((x & 0x0F0F) << 4);\n    rev[i] = (((x & 0xFF00) >>> 8) | ((x & 0x00FF) << 8)) >>> 1;\n}\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nvar hMap = (function (cd, mb, r) {\n    var s = cd.length;\n    // index\n    var i = 0;\n    // u16 \"map\": index -> # of codes with bit length = index\n    var l = new u16(mb);\n    // length of cd must be 288 (total # of codes)\n    for (; i < s; ++i) {\n        if (cd[i])\n            ++l[cd[i] - 1];\n    }\n    // u16 \"map\": index -> minimum code for bit length = index\n    var le = new u16(mb);\n    for (i = 0; i < mb; ++i) {\n        le[i] = (le[i - 1] + l[i - 1]) << 1;\n    }\n    var co;\n    if (r) {\n        // u16 \"map\": index -> number of actual bits, symbol for code\n        co = new u16(1 << mb);\n        // bits to remove for reverser\n        var rvb = 15 - mb;\n        for (i = 0; i < s; ++i) {\n            // ignore 0 lengths\n            if (cd[i]) {\n                // num encoding both symbol and bits read\n                var sv = (i << 4) | cd[i];\n                // free bits\n                var r_1 = mb - cd[i];\n                // start value\n                var v = le[cd[i] - 1]++ << r_1;\n                // m is end value\n                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {\n                    // every 16 bit value starting with the code yields the same result\n                    co[rev[v] >>> rvb] = sv;\n                }\n            }\n        }\n    }\n    else {\n        co = new u16(s);\n        for (i = 0; i < s; ++i) {\n            if (cd[i]) {\n                co[i] = rev[le[cd[i] - 1]++] >>> (15 - cd[i]);\n            }\n        }\n    }\n    return co;\n});\n// fixed length tree\nvar flt = new u8(288);\nfor (var i = 0; i < 144; ++i)\n    flt[i] = 8;\nfor (var i = 144; i < 256; ++i)\n    flt[i] = 9;\nfor (var i = 256; i < 280; ++i)\n    flt[i] = 7;\nfor (var i = 280; i < 288; ++i)\n    flt[i] = 8;\n// fixed distance tree\nvar fdt = new u8(32);\nfor (var i = 0; i < 32; ++i)\n    fdt[i] = 5;\n// fixed length map\nvar flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);\n// fixed distance map\nvar fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);\n// find max of array\nvar max = function (a) {\n    var m = a[0];\n    for (var i = 1; i < a.length; ++i) {\n        if (a[i] > m)\n            m = a[i];\n    }\n    return m;\n};\n// read d, starting at bit p and mask with m\nvar bits = function (d, p, m) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;\n};\n// read d, starting at bit p continuing for at least 16 bits\nvar bits16 = function (d, p) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));\n};\n// get end of byte\nvar shft = function (p) { return ((p + 7) / 8) | 0; };\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nvar slc = function (v, s, e) {\n    if (s == null || s < 0)\n        s = 0;\n    if (e == null || e > v.length)\n        e = v.length;\n    // can't use .constructor in case user-supplied\n    var n = new (v.BYTES_PER_ELEMENT == 2 ? u16 : v.BYTES_PER_ELEMENT == 4 ? u32 : u8)(e - s);\n    n.set(v.subarray(s, e));\n    return n;\n};\n/**\n * Codes for errors generated within this library\n */\nexport var FlateErrorCode = {\n    UnexpectedEOF: 0,\n    InvalidBlockType: 1,\n    InvalidLengthLiteral: 2,\n    InvalidDistance: 3,\n    StreamFinished: 4,\n    NoStreamHandler: 5,\n    InvalidHeader: 6,\n    NoCallback: 7,\n    InvalidUTF8: 8,\n    ExtraFieldTooLong: 9,\n    InvalidDate: 10,\n    FilenameTooLong: 11,\n    StreamFinishing: 12,\n    InvalidZipData: 13,\n    UnknownCompressionMethod: 14\n};\n// error codes\nvar ec = [\n    'unexpected EOF',\n    'invalid block type',\n    'invalid length/literal',\n    'invalid distance',\n    'stream finished',\n    'no stream handler',\n    ,\n    'no callback',\n    'invalid UTF-8 data',\n    'extra field too long',\n    'date not in range 1980-2099',\n    'filename too long',\n    'stream finishing',\n    'invalid zip data'\n    // determined by unknown compression method\n];\n;\nvar err = function (ind, msg, nt) {\n    var e = new Error(msg || ec[ind]);\n    e.code = ind;\n    if (Error.captureStackTrace)\n        Error.captureStackTrace(e, err);\n    if (!nt)\n        throw e;\n    return e;\n};\n// expands raw DEFLATE data\nvar inflt = function (dat, buf, st) {\n    // source length\n    var sl = dat.length;\n    if (!sl || (st && st.f && !st.l))\n        return buf || new u8(0);\n    // have to estimate size\n    var noBuf = !buf || st;\n    // no state\n    var noSt = !st || st.i;\n    if (!st)\n        st = {};\n    // Assumes roughly 33% compression ratio average\n    if (!buf)\n        buf = new u8(sl * 3);\n    // ensure buffer can fit at least l elements\n    var cbuf = function (l) {\n        var bl = buf.length;\n        // need to increase size to fit\n        if (l > bl) {\n            // Double or set to necessary, whichever is greater\n            var nbuf = new u8(Math.max(bl * 2, l));\n            nbuf.set(buf);\n            buf = nbuf;\n        }\n    };\n    //  last chunk         bitpos           bytes\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    // total bits\n    var tbts = sl * 8;\n    do {\n        if (!lm) {\n            // BFINAL - this is only 1 when last chunk is next\n            final = bits(dat, pos, 1);\n            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n            var type = bits(dat, pos + 1, 3);\n            pos += 3;\n            if (!type) {\n                // go to end of byte boundary\n                var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;\n                if (t > sl) {\n                    if (noSt)\n                        err(0);\n                    break;\n                }\n                // ensure size\n                if (noBuf)\n                    cbuf(bt + l);\n                // Copy over uncompressed data\n                buf.set(dat.subarray(s, t), bt);\n                // Get new bitpos, update byte count\n                st.b = bt += l, st.p = pos = t * 8, st.f = final;\n                continue;\n            }\n            else if (type == 1)\n                lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n            else if (type == 2) {\n                //  literal                            lengths\n                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n                var tl = hLit + bits(dat, pos + 5, 31) + 1;\n                pos += 14;\n                // length+distance tree\n                var ldt = new u8(tl);\n                // code length tree\n                var clt = new u8(19);\n                for (var i = 0; i < hcLen; ++i) {\n                    // use index map to get real code\n                    clt[clim[i]] = bits(dat, pos + i * 3, 7);\n                }\n                pos += hcLen * 3;\n                // code lengths bits\n                var clb = max(clt), clbmsk = (1 << clb) - 1;\n                // code lengths map\n                var clm = hMap(clt, clb, 1);\n                for (var i = 0; i < tl;) {\n                    var r = clm[bits(dat, pos, clbmsk)];\n                    // bits read\n                    pos += r & 15;\n                    // symbol\n                    var s = r >>> 4;\n                    // code length to copy\n                    if (s < 16) {\n                        ldt[i++] = s;\n                    }\n                    else {\n                        //  copy   count\n                        var c = 0, n = 0;\n                        if (s == 16)\n                            n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n                        else if (s == 17)\n                            n = 3 + bits(dat, pos, 7), pos += 3;\n                        else if (s == 18)\n                            n = 11 + bits(dat, pos, 127), pos += 7;\n                        while (n--)\n                            ldt[i++] = c;\n                    }\n                }\n                //    length tree                 distance tree\n                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n                // max length bits\n                lbt = max(lt);\n                // max dist bits\n                dbt = max(dt);\n                lm = hMap(lt, lbt, 1);\n                dm = hMap(dt, dbt, 1);\n            }\n            else\n                err(1);\n            if (pos > tbts) {\n                if (noSt)\n                    err(0);\n                break;\n            }\n        }\n        // Make sure the buffer can hold this + the largest possible addition\n        // Maximum chunk size (practically, theoretically infinite) is 2^17;\n        if (noBuf)\n            cbuf(bt + 131072);\n        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n        var lpos = pos;\n        for (;; lpos = pos) {\n            // bits read, code\n            var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;\n            pos += c & 15;\n            if (pos > tbts) {\n                if (noSt)\n                    err(0);\n                break;\n            }\n            if (!c)\n                err(2);\n            if (sym < 256)\n                buf[bt++] = sym;\n            else if (sym == 256) {\n                lpos = pos, lm = null;\n                break;\n            }\n            else {\n                var add = sym - 254;\n                // no extra bits needed if less\n                if (sym > 264) {\n                    // index\n                    var i = sym - 257, b = fleb[i];\n                    add = bits(dat, pos, (1 << b) - 1) + fl[i];\n                    pos += b;\n                }\n                // dist\n                var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;\n                if (!d)\n                    err(3);\n                pos += d & 15;\n                var dt = fd[dsym];\n                if (dsym > 3) {\n                    var b = fdeb[dsym];\n                    dt += bits16(dat, pos) & ((1 << b) - 1), pos += b;\n                }\n                if (pos > tbts) {\n                    if (noSt)\n                        err(0);\n                    break;\n                }\n                if (noBuf)\n                    cbuf(bt + 131072);\n                var end = bt + add;\n                for (; bt < end; bt += 4) {\n                    buf[bt] = buf[bt - dt];\n                    buf[bt + 1] = buf[bt + 1 - dt];\n                    buf[bt + 2] = buf[bt + 2 - dt];\n                    buf[bt + 3] = buf[bt + 3 - dt];\n                }\n                bt = end;\n            }\n        }\n        st.l = lm, st.p = lpos, st.b = bt, st.f = final;\n        if (lm)\n            final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    } while (!final);\n    return bt == buf.length ? buf : slc(buf, 0, bt);\n};\n// starting at p, write the minimum number of bits that can hold v to d\nvar wbits = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n};\n// starting at p, write the minimum number of bits (>8) that can hold v to d\nvar wbits16 = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n    d[o + 2] |= v >>> 16;\n};\n// creates code lengths from a frequency table\nvar hTree = function (d, mb) {\n    // Need extra info to make a tree\n    var t = [];\n    for (var i = 0; i < d.length; ++i) {\n        if (d[i])\n            t.push({ s: i, f: d[i] });\n    }\n    var s = t.length;\n    var t2 = t.slice();\n    if (!s)\n        return [et, 0];\n    if (s == 1) {\n        var v = new u8(t[0].s + 1);\n        v[t[0].s] = 1;\n        return [v, 1];\n    }\n    t.sort(function (a, b) { return a.f - b.f; });\n    // after i2 reaches last ind, will be stopped\n    // freq must be greater than largest possible number of symbols\n    t.push({ s: -1, f: 25001 });\n    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;\n    t[0] = { s: -1, f: l.f + r.f, l: l, r: r };\n    // efficient algorithm from UZIP.js\n    // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n    // symbols that combined have high freq, will start processing i2 (high-freq,\n    // non-composite) symbols instead\n    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n    while (i1 != s - 1) {\n        l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n        t[i1++] = { s: -1, f: l.f + r.f, l: l, r: r };\n    }\n    var maxSym = t2[0].s;\n    for (var i = 1; i < s; ++i) {\n        if (t2[i].s > maxSym)\n            maxSym = t2[i].s;\n    }\n    // code lengths\n    var tr = new u16(maxSym + 1);\n    // max bits in tree\n    var mbt = ln(t[i1 - 1], tr, 0);\n    if (mbt > mb) {\n        // more algorithms from UZIP.js\n        // TODO: find out how this code works (debt)\n        //  ind    debt\n        var i = 0, dt = 0;\n        //    left            cost\n        var lft = mbt - mb, cst = 1 << lft;\n        t2.sort(function (a, b) { return tr[b.s] - tr[a.s] || a.f - b.f; });\n        for (; i < s; ++i) {\n            var i2_1 = t2[i].s;\n            if (tr[i2_1] > mb) {\n                dt += cst - (1 << (mbt - tr[i2_1]));\n                tr[i2_1] = mb;\n            }\n            else\n                break;\n        }\n        dt >>>= lft;\n        while (dt > 0) {\n            var i2_2 = t2[i].s;\n            if (tr[i2_2] < mb)\n                dt -= 1 << (mb - tr[i2_2]++ - 1);\n            else\n                ++i;\n        }\n        for (; i >= 0 && dt; --i) {\n            var i2_3 = t2[i].s;\n            if (tr[i2_3] == mb) {\n                --tr[i2_3];\n                ++dt;\n            }\n        }\n        mbt = mb;\n    }\n    return [new u8(tr), mbt];\n};\n// get the max length and assign length codes\nvar ln = function (n, l, d) {\n    return n.s == -1\n        ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))\n        : (l[n.s] = d);\n};\n// length codes generation\nvar lc = function (c) {\n    var s = c.length;\n    // Note that the semicolon was intentional\n    while (s && !c[--s])\n        ;\n    var cl = new u16(++s);\n    //  ind      num         streak\n    var cli = 0, cln = c[0], cls = 1;\n    var w = function (v) { cl[cli++] = v; };\n    for (var i = 1; i <= s; ++i) {\n        if (c[i] == cln && i != s)\n            ++cls;\n        else {\n            if (!cln && cls > 2) {\n                for (; cls > 138; cls -= 138)\n                    w(32754);\n                if (cls > 2) {\n                    w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305);\n                    cls = 0;\n                }\n            }\n            else if (cls > 3) {\n                w(cln), --cls;\n                for (; cls > 6; cls -= 6)\n                    w(8304);\n                if (cls > 2)\n                    w(((cls - 3) << 5) | 8208), cls = 0;\n            }\n            while (cls--)\n                w(cln);\n            cls = 1;\n            cln = c[i];\n        }\n    }\n    return [cl.subarray(0, cli), s];\n};\n// calculate the length of output from tree, code lengths\nvar clen = function (cf, cl) {\n    var l = 0;\n    for (var i = 0; i < cl.length; ++i)\n        l += cf[i] * cl[i];\n    return l;\n};\n// writes a fixed block\n// returns the new bit pos\nvar wfblk = function (out, pos, dat) {\n    // no need to write 00 as type: TypedArray defaults to 0\n    var s = dat.length;\n    var o = shft(pos + 2);\n    out[o] = s & 255;\n    out[o + 1] = s >>> 8;\n    out[o + 2] = out[o] ^ 255;\n    out[o + 3] = out[o + 1] ^ 255;\n    for (var i = 0; i < s; ++i)\n        out[o + i + 4] = dat[i];\n    return (o + 4 + s) * 8;\n};\n// writes a block\nvar wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\n    wbits(out, p++, final);\n    ++lf[256];\n    var _a = hTree(lf, 15), dlt = _a[0], mlb = _a[1];\n    var _b = hTree(df, 15), ddt = _b[0], mdb = _b[1];\n    var _c = lc(dlt), lclt = _c[0], nlc = _c[1];\n    var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];\n    var lcfreq = new u16(19);\n    for (var i = 0; i < lclt.length; ++i)\n        lcfreq[lclt[i] & 31]++;\n    for (var i = 0; i < lcdt.length; ++i)\n        lcfreq[lcdt[i] & 31]++;\n    var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];\n    var nlcc = 19;\n    for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)\n        ;\n    var flen = (bl + 5) << 3;\n    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);\n    if (flen <= ftlen && flen <= dtlen)\n        return wfblk(out, p, dat.subarray(bs, bs + bl));\n    var lm, ll, dm, dl;\n    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;\n    if (dtlen < ftlen) {\n        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n        var llm = hMap(lct, mlcb, 0);\n        wbits(out, p, nlc - 257);\n        wbits(out, p + 5, ndc - 1);\n        wbits(out, p + 10, nlcc - 4);\n        p += 14;\n        for (var i = 0; i < nlcc; ++i)\n            wbits(out, p + 3 * i, lct[clim[i]]);\n        p += 3 * nlcc;\n        var lcts = [lclt, lcdt];\n        for (var it = 0; it < 2; ++it) {\n            var clct = lcts[it];\n            for (var i = 0; i < clct.length; ++i) {\n                var len = clct[i] & 31;\n                wbits(out, p, llm[len]), p += lct[len];\n                if (len > 15)\n                    wbits(out, p, (clct[i] >>> 5) & 127), p += clct[i] >>> 12;\n            }\n        }\n    }\n    else {\n        lm = flm, ll = flt, dm = fdm, dl = fdt;\n    }\n    for (var i = 0; i < li; ++i) {\n        if (syms[i] > 255) {\n            var len = (syms[i] >>> 18) & 31;\n            wbits16(out, p, lm[len + 257]), p += ll[len + 257];\n            if (len > 7)\n                wbits(out, p, (syms[i] >>> 23) & 31), p += fleb[len];\n            var dst = syms[i] & 31;\n            wbits16(out, p, dm[dst]), p += dl[dst];\n            if (dst > 3)\n                wbits16(out, p, (syms[i] >>> 5) & 8191), p += fdeb[dst];\n        }\n        else {\n            wbits16(out, p, lm[syms[i]]), p += ll[syms[i]];\n        }\n    }\n    wbits16(out, p, lm[256]);\n    return p + ll[256];\n};\n// deflate options (nice << 13) | chain\nvar deo = /*#__PURE__*/ new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);\n// empty\nvar et = /*#__PURE__*/ new u8(0);\n// compresses data into a raw DEFLATE buffer\nvar dflt = function (dat, lvl, plvl, pre, post, lst) {\n    var s = dat.length;\n    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);\n    // writing to this writes to the output buffer\n    var w = o.subarray(pre, o.length - post);\n    var pos = 0;\n    if (!lvl || s < 8) {\n        for (var i = 0; i <= s; i += 65535) {\n            // end\n            var e = i + 65535;\n            if (e >= s) {\n                // write final block\n                w[pos >> 3] = lst;\n            }\n            pos = wfblk(w, pos + 1, dat.subarray(i, e));\n        }\n    }\n    else {\n        var opt = deo[lvl - 1];\n        var n = opt >>> 13, c = opt & 8191;\n        var msk_1 = (1 << plvl) - 1;\n        //    prev 2-byte val map    curr 2-byte val map\n        var prev = new u16(32768), head = new u16(msk_1 + 1);\n        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;\n        var hsh = function (i) { return (dat[i] ^ (dat[i + 1] << bs1_1) ^ (dat[i + 2] << bs2_1)) & msk_1; };\n        // 24576 is an arbitrary number of maximum symbols per block\n        // 424 buffer for last block\n        var syms = new u32(25000);\n        // length/literal freq   distance freq\n        var lf = new u16(288), df = new u16(32);\n        //  l/lcnt  exbits  index  l/lind  waitdx  bitpos\n        var lc_1 = 0, eb = 0, i = 0, li = 0, wi = 0, bs = 0;\n        for (; i < s; ++i) {\n            // hash value\n            // deopt when i > s - 3 - at end, deopt acceptable\n            var hv = hsh(i);\n            // index mod 32768    previous index mod\n            var imod = i & 32767, pimod = head[hv];\n            prev[imod] = pimod;\n            head[hv] = imod;\n            // We always should modify head and prev, but only add symbols if\n            // this data is not yet processed (\"wait\" for wait index)\n            if (wi <= i) {\n                // bytes remaining\n                var rem = s - i;\n                if ((lc_1 > 7000 || li > 24576) && rem > 423) {\n                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n                    li = lc_1 = eb = 0, bs = i;\n                    for (var j = 0; j < 286; ++j)\n                        lf[j] = 0;\n                    for (var j = 0; j < 30; ++j)\n                        df[j] = 0;\n                }\n                //  len    dist   chain\n                var l = 2, d = 0, ch_1 = c, dif = (imod - pimod) & 32767;\n                if (rem > 2 && hv == hsh(i - dif)) {\n                    var maxn = Math.min(n, rem) - 1;\n                    var maxd = Math.min(32767, i);\n                    // max possible length\n                    // not capped at dif because decompressors implement \"rolling\" index population\n                    var ml = Math.min(258, rem);\n                    while (dif <= maxd && --ch_1 && imod != pimod) {\n                        if (dat[i + l] == dat[i + l - dif]) {\n                            var nl = 0;\n                            for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)\n                                ;\n                            if (nl > l) {\n                                l = nl, d = dif;\n                                // break out early when we reach \"nice\" (we are satisfied enough)\n                                if (nl > maxn)\n                                    break;\n                                // now, find the rarest 2-byte sequence within this\n                                // length of literals and search for that instead.\n                                // Much faster than just using the start\n                                var mmd = Math.min(dif, nl - 2);\n                                var md = 0;\n                                for (var j = 0; j < mmd; ++j) {\n                                    var ti = (i - dif + j + 32768) & 32767;\n                                    var pti = prev[ti];\n                                    var cd = (ti - pti + 32768) & 32767;\n                                    if (cd > md)\n                                        md = cd, pimod = ti;\n                                }\n                            }\n                        }\n                        // check the previous match\n                        imod = pimod, pimod = prev[imod];\n                        dif += (imod - pimod + 32768) & 32767;\n                    }\n                }\n                // d will be nonzero only when a match was found\n                if (d) {\n                    // store both dist and len data in one Uint32\n                    // Make sure this is recognized as a len/dist with 28th bit (2^28)\n                    syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d];\n                    var lin = revfl[l] & 31, din = revfd[d] & 31;\n                    eb += fleb[lin] + fdeb[din];\n                    ++lf[257 + lin];\n                    ++df[din];\n                    wi = i + l;\n                    ++lc_1;\n                }\n                else {\n                    syms[li++] = dat[i];\n                    ++lf[dat[i]];\n                }\n            }\n        }\n        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);\n        // this is the easiest way to avoid needing to maintain state\n        if (!lst && pos & 7)\n            pos = wfblk(w, pos + 1, et);\n    }\n    return slc(o, 0, pre + shft(pos) + post);\n};\n// CRC32 table\nvar crct = /*#__PURE__*/ (function () {\n    var t = new Int32Array(256);\n    for (var i = 0; i < 256; ++i) {\n        var c = i, k = 9;\n        while (--k)\n            c = ((c & 1) && -306674912) ^ (c >>> 1);\n        t[i] = c;\n    }\n    return t;\n})();\n// CRC32\nvar crc = function () {\n    var c = -1;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var cr = c;\n            for (var i = 0; i < d.length; ++i)\n                cr = crct[(cr & 255) ^ d[i]] ^ (cr >>> 8);\n            c = cr;\n        },\n        d: function () { return ~c; }\n    };\n};\n// Alder32\nvar adler = function () {\n    var a = 1, b = 0;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var n = a, m = b;\n            var l = d.length | 0;\n            for (var i = 0; i != l;) {\n                var e = Math.min(i + 2655, l);\n                for (; i < e; ++i)\n                    m += n += d[i];\n                n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);\n            }\n            a = n, b = m;\n        },\n        d: function () {\n            a %= 65521, b %= 65521;\n            return (a & 255) << 24 | (a >>> 8) << 16 | (b & 255) << 8 | (b >>> 8);\n        }\n    };\n};\n;\n// deflate with opts\nvar dopt = function (dat, opt, pre, post, st) {\n    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : (12 + opt.mem), pre, post, !st);\n};\n// Walmart object spread\nvar mrg = function (a, b) {\n    var o = {};\n    for (var k in a)\n        o[k] = a[k];\n    for (var k in b)\n        o[k] = b[k];\n    return o;\n};\n// worker clone\n// This is possibly the craziest part of the entire codebase, despite how simple it may seem.\n// The only parameter to this function is a closure that returns an array of variables outside of the function scope.\n// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.\n// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).\n// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.\n// This took me three weeks to figure out how to do.\nvar wcln = function (fn, fnStr, td) {\n    var dt = fn();\n    var st = fn.toString();\n    var ks = st.slice(st.indexOf('[') + 1, st.lastIndexOf(']')).replace(/\\s+/g, '').split(',');\n    for (var i = 0; i < dt.length; ++i) {\n        var v = dt[i], k = ks[i];\n        if (typeof v == 'function') {\n            fnStr += ';' + k + '=';\n            var st_1 = v.toString();\n            if (v.prototype) {\n                // for global objects\n                if (st_1.indexOf('[native code]') != -1) {\n                    var spInd = st_1.indexOf(' ', 8) + 1;\n                    fnStr += st_1.slice(spInd, st_1.indexOf('(', spInd));\n                }\n                else {\n                    fnStr += st_1;\n                    for (var t in v.prototype)\n                        fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[t].toString();\n                }\n            }\n            else\n                fnStr += st_1;\n        }\n        else\n            td[k] = v;\n    }\n    return [fnStr, td];\n};\nvar ch = [];\n// clone bufs\nvar cbfs = function (v) {\n    var tl = [];\n    for (var k in v) {\n        if (v[k].buffer) {\n            tl.push((v[k] = new v[k].constructor(v[k])).buffer);\n        }\n    }\n    return tl;\n};\n// use a worker to execute code\nvar wrkr = function (fns, init, id, cb) {\n    var _a;\n    if (!ch[id]) {\n        var fnStr = '', td_1 = {}, m = fns.length - 1;\n        for (var i = 0; i < m; ++i)\n            _a = wcln(fns[i], fnStr, td_1), fnStr = _a[0], td_1 = _a[1];\n        ch[id] = wcln(fns[m], fnStr, td_1);\n    }\n    var td = mrg({}, ch[id][1]);\n    return wk(ch[id][0] + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + init.toString() + '}', id, td, cbfs(td), cb);\n};\n// base async inflate fn\nvar bInflt = function () { return [u8, u16, u32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gu8]; };\nvar bDflt = function () { return [u8, u16, u32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf]; };\n// gzip extra\nvar gze = function () { return [gzh, gzhl, wbytes, crc, crct]; };\n// gunzip extra\nvar guze = function () { return [gzs, gzl]; };\n// zlib extra\nvar zle = function () { return [zlh, wbytes, adler]; };\n// unzlib extra\nvar zule = function () { return [zlv]; };\n// post buf\nvar pbf = function (msg) { return postMessage(msg, [msg.buffer]); };\n// get u8\nvar gu8 = function (o) { return o && o.size && new u8(o.size); };\n// async helper\nvar cbify = function (dat, opts, fns, init, id, cb) {\n    var w = wrkr(fns, init, id, function (err, dat) {\n        w.terminate();\n        cb(err, dat);\n    });\n    w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);\n    return function () { w.terminate(); };\n};\n// auto stream\nvar astrm = function (strm) {\n    strm.ondata = function (dat, final) { return postMessage([dat, final], [dat.buffer]); };\n    return function (ev) { return strm.push(ev.data[0], ev.data[1]); };\n};\n// async stream attach\nvar astrmify = function (fns, strm, opts, init, id) {\n    var t;\n    var w = wrkr(fns, init, id, function (err, dat) {\n        if (err)\n            w.terminate(), strm.ondata.call(strm, err);\n        else {\n            if (dat[1])\n                w.terminate();\n            strm.ondata.call(strm, err, dat[0], dat[1]);\n        }\n    });\n    w.postMessage(opts);\n    strm.push = function (d, f) {\n        if (!strm.ondata)\n            err(5);\n        if (t)\n            strm.ondata(err(4, 0, 1), null, !!f);\n        w.postMessage([d, t = f], [d.buffer]);\n    };\n    strm.terminate = function () { w.terminate(); };\n};\n// read 2 bytes\nvar b2 = function (d, b) { return d[b] | (d[b + 1] << 8); };\n// read 4 bytes\nvar b4 = function (d, b) { return (d[b] | (d[b + 1] << 8) | (d[b + 2] << 16) | (d[b + 3] << 24)) >>> 0; };\nvar b8 = function (d, b) { return b4(d, b) + (b4(d, b + 4) * 4294967296); };\n// write bytes\nvar wbytes = function (d, b, v) {\n    for (; v; ++b)\n        d[b] = v, v >>>= 8;\n};\n// gzip header\nvar gzh = function (c, o) {\n    var fn = o.filename;\n    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix\n    if (o.mtime != 0)\n        wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));\n    if (fn) {\n        c[3] = 8;\n        for (var i = 0; i <= fn.length; ++i)\n            c[i + 10] = fn.charCodeAt(i);\n    }\n};\n// gzip footer: -8 to -4 = CRC, -4 to -0 is length\n// gzip start\nvar gzs = function (d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n        err(6, 'invalid gzip data');\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4)\n        st += d[10] | (d[11] << 8) + 2;\n    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\n        ;\n    return st + (flg & 2);\n};\n// gzip length\nvar gzl = function (d) {\n    var l = d.length;\n    return ((d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16) | (d[l - 1] << 24)) >>> 0;\n};\n// gzip header length\nvar gzhl = function (o) { return 10 + ((o.filename && (o.filename.length + 1)) || 0); };\n// zlib header\nvar zlh = function (c, o) {\n    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\n    c[0] = 120, c[1] = (fl << 6) | (fl ? (32 - 2 * fl) : 1);\n};\n// zlib valid\nvar zlv = function (d) {\n    if ((d[0] & 15) != 8 || (d[0] >>> 4) > 7 || ((d[0] << 8 | d[1]) % 31))\n        err(6, 'invalid zlib data');\n    if (d[1] & 32)\n        err(6, 'invalid zlib data: preset dictionaries not supported');\n};\nfunction AsyncCmpStrm(opts, cb) {\n    if (!cb && typeof opts == 'function')\n        cb = opts, opts = {};\n    this.ondata = cb;\n    return opts;\n}\n// zlib footer: -4 to -0 is Adler32\n/**\n * Streaming DEFLATE compression\n */\nvar Deflate = /*#__PURE__*/ (function () {\n    function Deflate(opts, cb) {\n        if (!cb && typeof opts == 'function')\n            cb = opts, opts = {};\n        this.ondata = cb;\n        this.o = opts || {};\n    }\n    Deflate.prototype.p = function (c, f) {\n        this.ondata(dopt(c, this.o, 0, 0, !f), f);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Deflate.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        this.d = final;\n        this.p(chunk, final || false);\n    };\n    return Deflate;\n}());\nexport { Deflate };\n/**\n * Asynchronous streaming DEFLATE compression\n */\nvar AsyncDeflate = /*#__PURE__*/ (function () {\n    function AsyncDeflate(opts, cb) {\n        astrmify([\n            bDflt,\n            function () { return [astrm, Deflate]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Deflate(ev.data);\n            onmessage = astrm(strm);\n        }, 6);\n    }\n    return AsyncDeflate;\n}());\nexport { AsyncDeflate };\nexport function deflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n    ], function (ev) { return pbf(deflateSync(ev.data[0], ev.data[1])); }, 0, cb);\n}\n/**\n * Compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param opts The compression options\n * @returns The deflated version of the data\n */\nexport function deflateSync(data, opts) {\n    return dopt(data, opts || {}, 0, 0);\n}\n/**\n * Streaming DEFLATE decompression\n */\nvar Inflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an inflation stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Inflate(cb) {\n        this.s = {};\n        this.p = new u8(0);\n        this.ondata = cb;\n    }\n    Inflate.prototype.e = function (c) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        var l = this.p.length;\n        var n = new u8(l + c.length);\n        n.set(this.p), n.set(c, l), this.p = n;\n    };\n    Inflate.prototype.c = function (final) {\n        this.d = this.s.i = final || false;\n        var bts = this.s.b;\n        var dt = inflt(this.p, this.o, this.s);\n        this.ondata(slc(dt, bts, this.s.b), this.d);\n        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n        this.p = slc(this.p, (this.s.p / 8) | 0), this.s.p &= 7;\n    };\n    /**\n     * Pushes a chunk to be inflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the final chunk\n     */\n    Inflate.prototype.push = function (chunk, final) {\n        this.e(chunk), this.c(final);\n    };\n    return Inflate;\n}());\nexport { Inflate };\n/**\n * Asynchronous streaming DEFLATE decompression\n */\nvar AsyncInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous inflation stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncInflate(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            function () { return [astrm, Inflate]; }\n        ], this, 0, function () {\n            var strm = new Inflate();\n            onmessage = astrm(strm);\n        }, 7);\n    }\n    return AsyncInflate;\n}());\nexport { AsyncInflate };\nexport function inflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt\n    ], function (ev) { return pbf(inflateSync(ev.data[0], gu8(ev.data[1]))); }, 1, cb);\n}\n/**\n * Expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function inflateSync(data, out) {\n    return inflt(data, out);\n}\n// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.\n/**\n * Streaming GZIP compression\n */\nvar Gzip = /*#__PURE__*/ (function () {\n    function Gzip(opts, cb) {\n        this.c = crc();\n        this.l = 0;\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gzip.prototype.push = function (chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Gzip.prototype.p = function (c, f) {\n        this.c.p(c);\n        this.l += c.length;\n        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, !f);\n        if (this.v)\n            gzh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);\n        this.ondata(raw, f);\n    };\n    return Gzip;\n}());\nexport { Gzip };\n/**\n * Asynchronous streaming GZIP compression\n */\nvar AsyncGzip = /*#__PURE__*/ (function () {\n    function AsyncGzip(opts, cb) {\n        astrmify([\n            bDflt,\n            gze,\n            function () { return [astrm, Deflate, Gzip]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Gzip(ev.data);\n            onmessage = astrm(strm);\n        }, 8);\n    }\n    return AsyncGzip;\n}());\nexport { AsyncGzip };\nexport function gzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n        gze,\n        function () { return [gzipSync]; }\n    ], function (ev) { return pbf(gzipSync(ev.data[0], ev.data[1])); }, 2, cb);\n}\n/**\n * Compresses data with GZIP\n * @param data The data to compress\n * @param opts The compression options\n * @returns The gzipped version of the data\n */\nexport function gzipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var c = crc(), l = data.length;\n    c.p(data);\n    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;\n    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;\n}\n/**\n * Streaming GZIP decompression\n */\nvar Gunzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a GUNZIP stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Gunzip(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be GUNZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gunzip.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            var s = this.p.length > 3 ? gzs(this.p) : 4;\n            if (s >= this.p.length && !final)\n                return;\n            this.p = this.p.subarray(s), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 8)\n                err(6, 'invalid gzip data');\n            this.p = this.p.subarray(0, -8);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Gunzip;\n}());\nexport { Gunzip };\n/**\n * Asynchronous streaming GZIP decompression\n */\nvar AsyncGunzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous GUNZIP stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncGunzip(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            guze,\n            function () { return [astrm, Inflate, Gunzip]; }\n        ], this, 0, function () {\n            var strm = new Gunzip();\n            onmessage = astrm(strm);\n        }, 9);\n    }\n    return AsyncGunzip;\n}());\nexport { AsyncGunzip };\nexport function gunzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt,\n        guze,\n        function () { return [gunzipSync]; }\n    ], function (ev) { return pbf(gunzipSync(ev.data[0])); }, 3, cb);\n}\n/**\n * Expands GZIP data\n * @param data The data to decompress\n * @param out Where to write the data. GZIP already encodes the output size, so providing this doesn't save memory.\n * @returns The decompressed version of the data\n */\nexport function gunzipSync(data, out) {\n    return inflt(data.subarray(gzs(data), -8), out || new u8(gzl(data)));\n}\n/**\n * Streaming Zlib compression\n */\nvar Zlib = /*#__PURE__*/ (function () {\n    function Zlib(opts, cb) {\n        this.c = adler();\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be zlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Zlib.prototype.push = function (chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Zlib.prototype.p = function (c, f) {\n        this.c.p(c);\n        var raw = dopt(c, this.o, this.v && 2, f && 4, !f);\n        if (this.v)\n            zlh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 4, this.c.d());\n        this.ondata(raw, f);\n    };\n    return Zlib;\n}());\nexport { Zlib };\n/**\n * Asynchronous streaming Zlib compression\n */\nvar AsyncZlib = /*#__PURE__*/ (function () {\n    function AsyncZlib(opts, cb) {\n        astrmify([\n            bDflt,\n            zle,\n            function () { return [astrm, Deflate, Zlib]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Zlib(ev.data);\n            onmessage = astrm(strm);\n        }, 10);\n    }\n    return AsyncZlib;\n}());\nexport { AsyncZlib };\nexport function zlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n        zle,\n        function () { return [zlibSync]; }\n    ], function (ev) { return pbf(zlibSync(ev.data[0], ev.data[1])); }, 4, cb);\n}\n/**\n * Compress data with Zlib\n * @param data The data to compress\n * @param opts The compression options\n * @returns The zlib-compressed version of the data\n */\nexport function zlibSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var a = adler();\n    a.p(data);\n    var d = dopt(data, opts, 2, 4);\n    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;\n}\n/**\n * Streaming Zlib decompression\n */\nvar Unzlib = /*#__PURE__*/ (function () {\n    /**\n     * Creates a Zlib decompression stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Unzlib(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be unzlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzlib.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            if (this.p.length < 2 && !final)\n                return;\n            this.p = this.p.subarray(2), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 4)\n                err(6, 'invalid zlib data');\n            this.p = this.p.subarray(0, -4);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Unzlib;\n}());\nexport { Unzlib };\n/**\n * Asynchronous streaming Zlib decompression\n */\nvar AsyncUnzlib = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous Zlib decompression stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncUnzlib(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            zule,\n            function () { return [astrm, Inflate, Unzlib]; }\n        ], this, 0, function () {\n            var strm = new Unzlib();\n            onmessage = astrm(strm);\n        }, 11);\n    }\n    return AsyncUnzlib;\n}());\nexport { AsyncUnzlib };\nexport function unzlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt,\n        zule,\n        function () { return [unzlibSync]; }\n    ], function (ev) { return pbf(unzlibSync(ev.data[0], gu8(ev.data[1]))); }, 5, cb);\n}\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function unzlibSync(data, out) {\n    return inflt((zlv(data), data.subarray(2, -4)), out);\n}\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzip as compress, AsyncGzip as AsyncCompress };\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzipSync as compressSync, Gzip as Compress };\n/**\n * Streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar Decompress = /*#__PURE__*/ (function () {\n    /**\n     * Creates a decompression stream\n     * @param cb The callback to call whenever data is decompressed\n     */\n    function Decompress(cb) {\n        this.G = Gunzip;\n        this.I = Inflate;\n        this.Z = Unzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Decompress.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (!this.s) {\n            if (this.p && this.p.length) {\n                var n = new u8(this.p.length + chunk.length);\n                n.set(this.p), n.set(chunk, this.p.length);\n            }\n            else\n                this.p = chunk;\n            if (this.p.length > 2) {\n                var _this_1 = this;\n                var cb = function () { _this_1.ondata.apply(_this_1, arguments); };\n                this.s = (this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8)\n                    ? new this.G(cb)\n                    : ((this.p[0] & 15) != 8 || (this.p[0] >> 4) > 7 || ((this.p[0] << 8 | this.p[1]) % 31))\n                        ? new this.I(cb)\n                        : new this.Z(cb);\n                this.s.push(this.p, final);\n                this.p = null;\n            }\n        }\n        else\n            this.s.push(chunk, final);\n    };\n    return Decompress;\n}());\nexport { Decompress };\n/**\n * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar AsyncDecompress = /*#__PURE__*/ (function () {\n    /**\n   * Creates an asynchronous decompression stream\n   * @param cb The callback to call whenever data is decompressed\n   */\n    function AsyncDecompress(cb) {\n        this.G = AsyncGunzip;\n        this.I = AsyncInflate;\n        this.Z = AsyncUnzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncDecompress.prototype.push = function (chunk, final) {\n        Decompress.prototype.push.call(this, chunk, final);\n    };\n    return AsyncDecompress;\n}());\nexport { AsyncDecompress };\nexport function decompress(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzip(data, opts, cb)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflate(data, opts, cb)\n            : unzlib(data, opts, cb);\n}\n/**\n * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function decompressSync(data, out) {\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzipSync(data, out)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflateSync(data, out)\n            : unzlibSync(data, out);\n}\n// flatten a directory structure\nvar fltn = function (d, p, t, o) {\n    for (var k in d) {\n        var val = d[k], n = p + k, op = o;\n        if (Array.isArray(val))\n            op = mrg(o, val[1]), val = val[0];\n        if (val instanceof u8)\n            t[n] = [val, op];\n        else {\n            t[n += '/'] = [new u8(0), op];\n            fltn(val, n, t, o);\n        }\n    }\n};\n// text encoder\nvar te = typeof TextEncoder != 'undefined' && /*#__PURE__*/ new TextEncoder();\n// text decoder\nvar td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();\n// text decoder stream\nvar tds = 0;\ntry {\n    td.decode(et, { stream: true });\n    tds = 1;\n}\ncatch (e) { }\n// decode UTF8\nvar dutf8 = function (d) {\n    for (var r = '', i = 0;;) {\n        var c = d[i++];\n        var eb = (c > 127) + (c > 223) + (c > 239);\n        if (i + eb > d.length)\n            return [r, slc(d, i - 1)];\n        if (!eb)\n            r += String.fromCharCode(c);\n        else if (eb == 3) {\n            c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63)) - 65536,\n                r += String.fromCharCode(55296 | (c >> 10), 56320 | (c & 1023));\n        }\n        else if (eb & 1)\n            r += String.fromCharCode((c & 31) << 6 | (d[i++] & 63));\n        else\n            r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63));\n    }\n};\n/**\n * Streaming UTF-8 decoding\n */\nvar DecodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is decoded\n     */\n    function DecodeUTF8(cb) {\n        this.ondata = cb;\n        if (tds)\n            this.t = new TextDecoder();\n        else\n            this.p = et;\n    }\n    /**\n     * Pushes a chunk to be decoded from UTF-8 binary\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    DecodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        final = !!final;\n        if (this.t) {\n            this.ondata(this.t.decode(chunk, { stream: true }), final);\n            if (final) {\n                if (this.t.decode().length)\n                    err(8);\n                this.t = null;\n            }\n            return;\n        }\n        if (!this.p)\n            err(4);\n        var dat = new u8(this.p.length + chunk.length);\n        dat.set(this.p);\n        dat.set(chunk, this.p.length);\n        var _a = dutf8(dat), ch = _a[0], np = _a[1];\n        if (final) {\n            if (np.length)\n                err(8);\n            this.p = null;\n        }\n        else\n            this.p = np;\n        this.ondata(ch, final);\n    };\n    return DecodeUTF8;\n}());\nexport { DecodeUTF8 };\n/**\n * Streaming UTF-8 encoding\n */\nvar EncodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is encoded\n     */\n    function EncodeUTF8(cb) {\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be encoded to UTF-8\n     * @param chunk The string data to push\n     * @param final Whether this is the last chunk\n     */\n    EncodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        this.ondata(strToU8(chunk), this.d = final || false);\n    };\n    return EncodeUTF8;\n}());\nexport { EncodeUTF8 };\n/**\n * Converts a string into a Uint8Array for use with compression/decompression methods\n * @param str The string to encode\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless decoding a binary string.\n * @returns The string encoded in UTF-8/Latin-1 binary\n */\nexport function strToU8(str, latin1) {\n    if (latin1) {\n        var ar_1 = new u8(str.length);\n        for (var i = 0; i < str.length; ++i)\n            ar_1[i] = str.charCodeAt(i);\n        return ar_1;\n    }\n    if (te)\n        return te.encode(str);\n    var l = str.length;\n    var ar = new u8(str.length + (str.length >> 1));\n    var ai = 0;\n    var w = function (v) { ar[ai++] = v; };\n    for (var i = 0; i < l; ++i) {\n        if (ai + 5 > ar.length) {\n            var n = new u8(ai + 8 + ((l - i) << 1));\n            n.set(ar);\n            ar = n;\n        }\n        var c = str.charCodeAt(i);\n        if (c < 128 || latin1)\n            w(c);\n        else if (c < 2048)\n            w(192 | (c >> 6)), w(128 | (c & 63));\n        else if (c > 55295 && c < 57344)\n            c = 65536 + (c & 1023 << 10) | (str.charCodeAt(++i) & 1023),\n                w(240 | (c >> 18)), w(128 | ((c >> 12) & 63)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n        else\n            w(224 | (c >> 12)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n    }\n    return slc(ar, 0, ai);\n}\n/**\n * Converts a Uint8Array to a string\n * @param dat The data to decode to string\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless encoding to binary string.\n * @returns The original UTF-8/Latin-1 string\n */\nexport function strFromU8(dat, latin1) {\n    if (latin1) {\n        var r = '';\n        for (var i = 0; i < dat.length; i += 16384)\n            r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));\n        return r;\n    }\n    else if (td)\n        return td.decode(dat);\n    else {\n        var _a = dutf8(dat), out = _a[0], ext = _a[1];\n        if (ext.length)\n            err(8);\n        return out;\n    }\n}\n;\n// deflate bit flag\nvar dbf = function (l) { return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0; };\n// skip local zip header\nvar slzh = function (d, b) { return b + 30 + b2(d, b + 26) + b2(d, b + 28); };\n// read zip header\nvar zh = function (d, b, z) {\n    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\n    var _a = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a[0], su = _a[1], off = _a[2];\n    return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];\n};\n// read zip64 extra field\nvar z64e = function (d, b) {\n    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))\n        ;\n    return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];\n};\n// extra field length\nvar exfl = function (ex) {\n    var le = 0;\n    if (ex) {\n        for (var k in ex) {\n            var l = ex[k].length;\n            if (l > 65535)\n                err(9);\n            le += l + 4;\n        }\n    }\n    return le;\n};\n// write zip header\nvar wzh = function (d, b, f, fn, u, c, ce, co) {\n    var fl = fn.length, ex = f.extra, col = co && co.length;\n    var exl = exfl(ex);\n    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;\n    if (ce != null)\n        d[b++] = 20, d[b++] = f.os;\n    d[b] = 20, b += 2; // spec compliance? what's that?\n    d[b++] = (f.flag << 1) | (c < 0 && 8), d[b++] = u && 8;\n    d[b++] = f.compression & 255, d[b++] = f.compression >> 8;\n    var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;\n    if (y < 0 || y > 119)\n        err(10);\n    wbytes(d, b, (y << 25) | ((dt.getMonth() + 1) << 21) | (dt.getDate() << 16) | (dt.getHours() << 11) | (dt.getMinutes() << 5) | (dt.getSeconds() >>> 1)), b += 4;\n    if (c != -1) {\n        wbytes(d, b, f.crc);\n        wbytes(d, b + 4, c < 0 ? -c - 2 : c);\n        wbytes(d, b + 8, f.size);\n    }\n    wbytes(d, b + 12, fl);\n    wbytes(d, b + 14, exl), b += 16;\n    if (ce != null) {\n        wbytes(d, b, col);\n        wbytes(d, b + 6, f.attrs);\n        wbytes(d, b + 10, ce), b += 14;\n    }\n    d.set(fn, b);\n    b += fl;\n    if (exl) {\n        for (var k in ex) {\n            var exf = ex[k], l = exf.length;\n            wbytes(d, b, +k);\n            wbytes(d, b + 2, l);\n            d.set(exf, b + 4), b += 4 + l;\n        }\n    }\n    if (col)\n        d.set(co, b), b += col;\n    return b;\n};\n// write zip footer (end of central directory)\nvar wzf = function (o, b, c, d, e) {\n    wbytes(o, b, 0x6054B50); // skip disk\n    wbytes(o, b + 8, c);\n    wbytes(o, b + 10, c);\n    wbytes(o, b + 12, d);\n    wbytes(o, b + 16, e);\n};\n/**\n * A pass-through stream to keep data uncompressed in a ZIP archive.\n */\nvar ZipPassThrough = /*#__PURE__*/ (function () {\n    /**\n     * Creates a pass-through stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     */\n    function ZipPassThrough(filename) {\n        this.filename = filename;\n        this.c = crc();\n        this.size = 0;\n        this.compression = 0;\n    }\n    /**\n     * Processes a chunk and pushes to the output stream. You can override this\n     * method in a subclass for custom behavior, but by default this passes\n     * the data through. You must call this.ondata(err, chunk, final) at some\n     * point in this method.\n     * @param chunk The chunk to process\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.process = function (chunk, final) {\n        this.ondata(null, chunk, final);\n    };\n    /**\n     * Pushes a chunk to be added. If you are subclassing this with a custom\n     * compression algorithm, note that you must push data from the source\n     * file only, pre-compression.\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        this.c.p(chunk);\n        this.size += chunk.length;\n        if (final)\n            this.crc = this.c.d();\n        this.process(chunk, final || false);\n    };\n    return ZipPassThrough;\n}());\nexport { ZipPassThrough };\n// I don't extend because TypeScript extension adds 1kB of runtime bloat\n/**\n * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate\n * for better performance\n */\nvar ZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function ZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new Deflate(opts, function (dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n    }\n    ZipDeflate.prototype.process = function (chunk, final) {\n        try {\n            this.d.push(chunk, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return ZipDeflate;\n}());\nexport { ZipDeflate };\n/**\n * Asynchronous streaming DEFLATE compression for ZIP archives\n */\nvar AsyncZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function AsyncZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new AsyncDeflate(opts, function (err, dat, final) {\n            _this_1.ondata(err, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n        this.terminate = this.d.terminate;\n    }\n    AsyncZipDeflate.prototype.process = function (chunk, final) {\n        this.d.push(chunk, final);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return AsyncZipDeflate;\n}());\nexport { AsyncZipDeflate };\n// TODO: Better tree shaking\n/**\n * A zippable archive to which files can incrementally be added\n */\nvar Zip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an empty ZIP archive to which files can be added\n     * @param cb The callback to call whenever data for the generated ZIP archive\n     *           is available\n     */\n    function Zip(cb) {\n        this.ondata = cb;\n        this.u = [];\n        this.d = 1;\n    }\n    /**\n     * Adds a file to the ZIP archive\n     * @param file The file stream to add\n     */\n    Zip.prototype.add = function (file) {\n        var _this_1 = this;\n        if (!this.ondata)\n            err(5);\n        // finishing or finished\n        if (this.d & 2)\n            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, false);\n        else {\n            var f = strToU8(file.filename), fl_1 = f.length;\n            var com = file.comment, o = com && strToU8(com);\n            var u = fl_1 != file.filename.length || (o && (com.length != o.length));\n            var hl_1 = fl_1 + exfl(file.extra) + 30;\n            if (fl_1 > 65535)\n                this.ondata(err(11, 0, 1), null, false);\n            var header = new u8(hl_1);\n            wzh(header, 0, file, f, u, -1);\n            var chks_1 = [header];\n            var pAll_1 = function () {\n                for (var _i = 0, chks_2 = chks_1; _i < chks_2.length; _i++) {\n                    var chk = chks_2[_i];\n                    _this_1.ondata(null, chk, false);\n                }\n                chks_1 = [];\n            };\n            var tr_1 = this.d;\n            this.d = 0;\n            var ind_1 = this.u.length;\n            var uf_1 = mrg(file, {\n                f: f,\n                u: u,\n                o: o,\n                t: function () {\n                    if (file.terminate)\n                        file.terminate();\n                },\n                r: function () {\n                    pAll_1();\n                    if (tr_1) {\n                        var nxt = _this_1.u[ind_1 + 1];\n                        if (nxt)\n                            nxt.r();\n                        else\n                            _this_1.d = 1;\n                    }\n                    tr_1 = 1;\n                }\n            });\n            var cl_1 = 0;\n            file.ondata = function (err, dat, final) {\n                if (err) {\n                    _this_1.ondata(err, dat, final);\n                    _this_1.terminate();\n                }\n                else {\n                    cl_1 += dat.length;\n                    chks_1.push(dat);\n                    if (final) {\n                        var dd = new u8(16);\n                        wbytes(dd, 0, 0x8074B50);\n                        wbytes(dd, 4, file.crc);\n                        wbytes(dd, 8, cl_1);\n                        wbytes(dd, 12, file.size);\n                        chks_1.push(dd);\n                        uf_1.c = cl_1, uf_1.b = hl_1 + cl_1 + 16, uf_1.crc = file.crc, uf_1.size = file.size;\n                        if (tr_1)\n                            uf_1.r();\n                        tr_1 = 1;\n                    }\n                    else if (tr_1)\n                        pAll_1();\n                }\n            };\n            this.u.push(uf_1);\n        }\n    };\n    /**\n     * Ends the process of adding files and prepares to emit the final chunks.\n     * This *must* be called after adding all desired files for the resulting\n     * ZIP file to work properly.\n     */\n    Zip.prototype.end = function () {\n        var _this_1 = this;\n        if (this.d & 2) {\n            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, true);\n            return;\n        }\n        if (this.d)\n            this.e();\n        else\n            this.u.push({\n                r: function () {\n                    if (!(_this_1.d & 1))\n                        return;\n                    _this_1.u.splice(-1, 1);\n                    _this_1.e();\n                },\n                t: function () { }\n            });\n        this.d = 3;\n    };\n    Zip.prototype.e = function () {\n        var bt = 0, l = 0, tl = 0;\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);\n        }\n        var out = new u8(tl + 22);\n        for (var _b = 0, _c = this.u; _b < _c.length; _b++) {\n            var f = _c[_b];\n            wzh(out, bt, f, f.f, f.u, -f.c - 2, l, f.o);\n            bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;\n        }\n        wzf(out, bt, this.u.length, tl, l);\n        this.ondata(null, out, true);\n        this.d = 2;\n    };\n    /**\n     * A method to terminate any internal workers used by the stream. Subsequent\n     * calls to add() will fail.\n     */\n    Zip.prototype.terminate = function () {\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            f.t();\n        }\n        this.d = 2;\n    };\n    return Zip;\n}());\nexport { Zip };\nexport function zip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    var r = {};\n    fltn(data, '', r, opts);\n    var k = Object.keys(r);\n    var lft = k.length, o = 0, tot = 0;\n    var slft = lft, files = new Array(lft);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var cbd = function (a, b) {\n        mt(function () { cb(a, b); });\n    };\n    mt(function () { cbd = cb; });\n    var cbf = function () {\n        var out = new u8(tot + 22), oe = o, cdl = tot - o;\n        tot = 0;\n        for (var i = 0; i < slft; ++i) {\n            var f = files[i];\n            try {\n                var l = f.c.length;\n                wzh(out, tot, f, f.f, f.u, l);\n                var badd = 30 + f.f.length + exfl(f.extra);\n                var loc = tot + badd;\n                out.set(f.c, loc);\n                wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;\n            }\n            catch (e) {\n                return cbd(e, null);\n            }\n        }\n        wzf(out, o, files.length, cdl, oe);\n        cbd(null, out);\n    };\n    if (!lft)\n        cbf();\n    var _loop_1 = function (i) {\n        var fn = k[i];\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var c = crc(), size = file.length;\n        c.p(file);\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        var compression = p.level == 0 ? 0 : 8;\n        var cbl = function (e, d) {\n            if (e) {\n                tAll();\n                cbd(e, null);\n            }\n            else {\n                var l = d.length;\n                files[i] = mrg(p, {\n                    size: size,\n                    crc: c.d(),\n                    c: d,\n                    f: f,\n                    m: m,\n                    u: s != fn.length || (m && (com.length != ms)),\n                    compression: compression\n                });\n                o += 30 + s + exl + l;\n                tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n                if (!--lft)\n                    cbf();\n            }\n        };\n        if (s > 65535)\n            cbl(err(11, 0, 1), null);\n        if (!compression)\n            cbl(null, file);\n        else if (size < 160000) {\n            try {\n                cbl(null, deflateSync(file, p));\n            }\n            catch (e) {\n                cbl(e, null);\n            }\n        }\n        else\n            term.push(deflate(file, p, cbl));\n    };\n    // Cannot use lft because it can decrease\n    for (var i = 0; i < slft; ++i) {\n        _loop_1(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously creates a ZIP file. Prefer using `zip` for better performance\n * with more than one file.\n * @param data The directory structure for the ZIP archive\n * @param opts The main options, merged with per-file options\n * @returns The generated ZIP archive\n */\nexport function zipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var r = {};\n    var files = [];\n    fltn(data, '', r, opts);\n    var o = 0;\n    var tot = 0;\n    for (var fn in r) {\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var compression = p.level == 0 ? 0 : 8;\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        if (s > 65535)\n            err(11);\n        var d = compression ? deflateSync(file, p) : file, l = d.length;\n        var c = crc();\n        c.p(file);\n        files.push(mrg(p, {\n            size: file.length,\n            crc: c.d(),\n            c: d,\n            f: f,\n            m: m,\n            u: s != fn.length || (m && (com.length != ms)),\n            o: o,\n            compression: compression\n        }));\n        o += 30 + s + exl + l;\n        tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n    }\n    var out = new u8(tot + 22), oe = o, cdl = tot - o;\n    for (var i = 0; i < files.length; ++i) {\n        var f = files[i];\n        wzh(out, f.o, f, f.f, f.u, f.c.length);\n        var badd = 30 + f.f.length + exfl(f.extra);\n        out.set(f.c, f.o + badd);\n        wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);\n    }\n    wzf(out, o, files.length, cdl, oe);\n    return out;\n}\n/**\n * Streaming pass-through decompression for ZIP archives\n */\nvar UnzipPassThrough = /*#__PURE__*/ (function () {\n    function UnzipPassThrough() {\n    }\n    UnzipPassThrough.prototype.push = function (data, final) {\n        this.ondata(null, data, final);\n    };\n    UnzipPassThrough.compression = 0;\n    return UnzipPassThrough;\n}());\nexport { UnzipPassThrough };\n/**\n * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for\n * better performance.\n */\nvar UnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function UnzipInflate() {\n        var _this_1 = this;\n        this.i = new Inflate(function (dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n    }\n    UnzipInflate.prototype.push = function (data, final) {\n        try {\n            this.i.push(data, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    UnzipInflate.compression = 8;\n    return UnzipInflate;\n}());\nexport { UnzipInflate };\n/**\n * Asynchronous streaming DEFLATE decompression for ZIP archives\n */\nvar AsyncUnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function AsyncUnzipInflate(_, sz) {\n        var _this_1 = this;\n        if (sz < 320000) {\n            this.i = new Inflate(function (dat, final) {\n                _this_1.ondata(null, dat, final);\n            });\n        }\n        else {\n            this.i = new AsyncInflate(function (err, dat, final) {\n                _this_1.ondata(err, dat, final);\n            });\n            this.terminate = this.i.terminate;\n        }\n    }\n    AsyncUnzipInflate.prototype.push = function (data, final) {\n        if (this.i.terminate)\n            data = slc(data, 0);\n        this.i.push(data, final);\n    };\n    AsyncUnzipInflate.compression = 8;\n    return AsyncUnzipInflate;\n}());\nexport { AsyncUnzipInflate };\n/**\n * A ZIP archive decompression stream that emits files as they are discovered\n */\nvar Unzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a ZIP decompression stream\n     * @param cb The callback to call whenever a file in the ZIP archive is found\n     */\n    function Unzip(cb) {\n        this.onfile = cb;\n        this.k = [];\n        this.o = {\n            0: UnzipPassThrough\n        };\n        this.p = et;\n    }\n    /**\n     * Pushes a chunk to be unzipped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzip.prototype.push = function (chunk, final) {\n        var _this_1 = this;\n        if (!this.onfile)\n            err(5);\n        if (!this.p)\n            err(4);\n        if (this.c > 0) {\n            var len = Math.min(this.c, chunk.length);\n            var toAdd = chunk.subarray(0, len);\n            this.c -= len;\n            if (this.d)\n                this.d.push(toAdd, !this.c);\n            else\n                this.k[0].push(toAdd);\n            chunk = chunk.subarray(len);\n            if (chunk.length)\n                return this.push(chunk, final);\n        }\n        else {\n            var f = 0, i = 0, is = void 0, buf = void 0;\n            if (!this.p.length)\n                buf = chunk;\n            else if (!chunk.length)\n                buf = this.p;\n            else {\n                buf = new u8(this.p.length + chunk.length);\n                buf.set(this.p), buf.set(chunk, this.p.length);\n            }\n            var l = buf.length, oc = this.c, add = oc && this.d;\n            var _loop_2 = function () {\n                var _a;\n                var sig = b4(buf, i);\n                if (sig == 0x4034B50) {\n                    f = 1, is = i;\n                    this_1.d = null;\n                    this_1.c = 0;\n                    var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);\n                    if (l > i + 30 + fnl + es) {\n                        var chks_3 = [];\n                        this_1.k.unshift(chks_3);\n                        f = 2;\n                        var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);\n                        var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);\n                        if (sc_1 == 4294967295) {\n                            _a = dd ? [-2] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];\n                        }\n                        else if (dd)\n                            sc_1 = -1;\n                        i += es;\n                        this_1.c = sc_1;\n                        var d_1;\n                        var file_1 = {\n                            name: fn_1,\n                            compression: cmp_1,\n                            start: function () {\n                                if (!file_1.ondata)\n                                    err(5);\n                                if (!sc_1)\n                                    file_1.ondata(null, et, true);\n                                else {\n                                    var ctr = _this_1.o[cmp_1];\n                                    if (!ctr)\n                                        file_1.ondata(err(14, 'unknown compression type ' + cmp_1, 1), null, false);\n                                    d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);\n                                    d_1.ondata = function (err, dat, final) { file_1.ondata(err, dat, final); };\n                                    for (var _i = 0, chks_4 = chks_3; _i < chks_4.length; _i++) {\n                                        var dat = chks_4[_i];\n                                        d_1.push(dat, false);\n                                    }\n                                    if (_this_1.k[0] == chks_3 && _this_1.c)\n                                        _this_1.d = d_1;\n                                    else\n                                        d_1.push(et, true);\n                                }\n                            },\n                            terminate: function () {\n                                if (d_1 && d_1.terminate)\n                                    d_1.terminate();\n                            }\n                        };\n                        if (sc_1 >= 0)\n                            file_1.size = sc_1, file_1.originalSize = su_1;\n                        this_1.onfile(file_1);\n                    }\n                    return \"break\";\n                }\n                else if (oc) {\n                    if (sig == 0x8074B50) {\n                        is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                    else if (sig == 0x2014B50) {\n                        is = i -= 4, f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                }\n            };\n            var this_1 = this;\n            for (; i < l - 4; ++i) {\n                var state_1 = _loop_2();\n                if (state_1 === \"break\")\n                    break;\n            }\n            this.p = et;\n            if (oc < 0) {\n                var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);\n                if (add)\n                    add.push(dat, !!f);\n                else\n                    this.k[+(f == 2)].push(dat);\n            }\n            if (f & 2)\n                return this.push(buf.subarray(i), final);\n            this.p = buf.subarray(i);\n        }\n        if (final) {\n            if (this.c)\n                err(13);\n            this.p = null;\n        }\n    };\n    /**\n     * Registers a decoder with the stream, allowing for files compressed with\n     * the compression type provided to be expanded correctly\n     * @param decoder The decoder constructor\n     */\n    Unzip.prototype.register = function (decoder) {\n        this.o[decoder.compression] = decoder;\n    };\n    return Unzip;\n}());\nexport { Unzip };\nvar mt = typeof queueMicrotask == 'function' ? queueMicrotask : typeof setTimeout == 'function' ? setTimeout : function (fn) { fn(); };\nexport function unzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var files = {};\n    var cbd = function (a, b) {\n        mt(function () { cb(a, b); });\n    };\n    mt(function () { cbd = cb; });\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558) {\n            cbd(err(13, 0, 1), null);\n            return tAll;\n        }\n    }\n    ;\n    var lft = b2(data, e + 8);\n    if (lft) {\n        var c = lft;\n        var o = b4(data, e + 16);\n        var z = o == 4294967295 || c == 65535;\n        if (z) {\n            var ze = b4(data, e - 12);\n            z = b4(data, ze) == 0x6064B50;\n            if (z) {\n                c = lft = b4(data, ze + 32);\n                o = b4(data, ze + 48);\n            }\n        }\n        var fltr = opts && opts.filter;\n        var _loop_3 = function (i) {\n            var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n            o = no;\n            var cbl = function (e, d) {\n                if (e) {\n                    tAll();\n                    cbd(e, null);\n                }\n                else {\n                    if (d)\n                        files[fn] = d;\n                    if (!--lft)\n                        cbd(null, files);\n                }\n            };\n            if (!fltr || fltr({\n                name: fn,\n                size: sc,\n                originalSize: su,\n                compression: c_1\n            })) {\n                if (!c_1)\n                    cbl(null, slc(data, b, b + sc));\n                else if (c_1 == 8) {\n                    var infl = data.subarray(b, b + sc);\n                    if (sc < 320000) {\n                        try {\n                            cbl(null, inflateSync(infl, new u8(su)));\n                        }\n                        catch (e) {\n                            cbl(e, null);\n                        }\n                    }\n                    else\n                        term.push(inflate(infl, { size: su }, cbl));\n                }\n                else\n                    cbl(err(14, 'unknown compression type ' + c_1, 1), null);\n            }\n            else\n                cbl(null, null);\n        };\n        for (var i = 0; i < c; ++i) {\n            _loop_3(i);\n        }\n    }\n    else\n        cbd(null, {});\n    return tAll;\n}\n/**\n * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better\n * performance with more than one file.\n * @param data The raw compressed ZIP file\n * @param opts The ZIP extraction options\n * @returns The decompressed files\n */\nexport function unzipSync(data, opts) {\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558)\n            err(13);\n    }\n    ;\n    var c = b2(data, e + 8);\n    if (!c)\n        return {};\n    var o = b4(data, e + 16);\n    var z = o == 4294967295 || c == 65535;\n    if (z) {\n        var ze = b4(data, e - 12);\n        z = b4(data, ze) == 0x6064B50;\n        if (z) {\n            c = b4(data, ze + 32);\n            o = b4(data, ze + 48);\n        }\n    }\n    var fltr = opts && opts.filter;\n    for (var i = 0; i < c; ++i) {\n        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        if (!fltr || fltr({\n            name: fn,\n            size: sc,\n            originalSize: su,\n            compression: c_2\n        })) {\n            if (!c_2)\n                files[fn] = slc(data, b, b + sc);\n            else if (c_2 == 8)\n                files[fn] = inflateSync(data.subarray(b, b + sc), new u8(su));\n            else\n                err(14, 'unknown compression type ' + c_2);\n        }\n    }\n    return files;\n}\n","import * as fflate from 'fflate';\nexport default class FFlateEncoder {\n    encode(arrayBuffer) {\n        return fflate.gzipSync(new Uint8Array(arrayBuffer)).buffer;\n    }\n    decode(arrayBuffer) {\n        return fflate.gunzipSync(new Uint8Array(arrayBuffer)).buffer;\n    }\n}\n","export const SPLIT_REGEX = /\\W+/g;\nexport const TEST_REGEX = /(\\w{3,}\\W+){2,}|(\\W+\\w{3,}){2,}/;\n/**\n * detect the type of a value\n *\n * @param value Value to analyze\n * @returns type of the value\n */\nexport function getType(value) {\n    if (Array.isArray(value)) {\n        return \"array\";\n    }\n    else if (typeof value === \"object\" && value) {\n        return \"object\";\n    }\n    else if (typeof value === \"string\" && new Set(value).size < 16) {\n        return \"leaf\";\n    }\n    else if (typeof value === \"string\" && TEST_REGEX.test(value)) {\n        return \"split\";\n    }\n    else {\n        return \"leaf\";\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport Loader from \"../io/Loader\";\nimport { getType, SPLIT_REGEX } from \"./Token\";\nimport md5 from \"blueimp-md5\";\n/**\n * Class for spitting objects into tokens.\n */\nexport default class Tokenizer {\n    constructor() {\n        this.loader = new Loader();\n    }\n    /**\n     * Load json or text files and turn them into tokens.\n     *\n     * @param files files to load and reduce.\n     */\n    load(...files) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (files.some(file => typeof file !== \"string\")) {\n                throw new Error(\"Each argument passed to load must be a string.\");\n            }\n            const sortedFiles = files.sort();\n            const allData = yield Promise.all(sortedFiles.map(this.loader.load));\n            const header = this.tokenize(Object.fromEntries(allData.map((data, index) => [sortedFiles[index], data])));\n            const textEncoder = new TextEncoder();\n            header.originalDataSize = textEncoder.encode(JSON.stringify(allData)).byteLength;\n            return header;\n        });\n    }\n    /**\n     * Takes a mapping of filename and their corresponding data, and turn them into tokens.\n     *\n     * @param items Mapping from filename to data.\n     * @returns All data stored as tokens.\n     */\n    tokenize(items) {\n        const header = {\n            registry: {},\n            files: {},\n        };\n        const counter = { next: 0 };\n        Object.entries(items).forEach(([file, value]) => {\n            header.files[file] = {\n                nameToken: this.tokenizeHelper(file, header.registry, counter, \"header\"),\n                token: this.tokenizeHelper(value, header.registry, counter, file),\n            };\n        });\n        return header;\n    }\n    registerToken(hash, value, registry, counter, file, reference) {\n        var _a;\n        const entry = (_a = registry[hash]) !== null && _a !== void 0 ? _a : (registry[hash] = {\n            type: getType(value),\n            hash,\n            value,\n            reference,\n            order: counter.next++,\n            count: 0,\n            files: new Set(),\n        });\n        entry.files.add(file);\n        entry.count++;\n        return entry;\n    }\n    tokenizeHelper(item, registry, counter, file) {\n        const type = getType(item);\n        if (type === \"array\") {\n            if (!Array.isArray(item)) {\n                throw new Error(\"item should be an array\");\n            }\n            const hashes = item.map(item => this.tokenizeHelper(item, registry, counter, file)).map(({ hash }) => hash);\n            const hash = md5(hashes.join(\",\"));\n            return this.registerToken(hash, item, registry, counter, file, hashes);\n        }\n        else if (type === \"object\") {\n            const entries = Object.entries(item);\n            const keysToken = this.tokenizeHelper(entries.map(([key]) => key), registry, counter, file);\n            const valuesToken = this.tokenizeHelper(entries.map(([, value]) => value), registry, counter, file);\n            const hash = md5(`${keysToken.hash}|${valuesToken.hash}`);\n            return this.registerToken(hash, item, registry, counter, file, [keysToken.hash, valuesToken.hash]);\n        }\n        else if (type === \"split\") {\n            const chunks = item.split(SPLIT_REGEX);\n            const separators = item.match(SPLIT_REGEX);\n            const chunksToken = this.tokenizeHelper(chunks, registry, counter, file);\n            const separatorsToken = this.tokenizeHelper(separators, registry, counter, file);\n            const hash = md5(`${chunksToken.hash}-${separatorsToken.hash}`);\n            return this.registerToken(hash, item, registry, counter, file, [chunksToken.hash, separatorsToken.hash]);\n        }\n        else {\n            const m = md5(JSON.stringify(item));\n            return this.registerToken(m, item, registry, counter, file);\n        }\n    }\n}\n","import { StructureType } from \"../compression/DataType\";\nconst DEFAULT_CONFIG = {\n    cacheable: true,\n};\n/**\n * Class storing all data that can be extracted.\n */\nexport default class ExtractableData {\n    constructor(dataStore, config) {\n        this.extractor = new Extractor();\n        this.dataStore = dataStore;\n        this.config = Object.assign(Object.assign({}, DEFAULT_CONFIG), config);\n        this.fileNames = this.extractor.extractFileNames(dataStore.files, dataStore.headerTokens, this.config);\n        this.fileToSlot = Object.fromEntries(this.fileNames.map((file, index) => [file, index]));\n        this.version = dataStore.version;\n        this.originalDataSize = dataStore.originalDataSize;\n        this.compressedSize = dataStore.compressedSize;\n    }\n    /**\n     * Extract data form a stored file.\n     *\n     * @param filename filename to be extracted.\n     * @returns extracted data.\n     */\n    extract(filename) {\n        const slot = this.fileToSlot[filename];\n        const dataTokens = this.dataStore.getDataTokens(slot);\n        if (dataTokens) {\n            return this.extractor.extract(this.dataStore.headerTokens, dataTokens, this.config);\n        }\n    }\n    getHeaderTokens() {\n        return this.dataStore.headerTokens;\n    }\n}\nclass Extractor {\n    constructor() {\n        this.valueFetcher = {\n            \"array\": this.getArray.bind(this),\n            \"leaf\": this.getLeaf.bind(this),\n            \"object\": this.getObject.bind(this),\n            \"split\": this.getSplit.bind(this),\n            \"reference\": this.getReference.bind(this),\n            \"complex\": undefined,\n        };\n    }\n    extractFileNames(files, headerTokens, config) {\n        return files.map(index => this.extractToken(index, headerTokens, undefined, config));\n    }\n    extract(headerTokens, dataTokens, config) {\n        const tokenStream = dataTokens.entries();\n        const [, complexToken] = tokenStream.next().value;\n        const structure = complexToken.value;\n        const token = this.extractComplex(structure.entries(), tokenStream, headerTokens, [...dataTokens], config);\n        return token;\n    }\n    extractComplex(structure, tokenStream, headerTokens, dataTokens, config) {\n        const [, structureType] = structure.next().value;\n        switch (structureType) {\n            case StructureType.LEAF:\n                const [, leafToken] = tokenStream.next().value;\n                const value = this.extractValueOrCache(leafToken, headerTokens, dataTokens, config, true, this.valueFetcher[leafToken.type]);\n                return value;\n            case StructureType.ARRAY:\n                const [, numToken] = tokenStream.next().value;\n                const array = new Array(numToken.value).fill(null)\n                    .map(_ => this.extractComplex(structure, tokenStream, headerTokens, dataTokens, config));\n                return array;\n            case StructureType.OBJECT:\n                const keys = this.extractComplex(structure, tokenStream, headerTokens, dataTokens, config);\n                const values = this.extractComplex(structure, tokenStream, headerTokens, dataTokens, config);\n                const object = Object.fromEntries(keys.map((key, index) => [key, values[index]]));\n                return object;\n            case StructureType.SPLIT:\n                const chunks = this.extractComplex(structure, tokenStream, headerTokens, dataTokens, config);\n                const separators = this.extractComplex(structure, tokenStream, headerTokens, dataTokens, config);\n                const split = chunks.map((chunk, index) => { var _a; return `${chunk}${(_a = separators[index]) !== null && _a !== void 0 ? _a : \"\"}`; }).join(\"\");\n                return split;\n        }\n    }\n    extractToken(index, headerTokens, dataTokens, config, allowUseCache) {\n        const token = index < headerTokens.length ? headerTokens[index] : dataTokens === null || dataTokens === void 0 ? void 0 : dataTokens[index - headerTokens.length];\n        if (!token) {\n            throw new Error(\"Invalid token at index: \" + index);\n        }\n        return this.extractValueOrCache(token, headerTokens, dataTokens, config, allowUseCache, this.valueFetcher[token.type]);\n    }\n    getLeaf(token) {\n        return token.value;\n    }\n    getReference(token, headerTokens, dataTokens, config) {\n        const index = token.value;\n        return this.extractToken(index, headerTokens, dataTokens, config);\n    }\n    getArray(token, headerTokens, dataTokens, config) {\n        if (!Array.isArray(token.value)) {\n            throw new Error(\"Invalid array token\");\n        }\n        return token.value.map(index => this.extractToken(index, headerTokens, dataTokens, config));\n    }\n    getObject(token, headerTokens, dataTokens, config) {\n        const [keyIndex, valueIndex] = token.value;\n        const keys = this.extractToken(keyIndex, headerTokens, dataTokens, config, true);\n        const values = this.extractToken(valueIndex, headerTokens, dataTokens, config);\n        return Object.fromEntries(keys.map((key, index) => [key, values[index]]));\n    }\n    getSplit(token, headerTokens, dataTokens, config) {\n        const [chunksIndex, separatorsIndex] = token.value;\n        const chunks = this.extractToken(chunksIndex, headerTokens, dataTokens, config, true);\n        const separators = this.extractToken(separatorsIndex, headerTokens, dataTokens, config, true);\n        return chunks.map((chunk, index) => { var _a; return `${chunk}${(_a = separators[index]) !== null && _a !== void 0 ? _a : \"\"}`; }).join(\"\");\n    }\n    extractValueOrCache(token, headerTokens, dataTokens, config, allowUseCache, getValue) {\n        if (token.cache !== undefined && allowUseCache) {\n            return token.cache;\n        }\n        const value = getValue(token, headerTokens, dataTokens, config);\n        if (config.cacheable && token.type !== \"leaf\") {\n            token.cache = value;\n        }\n        return value;\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport Reducer from \"../reducer/Reducer\";\nimport { StreamDataView } from \"stream-data-view\";\nimport TokenEncoder from \"./TokenEncoder\";\nimport FFlateEncoder from \"./FFlateEncoder\";\nimport { version } from '../../package.json';\nimport Tokenizer from \"../tokenizer/Tokenizer\";\nimport ExtractableData from \"../expander/Extractor\";\nvar EncoderEnum;\n(function (EncoderEnum) {\n    EncoderEnum[EncoderEnum[\"NONE\"] = 0] = \"NONE\";\n    EncoderEnum[EncoderEnum[\"FFLATE\"] = 1] = \"FFLATE\";\n})(EncoderEnum || (EncoderEnum = {}));\n;\nconst ENCODERS = [\n    () => undefined,\n    () => new FFlateEncoder(),\n];\nconst DEFAULT = [EncoderEnum.FFLATE];\nexport default class Compressor {\n    applyEncoders(buffer, encoders) {\n        let resultBuffer = buffer;\n        encoders.forEach(encoder => {\n            resultBuffer = encoder.encode(resultBuffer);\n        });\n        return resultBuffer;\n    }\n    applyDecoders(buffer, decoders) {\n        let resultBuffer = buffer;\n        decoders.forEach(decoder => {\n            resultBuffer = decoder.decode(resultBuffer);\n        });\n        return resultBuffer;\n    }\n    /**\n     * Load json or text files and compress them into one big blob.\n     * This uses the default encoders.\n     *\n     * @param files files to load.\n     */\n    loadAndCompress(files) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const tokenizer = new Tokenizer();\n            const header = yield tokenizer.load(...files);\n            const reducer = new Reducer();\n            const dataStore = reducer.reduce(header);\n            return this.compressDataStore(dataStore);\n        });\n    }\n    /**\n     * Compress data into one big blob.\n     * This uses the default encoders.\n     *\n     * @param files files to load.\n     */\n    compress(data) {\n        const tokenizer = new Tokenizer();\n        const header = tokenizer.tokenize(data);\n        const reducer = new Reducer();\n        const dataStore = reducer.reduce(header);\n        return this.compressDataStore(dataStore);\n    }\n    loadAndExpand(file) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield fetch(file);\n            const arrayBuffer = yield response.arrayBuffer();\n            return this.expand(arrayBuffer);\n        });\n    }\n    expand(arrayBuffer, config) {\n        return new ExtractableData(this.expandDataStore(arrayBuffer), config);\n    }\n    compressDataStore(dataStore, encoderEnums = DEFAULT) {\n        var _a;\n        const streamDataView = new StreamDataView();\n        const tokenEncoder = new TokenEncoder(streamDataView);\n        //  Write header tokens\n        tokenEncoder.encodeTokens(dataStore.headerTokens, true);\n        //  Write fileNames\n        tokenEncoder.encodeNumberArray(dataStore.files);\n        const finalStream = new StreamDataView();\n        //  Write version\n        finalStream.setNextUint8(version.length);\n        finalStream.setNextString(version);\n        //  Write encoders\n        encoderEnums.forEach(encoderEnum => finalStream.setNextUint8(encoderEnum));\n        finalStream.setNextUint8(0);\n        const encoders = encoderEnums\n            .map(encoderEnum => ENCODERS[encoderEnum]())\n            .filter((encoder) => !!encoder);\n        //  Write header\n        const headerBuffer = this.applyEncoders(streamDataView.getBuffer(), encoders);\n        finalStream.setNextUint32(headerBuffer.byteLength);\n        finalStream.setNextBytes(headerBuffer);\n        console.log(\"HEADER length\", headerBuffer.byteLength);\n        //  Write each file's data tokens.\n        for (let index = 0; index < dataStore.files.length; index++) {\n            const subStream = new StreamDataView();\n            const subEncoder = new TokenEncoder(subStream);\n            subEncoder.encodeTokens(dataStore.getDataTokens(index), false);\n            //  save and compress buffer\n            const subBuffer = this.applyEncoders(subStream.getBuffer(), encoders);\n            finalStream.setNextUint32(subBuffer.byteLength);\n            console.log(\"SUBBUFFER length\", index, subBuffer.byteLength);\n            finalStream.setNextBytes(subBuffer);\n        }\n        finalStream.setNextUint32(0);\n        //  Write original data size\n        finalStream.setNextUint32((_a = dataStore.originalDataSize) !== null && _a !== void 0 ? _a : 0);\n        return finalStream.getBuffer();\n    }\n    expandDataStore(arrayBuffer) {\n        const compressedSize = arrayBuffer.byteLength;\n        let input = arrayBuffer;\n        const globalStream = new StreamDataView(input);\n        const version = globalStream.getNextString(globalStream.getNextUint8());\n        const decoders = [];\n        do {\n            const encoderEnum = globalStream.getNextUint8();\n            if (encoderEnum === EncoderEnum.NONE) {\n                break;\n            }\n            const decoder = ENCODERS[encoderEnum]();\n            if (decoder) {\n                decoders.push(decoder);\n            }\n        } while (globalStream.getOffset() < globalStream.getLength());\n        const headerByteLength = globalStream.getNextUint32();\n        const headerBuffer = this.applyDecoders(globalStream.getNextBytes(headerByteLength).buffer, decoders);\n        const headerTokenEncoder = new TokenEncoder(new StreamDataView(headerBuffer));\n        const headerTokens = headerTokenEncoder.decodeTokens(true);\n        const files = headerTokenEncoder.decodeNumberArray();\n        const subBuffers = [];\n        do {\n            const byteLength = globalStream.getNextUint32();\n            if (!byteLength) {\n                break;\n            }\n            subBuffers.push(globalStream.getNextBytes(byteLength).buffer);\n        } while (globalStream.getOffset() < globalStream.getLength());\n        const getDataTokens = (index) => {\n            const subBuffer = this.applyDecoders(subBuffers[index], decoders);\n            const streamDataView = new StreamDataView(subBuffer);\n            const tokenDecoder = new TokenEncoder(streamDataView);\n            return tokenDecoder.decodeTokens(false);\n        };\n        //  The remaining from streamDataView is extra. Some compressed data don't have it.\n        let originalDataSize;\n        try {\n            originalDataSize = globalStream.getNextUint32() || undefined;\n        }\n        catch (e) {\n        }\n        return {\n            version,\n            originalDataSize,\n            compressedSize,\n            headerTokens,\n            files,\n            getDataTokens,\n        };\n    }\n}\n","import Loader from \"./io/Loader\";\nimport TokenEncoder from \"./compression/TokenEncoder\";\nimport Compressor from \"./compression/Compressor\";\nconst exportedClasses = {\n    Loader,\n    Compressor,\n    TokenEncoder,\n};\nexport default exportedClasses;\nglobalThis.exports = exportedClasses;\n"],"names":["$","safeAdd","x","y","lsw","md5cmn","q","a","b","s","t","num","cnt","md5ff","c","d","md5gg","md5hh","md5ii","binlMD5","len","i","olda","oldb","oldc","oldd","length","binl2rstr","input","output","length32","String","fromCharCode","rstr2binl","undefined","length8","charCodeAt","rstr2hex","hexTab","charAt","str2rstrUTF8","unescape","encodeURIComponent","rawMD5","rstrMD5","rawHMACMD5","k","key","data","hash","bkey","ipad","opad","concat","rstrHMACMD5","md5","string","raw","module","exports","e","n","o","Object","defineProperty","enumerable","get","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","StreamDataView","this","encoding","decode","apply","Array","from","decodeURIComponent","escape","encode","Uint8Array","split","map","offset","autoResize","ArrayBuffer","view","DataView","littleEndian","fromByteString","fromTextString","setNextString","resize","TypeError","byteLength","slice","set","buffer","getBuffer","crop","getOffset","skip","resetOffset","setOffset","getInt8","getUint8","getNextInt8","getNextUint8","getInt16","getUint16","getNextInt16","getNextUint16","getInt32","getUint32","getNextInt32","getNextUint32","getFloat32","getFloat64","getNextFloat32","getNextFloat64","setInt8","handleAutoResize","setUint8","setNextInt8","setNextUint8","setInt16","setUint16","setNextInt16","setNextUint16","setInt32","setUint32","setNextInt32","setNextUint32","setFloat32","setFloat64","setNextFloat32","setNextFloat64","getBytes","getNextBytes","setBytes","isArray","setNextBytes","getString","indexOf","getNextString","setString","toByteString","toString","join","toUpperCase","toTextString","parseInt","getLength","clear","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","getter","__esModule","definition","obj","prop","Loader","load","file","thisArg","_arguments","generator","response","fetch","pop","extension","json","text","P","Promise","resolve","reject","fulfilled","step","next","rejected","result","done","then","StructureType","DataType","NUMBER_DATA_TYPES","UINT8","INT8","UINT16","INT16","UINT32","INT32","FLOAT32","FLOAT64","DataTypeUtils","numberSatisfyDataType","dataType","Math","fround","getBestType","array","some","number","every","min","max","getNumberDataType","type","UNDEFINED","getStringDataType","noSet","l","code","STRING","UNICODE","getFullTokenDataType","token","ARRAY_8","OBJECT_8","SPLIT_8","getDataType","COMPLEX_OBJECT","indices","console","assert","EMPTY_ARRAY","bestType","OBJECT_16","OBJECT_32","SPLIT_16","SPLIT_32","OFFSET_ARRAY_8","OFFSET_ARRAY_16","OFFSET_ARRAY_32","ARRAY_16","ARRAY_32","NULL","BOOLEAN_TRUE","BOOLEAN_FALSE","REFERENCE_8","REFERENCE_16","REFERENCE_32","Error","dataTypeToType","typeToStructureType","LEAF","ARRAY","OBJECT","SPLIT","TokenEncoder","constructor","streamDataView","dataTypeUtils","encodeTokens","tokens","organized","pos","count","encodeMulti","decodeTokens","decodeMulti","encodeToken","multiInfo","usedDataType","encodeDataType","encodeSingleNumber","encodeString","encodeObjectToken","encodeSplitToken","encodeArrayToken","encodeReferenceToken","encodeComplexToken","decodeToken","decodeDataType","UINT2","UINT4","decodeSingleNumber","decodeString","decodeObjectToken","decodeSplitToken","decodeArrayToken","decodeReferenceToken","decodeComplexToken","isOffsetDataType","arrayToken","numberType","encodeNumberArray","decodeNumberArray","objectToken","keysIndex","valuesIndex","splitToken","chunksIndex","separatorsIndex","index","structure","firstType","multiCount","maxCount","push","bit2ToNum","numToBit2","size","bit4ToNum","numToBit4","stride","transform","bytes","byte","sizeDiff","numbers","letterCodes","lastStringLength","forEach","charCodes","static","tokenEncoder","tokenDecoder","reset","testAction","header","fill","_","tester","info","check","JSON","stringify","decoded","Reducer","reduce","hashToIndex","headerTokens","createReducedHeaderTokens","filterSplit","values","registry","filter","files","has","fileEntries","entries","sort","name1","name2","localeCompare","nameToken","dataTokens","root","subHashToIndex","assign","createComplexObject","originalDataSize","getDataTokens","sortTokens","t1","t2","organizeTokens","buckets","bucket","resultTokens","chunskHash","separatorsHash","reference","chunksToken","separatorsToken","deleted","organizedTokens","_a","_b","resultDataTokens","subTokens","u8","u16","Uint16Array","u32","Uint32Array","fleb","fdeb","clim","freb","eb","start","j","fl","revfl","fd","revfd","rev","hMap","cd","mb","co","le","rvb","sv","r_1","v","m","flt","fdt","flm","flrm","fdm","fdrm","bits","p","bits16","shft","slc","BYTES_PER_ELEMENT","subarray","ec","err","ind","msg","nt","captureStackTrace","wbits","wbits16","hTree","f","et","i0","i1","i2","maxSym","tr","mbt","ln","dt","lft","cst","i2_1","i2_2","i2_3","lc","cl","cli","cln","cls","w","clen","cf","wfblk","out","dat","wblk","final","syms","lf","df","li","bs","bl","dlt","mlb","ddt","mdb","_c","lclt","nlc","_d","lcdt","ndc","lcfreq","_e","lct","mlcb","nlcc","lm","ll","dm","dl","flen","ftlen","dtlen","llm","lcts","it","clct","dst","deo","crct","Int32Array","dopt","opt","pre","post","st","lvl","plvl","lst","ceil","msk_1","prev","head","bs1_1","bs2_1","hsh","lc_1","wi","hv","imod","pimod","rem","ch_1","dif","maxn","maxd","ml","nl","mmd","md","ti","lin","din","dflt","level","mem","log","wbytes","gzipSync","opts","cr","crc","filename","fn","mtime","floor","Date","now","gzh","gunzipSync","buf","sl","noBuf","noSt","cbuf","nbuf","bt","lbt","dbt","tbts","hLit","hcLen","tl","ldt","clt","clb","clbmsk","clm","lt","lms","dms","lpos","sym","add","dsym","end","inflt","flg","zs","gzs","td","TextDecoder","stream","queueMicrotask","setTimeout","FFlateEncoder","arrayBuffer","SPLIT_REGEX","TEST_REGEX","getType","Set","test","Tokenizer","loader","sortedFiles","allData","all","tokenize","fromEntries","textEncoder","TextEncoder","items","counter","tokenizeHelper","registerToken","entry","order","item","hashes","keysToken","valuesToken","chunks","separators","match","DEFAULT_CONFIG","cacheable","ExtractableData","dataStore","config","extractor","Extractor","fileNames","extractFileNames","fileToSlot","version","compressedSize","extract","slot","getHeaderTokens","valueFetcher","getArray","bind","getLeaf","getObject","getSplit","getReference","extractToken","tokenStream","complexToken","extractComplex","structureType","leafToken","extractValueOrCache","numToken","keys","chunk","allowUseCache","keyIndex","valueIndex","getValue","cache","EncoderEnum","ENCODERS","DEFAULT","FFLATE","exportedClasses","Compressor","applyEncoders","encoders","resultBuffer","encoder","applyDecoders","decoders","decoder","loadAndCompress","tokenizer","compressDataStore","compress","loadAndExpand","expand","expandDataStore","encoderEnums","finalStream","encoderEnum","headerBuffer","subStream","subBuffer","globalStream","NONE","headerByteLength","headerTokenEncoder","subBuffers","globalThis"],"sourceRoot":""}